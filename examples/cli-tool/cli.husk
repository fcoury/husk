// CLI argument parsing and command definitions

use local::file_processor::ProcessingOptions;

pub enum Command {
    Process {
        input: string,
        output: string,
        options: ProcessingOptions,
    },
    Analyze {
        path: string,
    },
    Watch {
        directory: string,
    },
    Help,
}

pub struct CliArgs {
    pub command: Command,
}

impl CliArgs {
    pub fn parse(args: Vec<string>) -> Result<CliArgs, string> {
        if args.len() < 2 {
            return Ok(CliArgs { command: Command::Help });
        }
        
        let command_name = args[1].clone();
        
        match command_name.as_str() {
            "process" => Self::parse_process_command(args),
            "analyze" => Self::parse_analyze_command(args),
            "watch" => Self::parse_watch_command(args),
            "help" => Ok(CliArgs { command: Command::Help }),
            "--help" => Ok(CliArgs { command: Command::Help }),
            "-h" => Ok(CliArgs { command: Command::Help }),
            _ => Err(format!("Unknown command: {}", command_name)),
        }
    }
    
    fn parse_process_command(args: Vec<string>) -> Result<CliArgs, string> {
        if args.len() < 4 {
            return Err("process command requires: husk-cli process <input> <output>");
        }
        
        let input = args[2].clone();
        let output = args[3].clone();
        
        // Parse additional options
        let options = ProcessingOptions::default();
        let i = 4;
        
        while i < args.len() {
            let arg = args[i].clone();
            
            match arg.as_str() {
                "--minify" => {
                    options.minify = true;
                }
                "--transform" => {
                    if i + 1 < args.len() {
                        options.transform_type = Some(args[i + 1].clone());
                        i = i + 1;
                    } else {
                        return Err("--transform requires a value");
                    }
                }
                "--filter" => {
                    if i + 1 < args.len() {
                        options.file_filter = Some(args[i + 1].clone());
                        i = i + 1;
                    } else {
                        return Err("--filter requires a pattern");
                    }
                }
                "--verbose" => {
                    options.verbose = true;
                }
                "-v" => {
                    options.verbose = true;
                }
                _ => {
                    return Err("Unknown option");
                }
            }
            
            i = i + 1;
        }
        
        Ok(CliArgs {
            command: Command::Process { input: input, output: output, options: options }
        })
    }
    
    fn parse_analyze_command(args: Vec<string>) -> Result<CliArgs, string> {
        if args.len() < 3 {
            return Err("analyze command requires: husk-cli analyze <path>");
        }
        
        let path = args[2].clone();
        
        Ok(CliArgs {
            command: Command::Analyze { path: path }
        })
    }
    
    fn parse_watch_command(args: Vec<string>) -> Result<CliArgs, string> {
        if args.len() < 3 {
            return Err("watch command requires: husk-cli watch <directory>");
        }
        
        let directory = args[2].clone();
        
        Ok(CliArgs {
            command: Command::Watch { directory: directory }
        })
    }
}

// Command validation helpers
impl Command {
    pub fn validate(self) -> Result<(), string> {
        match self {
            Command::Process { input, output, .. } => {
                if input.len() == 0 {
                    return Err("Input path cannot be empty");
                }
                if output.len() == 0 {
                    return Err("Output path cannot be empty");
                }
                if input == output {
                    return Err("Input and output paths cannot be the same");
                }
                return Ok(());
            }
            Command::Analyze { path } => {
                if path.len() == 0 {
                    return Err("Analysis path cannot be empty");
                }
                return Ok(());
            }
            Command::Watch { directory } => {
                if directory.len() == 0 {
                    return Err("Watch directory cannot be empty");
                }
                return Ok(());
            }
            Command::Help => return Ok(()),
        }
    }
    
    pub fn description(self) -> string {
        match self {
            Command::Process { .. } => "Process files from input to output location",
            Command::Analyze { .. } => "Analyze directory structure and file statistics",
            Command::Watch { .. } => "Watch directory for file system changes",
            Command::Help => "Display help information",
        }
    }
}

// Helper function for command line usage
pub fn print_usage() {
    println("Husk CLI File Processor");
    println("");
    println("USAGE:");
    println("    husk-cli <COMMAND> [OPTIONS]");
    println("");
    println("COMMANDS:");
    println("    process <input> <output>    Process files from input to output");
    println("    analyze <path>              Analyze directory contents");
    println("    watch <directory>           Watch directory for changes");
    println("    help                        Print this help message");
    println("");
    println("PROCESS OPTIONS:");
    println("    --minify                    Minify output files");
    println("    --transform <type>          Apply transformation (js, css, html)");
    println("    --filter <pattern>          Filter files by pattern (*.js, *.css)");
    println("    --verbose, -v               Enable verbose output");
    println("");
    println("EXAMPLES:");
    println("    husk-cli process ./src ./dist --minify --filter '*.js'");
    println("    husk-cli analyze ./project");
    println("    husk-cli watch ./src --verbose");
    println("    husk-cli help");
}