// React + HX Templating Demo
//
// This example demonstrates:
// - HX templating syntax (hx { <div>...</div> })
// - Component composition with props using #[react_component]
// - Attribute mapping (class -> className)
// - Browser platform with ESM output
// - Calling JsValue functions with jsvalue_call

extern "js" {
    mod react;
    mod "react-dom/client" as react_dom_client;

    #[ns = "react_dom_client"]
    fn createRoot(element: JsValue) -> JsValue;

    // React hooks - returns [value, setter] array
    #[ns = "react"]
    fn useState(initial: JsValue) -> JsValue;
}

fn Header() -> JsValue {
    hx {
        <header class="header">
            <h1>Welcome to Husk + React</h1>
            <p>HX templating compiles to React elements</p>
        </header>
    }
}

// Feature component with props - the #[react_component] attribute generates
// a wrapper that extracts props.title and props.description from the props object
#[react_component]
fn Feature(title: String, description: String) -> JsValue {
    hx {
        <div class="feature">
            <h3>{title}</h3>
            <p>{description}</p>
        </div>
    }
}

fn FeatureList() -> JsValue {
    hx {
        <section class="features">
            <h2>Features</h2>
            <div class="feature-grid">
                <Feature title="Clean Syntax" description="Write JSX-like templates with hx blocks" />
                <Feature title="Type Safety" description="Husk's type system catches errors at compile time" />
                <Feature title="Easy Interop" description="Seamlessly call JavaScript and npm packages" />
            </div>
        </section>
    }
}

fn Counter() -> JsValue {
    // Phase 3: Native primitive conversion instead of js { 0 }
    let state = useState(jsvalue_from_int(0));

    // Extract count (index 0) and setter (index 1) from the state array
    let count = jsvalue_get(state, "0");
    let set_count = jsvalue_get(state, "1");

    // Phase 1+2: Native Husk closure with jsvalue_call and arithmetic
    // No more js blocks needed for the callback!
    let increment = || {
        jsvalue_call1(set_count, jsvalue_add_num(count, 1.0));
    };

    hx {
        <div class="counter">
            <h2>Counter Demo</h2>
            <p class="count">Count: {count}</p>
            <button onClick={increment}>Increment</button>
        </div>
    }
}

fn Footer() -> JsValue {
    hx {
        <footer class="footer">
            <p>Built with Husk - the typed language that compiles to JavaScript</p>
        </footer>
    }
}

fn App() -> JsValue {
    hx {
        <div class="app">
            <Header />
            <main>
                <Counter />
                <FeatureList />
            </main>
            <Footer />
        </div>
    }
}

fn main() {
    // Phase 4: Native browser global access instead of js block
    let root_element = jsvalue_method1_str(get_document(), "getElementById", "root");
    let root = createRoot(root_element);
    root.render(hx { <App /> });
}
