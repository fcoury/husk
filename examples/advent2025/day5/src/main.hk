extern "js" {
    mod global Math {
        fn max(x: i32, y: i32) -> i32;
        fn min(x: i32, y: i32) -> i32;
    }
}

fn main() {
    part_two()
}

fn part_two() {
    let data = include_str("input-test.txt").trim();
    let parts = data.split_once("\n\n").expect("valid input").to_array().expect("valid input").map(|d: String| d.split("\n"));

    let fresh = parts[0];
    let ingredients = parts[1];

    let ranges: [Range] = [];
    for range in fresh {
        let parts = range.split("-").map(|p: String| parse_int(p, 10));
        ranges.push(parts[0]..=parts[1]);
    }

    // contains the list of combined ranges
    // combined ranges after merging overlaps
    let new_ranges: [Range] = [];
    // contains the list of ranges that were handled already, either because
    // it's on new_ranges or it was combined
    // track ranges already processed so we don't merge twice
    let handled_list = Set::new();

    for range in ranges {
        if handled_list.has(range) {
            continue;
        }

        let handled = false;
        for cmp_range in ranges {
            if overlap(range, cmp_range) {
                new_ranges.push(combine(range, cmp_range));
                handled_list.add(cmp_range);

                handled = true;
            }
        }

        if !handled {
            new_ranges.push(range);
        }

        handled_list.add(range);
    }

    println("new ranges: {:?}", new_ranges);

    let total_numbers = 0;
    for range in new_ranges {
        total_numbers += range_len(range);
    }

    println("total: {total_numbers}");
}

fn draw(r: Range<i32>) -> String {
    let prefix = " ".repeat(r.start);
    let size = " ".repeat(range_len(r));
    format("{prefix}[{size}]")
}

fn end_exclusive(r: Range<i32>) -> i32 {
    if r.inclusive { r.end + 1 } else { r.end }
}

fn range_len(r: Range<i32>) -> i32 {
    end_exclusive(r) - r.start
}

fn combine(a: Range<i32>, b: Range<i32>) -> Range<i32> {
    let start = Math.min(a.start, b.start);

    let a_end_excl = end_exclusive(a);
    let b_end_excl = end_exclusive(b);

    // Pick the boundary that extends farthest to the right and preserve its inclusivity
    // pick the boundary that extends farthest to the right and preserve its inclusivity
    let mut end = a.end;
    let mut inclusive = a.inclusive;
    if b_end_excl > a_end_excl {
        end = b.end;
        inclusive = b.inclusive;
    }

    if inclusive {
        start..=end
    } else {
        start..end
    }
}

fn overlap(a: Range<i32>, b: Range<i32>) -> bool {
    let a_end = end_exclusive(a);
    let b_end = end_exclusive(b);

    // Half-open interval overlap test: [a.start, a_end) intersects [b.start, b_end)
    a.start < b_end && b.start < a_end
}

#[cfg(test)]
#[test]
fn test_overlap() {
    //     ....|....1....|....2....|....3....|....4....|....5
    // 1:    [ ] 
    // 2:           [   ]
    // 3:                 [   ]
    // 4:             [     ]
    // 5:                     [     ]
    // 6:                      [    ]
    // 7:          [      ]
    // 8:          [     ]      
    //
    let range1 = 3..=5;
    let range2 = 10..=14;
    let range3 = 16..=20;
    let range4 = 12..=18;
    let range5 = 21..=27;
    let range6 = 22..=27;
    let range7 = 10..=16;
    let range8 = 10..=15;

    assert_msg(!overlap(range1, range2), "1 before 2");
    assert_msg(!overlap(range2, range3), "2 before 3");
    assert_msg(overlap(range3, range4), "start of 3 < end of 4");
    assert_msg(overlap(range2, range4), "start of 5 < end of 2");
    assert_msg(overlap(range3, range5), "end of 3 = start of 5, 3 left of 5");
    assert_msg(overlap(range6, range5), "5 contains 6");
    assert_msg(overlap(range7, range3), "end of 7 = start of 3, 7 left of 3");
    assert_msg(overlap(range8, range7), "7 contains 8");
    assert_msg(!overlap(range6, range3), "before");
    assert_msg(overlap(range8, range3), "after");
}

// -------------------------------------------------

fn part_one() {
    let data = include_str("input.txt").trim();
    let parts = data.split_once("\n\n").expect("valid input").to_array().expect("valid input").map(|d: String| d.split("\n"));

    let fresh = parts[0];
    let ingredients = parts[1];

    let ranges: [Range] = [];
    for range in fresh {
        let parts = range.split("-").map(|p: String| parse_int(p, 10));
        ranges.push(parts[0]..=parts[1]);
    }

    let count = 0;
    for id in ingredients {
        let fresh = ranges.some(|r| r.contains(id));
        println("Ingredient {id} is fresh: {fresh}");
        if fresh {
            count += 1;
        }
    }

    println("{count}");
}
