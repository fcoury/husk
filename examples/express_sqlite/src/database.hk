// Auto-generated from .d.ts file
// Some types may be simplified - see warnings below

extern "js" {
    // Module exports class: `export = Database`
    mod "better-sqlite3" as better_sqlite3;

    // Database constructor as module callable
    #[js_name = "Database"]
    fn better_sqlite3(filename: Option<JsValue>, options: Option<Options>) -> Database;

    struct AbortController;
    struct AbortSignal;
    struct Abortable;
    struct AddEventListenerOptions;
    struct AddHeapSnapshotChunkEventDataType;
    struct AddInspectedHeapObjectParameterType;
    struct Address;
    struct AddressInfo;
    struct AeadParams;
    struct AesCbcParams;
    struct AesCtrParams;
    struct AesDerivedKeyParams;
    struct AesGcmParams;
    struct AesKeyAlgorithm;
    struct AesKeyGenParams;
    struct After;
    struct Agent;
    struct AgentOptions;
    struct AggregateOptions<T>;
    struct Algorithm;
    struct AlternativeServiceOptions;
    struct AnyARecord;
    struct AnyAaaaRecord;
    struct AnyCaaRecord;
    struct AnyCnameRecord;
    struct AnyMxRecord;
    struct AnyNaptrRecord;
    struct AnyNsRecord;
    struct AnyPtrRecord;
    struct AnySoaRecord;
    struct AnySrvRecord;
    struct AnyTlsaRecord;
    struct AnyTxtRecord;
    struct ApplyChangesetOptions;
    struct Argon2Parameters;
    struct Argon2Params;
    struct ArrayOptions;
    struct Assert;
    struct AssertOptions;
    struct AssertSnapshotOptions;
    struct AssertStrict;
    struct AssertionError;
    struct AssertionErrorOptions;
    struct AsymmetricKeyDetails;
    struct AsyncHook;
    struct AsyncIterator<T, TReturn, TNext>;
    struct AsyncIteratorObject<T, TReturn, TNext>;
    struct AsyncLocalStorage<T>;
    struct AsyncLocalStorageOptions;
    struct AsyncResource;
    struct AsyncResourceOptions;
    struct AttachedToTargetEventDataType;
    struct AttachedToWorkerEventDataType;
    struct AwaitPromiseParameterType;
    struct AwaitPromiseReturnType;
    struct BackupMetadata;
    struct BackupOptions;
    struct BackupProgressInfo;
    struct BalancedPool;
    struct BalancedPoolMissingUpstreamError;
    struct BaseOptions;
    struct BasePrivateKeyEncodingOptions<T>;
    struct Before;
    struct BigIntOptions;
    struct BigIntStats;
    struct BigIntStatsFs;
    struct BindOptions;
    struct Blob;
    struct BlobOptions;
    struct BlockList;
    struct BodyMixin;
    struct BodyReadable;
    struct BodyTimeoutError;
    struct BreakLocation;
    struct BreakpointResolvedEventDataType;
    struct BroadcastChannel;
    struct BrotliCompress;
    struct BrotliDecompress;
    struct BrotliOptions;
    struct Buffer;
    struct BufferConstructor;
    struct BuiltInModule;
    struct ByteLengthQueuingStrategy;
    struct CPUProfileHandle;
    struct CShakeParams;
    struct CaaRecord;
    struct Cache;
    struct CacheControlDirectives;
    struct CacheHandlerOptions;
    struct CacheKey;
    struct CacheOptions;
    struct CacheQueryOptions;
    struct CacheStorage;
    struct CacheStore;
    struct CacheValue;
    struct CallArgument;
    struct CallFrame;
    struct CallFunctionOnParameterType;
    struct CallFunctionOnReturnType;
    struct CallSite;
    struct CallSiteObject;
    struct CallTracker;
    struct CallTrackerCall;
    struct CallTrackerReportInformation;
    struct Certificate;
    struct Channel<StoreType, ContextType>;
    struct CheckPrimeOptions;
    struct ChildProcess;
    struct ChildProcessByStdio<I, O, E>;
    struct ChildProcessWithoutNullStreams;
    struct CipherCCM;
    struct CipherCCMOptions;
    struct CipherChaCha20Poly1305;
    struct CipherChaCha20Poly1305Options;
    struct CipherGCM;
    struct CipherGCMOptions;
    struct CipherInfo;
    struct CipherInfoOptions;
    struct CipherNameAndProtocol;
    struct CipherOCB;
    struct CipherOCBOptions;
    struct Cipheriv;
    struct Client;
    struct ClientBeforeConnectMessage;
    struct ClientClosedError;
    struct ClientConnectErrorMessage;
    struct ClientConnectedMessage;
    struct ClientDestroyedError;
    struct ClientHttp2Session;
    struct ClientHttp2Stream;
    struct ClientRequest;
    struct ClientRequestArgs;
    struct ClientSendHeadersMessage;
    struct ClientSessionOptions;
    struct ClientSessionRequestOptions;
    struct ClientStats;
    struct CloseEvent;
    struct CloseEventInit;
    struct CloseParameterType;
    struct Cluster;
    struct ClusterSettings;
    struct ColumnDefinition;
    struct CommonConnectionOptions;
    struct CommonExecOptions;
    struct CommonOptions;
    struct CommonSpawnOptions;
    struct CompileFunctionOptions;
    struct CompileScriptParameterType;
    struct CompileScriptReturnType;
    struct ComposedDispatcher;
    struct CompressionStream;
    struct ConnectData<TOpaque>;
    struct ConnectOptions<TOpaque>;
    struct ConnectParams;
    struct ConnectTimeoutError;
    struct ConnectionOptions;
    struct Console;
    struct ConsoleAPICalledEventDataType;
    struct ConsoleConstructor;
    struct ConsoleConstructorOptions;
    struct ConsoleMessage;
    struct ConsoleProfileFinishedEventDataType;
    struct ConsoleProfileStartedEventDataType;
    struct Context;
    struct ContextParams;
    struct ContinueToLocationParameterType;
    struct Control;
    struct Cookie;
    struct CopyOptions;
    struct CopyOptionsBase;
    struct CopySyncOptions;
    struct CountQueuingStrategy;
    struct CoverageRange;
    struct CpuInfo;
    struct CpuUsage;
    struct CreateContextOptions;
    struct CreateHistogramOptions;
    struct CreateReadStreamFSImplementation;
    struct CreateReadStreamOptions;
    struct CreateSessionOptions;
    struct CreateTracingOptions;
    struct CreateWriteStreamFSImplementation;
    struct CreateWriteStreamOptions;
    struct Crypto;
    struct CryptoKey;
    struct CryptoKeyPair;
    struct CursorPos;
    struct CustomEvent<T>;
    struct CustomEventInit<T>;
    struct CustomPreview;
    struct CustomPromisifyLegacy<TCustom>;
    struct CustomPromisifySymbol<TCustom>;
    struct DOMException;
    struct DSAKeyPairKeyObjectOptions;
    struct DSAKeyPairOptions<PubF, PrivF>;
    struct DataCollectedEventDataType;
    struct DataReceivedEventDataType;
    struct Database;
    struct DatabaseConstructor;
    struct DatabaseSync;
    struct DatabaseSyncOptions;
    struct DebugLogger;
    struct DecipherCCM;
    struct DecipherChaCha20Poly1305;
    struct DecipherGCM;
    struct DecipherOCB;
    struct Decipheriv;
    struct DecompressionStream;
    struct DecoratorHandler;
    struct DefaultDeserializer;
    struct DefaultSerializer;
    struct Deflate;
    struct DeflateRaw;
    struct DeleteByUri;
    struct Deserializer;
    struct DetachParameterType;
    struct DetachedFromWorkerEventDataType;
    struct DetailedPeerCertificate;
    struct Dict<T>;
    struct DiffieHellman;
    struct DiffieHellmanGroupConstructor;
    struct Dir;
    struct Dirent<Name>;
    struct DispatchController;
    struct DispatchHandler;
    struct DispatchInterceptor;
    struct DispatchOptions;
    struct Dispatcher;
    struct DisposableTempDir;
    struct Domain;
    struct DropArgument;
    struct Duplex;
    struct DuplexOptions<T>;
    struct ECDH;
    struct ECKeyPairKeyObjectOptions;
    struct ECKeyPairOptions<PubF, PrivF>;
    struct ED25519KeyPairKeyObjectOptions;
    struct ED25519KeyPairOptions<PubF, PrivF>;
    struct ED448KeyPairKeyObjectOptions;
    struct ED448KeyPairOptions<PubF, PrivF>;
    struct EcKeyAlgorithm;
    struct EcKeyGenParams;
    struct EcKeyImportParams;
    struct EcdhKeyDeriveParams;
    struct EcdsaParams;
    struct EmitWarningOptions;
    struct EnableCompileCacheResult;
    struct EnableParameterType;
    struct EnableReturnType;
    struct EncapsulatedBits;
    struct EncapsulatedKey;
    struct EncodeIntoResult;
    struct EntryPreview;
    struct EnvHttpProxyAgent;
    struct EphemeralKeyInfo;
    struct ErrnoException;
    struct Error;
    struct ErrorConstructor;
    struct ErrorEvent;
    struct ErrorEventInit;
    struct EvaluateOnCallFrameParameterType;
    struct EvaluateOnCallFrameReturnType;
    struct EvaluateParameterType;
    struct EvaluateReturnType;
    struct Event;
    struct EventEmitter<T>;
    struct EventEmitterAsyncResource;
    struct EventEmitterAsyncResourceOptions;
    struct EventEmitterOptions;
    struct EventEmitterReferencingAsyncResource;
    struct EventInit;
    struct EventListener;
    struct EventListenerObject;
    struct EventListenerOptions;
    struct EventLoopMonitorOptions;
    struct EventLoopUtilization;
    struct EventSource;
    struct EventSourceEventMap;
    struct EventSourceInit;
    struct EventTarget;
    struct ExceptionDetails;
    struct ExceptionRevokedEventDataType;
    struct ExceptionThrownEventDataType;
    struct ExecException;
    struct ExecFileOptions;
    struct ExecFileOptionsWithBufferEncoding;
    struct ExecFileOptionsWithOtherEncoding;
    struct ExecFileOptionsWithStringEncoding;
    struct ExecFileSyncOptions;
    struct ExecFileSyncOptionsWithBufferEncoding;
    struct ExecFileSyncOptionsWithStringEncoding;
    struct ExecOptions;
    struct ExecOptionsWithBufferEncoding;
    struct ExecOptionsWithStringEncoding;
    struct ExecSyncOptions;
    struct ExecSyncOptionsWithBufferEncoding;
    struct ExecSyncOptionsWithStringEncoding;
    struct ExecutionContextCreatedEventDataType;
    struct ExecutionContextDescription;
    struct ExecutionContextDestroyedEventDataType;
    struct FSImplementation;
    struct FSWatcher;
    struct File;
    struct FileChangeInfo<T>;
    struct FileHandle;
    struct FileOptions;
    struct FileReadOptions<T>;
    struct FileReadResult<T>;
    struct FileUrlToPathOptions;
    struct FilterCallsObjectCriteria;
    struct FilterCallsOptions;
    struct FinalizeBindingsOptions;
    struct FinishedOptions;
    struct FlagAndOpenMode;
    struct ForkOptions;
    struct FormData;
    struct FormatInputPathObject;
    struct FunctionCoverage;
    struct FunctionOptions;
    struct GCFunction;
    struct GCOptions;
    struct GCProfiler;
    struct GCProfilerResult;
    struct GeneratePrimeOptions;
    struct GeneratePrimeOptionsArrayBuffer;
    struct GeneratePrimeOptionsBigInt;
    struct GetBestEffortCoverageReturnType;
    struct GetCallSitesOptions;
    struct GetCategoriesReturnType;
    struct GetDomainsReturnType;
    struct GetHeapObjectIdParameterType;
    struct GetHeapObjectIdReturnType;
    struct GetObjectByHeapObjectIdParameterType;
    struct GetObjectByHeapObjectIdReturnType;
    struct GetPossibleBreakpointsParameterType;
    struct GetPossibleBreakpointsReturnType;
    struct GetPropertiesParameterType;
    struct GetPropertiesReturnType;
    struct GetRequestPostDataParameterType;
    struct GetRequestPostDataReturnType;
    struct GetResponseBodyParameterType;
    struct GetResponseBodyReturnType;
    struct GetSamplingProfileReturnType;
    struct GetScriptSourceParameterType;
    struct GetScriptSourceReturnType;
    struct GetStackTraceParameterType;
    struct GetStackTraceReturnType;
    struct GlobOptions;
    struct GlobOptionsWithFileTypes;
    struct GlobOptionsWithoutFileTypes;
    struct GlobalLexicalScopeNamesParameterType;
    struct GlobalLexicalScopeNamesReturnType;
    struct Gunzip;
    struct Gzip;
    struct H2CClient;
    struct HRTime;
    struct HTTP2ServerCommon;
    struct HTTPParserError;
    struct Hash;
    struct HashOptions;
    struct Headers;
    struct HeadersOverflowError;
    struct HeadersTimeoutError;
    struct HeapCodeStatistics;
    struct HeapInfo;
    struct HeapProfileHandle;
    struct HeapSnapshotOptions;
    struct HeapSpaceInfo;
    struct HeapSpaceStatistics;
    struct HeapStatistics;
    struct HeapStatsUpdateEventDataType;
    struct Histogram;
    struct HkdfParams;
    struct Hmac;
    struct HmacImportParams;
    struct HmacKeyAlgorithm;
    struct HmacKeyGenParams;
    struct HookCallbacks;
    struct HookOptions;
    struct Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct Http2ServerRequest;
    struct Http2ServerResponse<Request>;
    struct Http2Session;
    struct Http2Stream;
    struct Immediate;
    struct ImportAttributes;
    struct ImportMeta;
    struct IncomingHttpHeaders;
    struct IncomingHttpStatusHeader;
    struct IncomingMessage;
    struct Inflate;
    struct InflateRaw;
    struct InformationEvent;
    struct InformationalError;
    struct Init;
    struct Initiator;
    struct InspectOptions;
    struct InspectOptionsStylized;
    struct InspectRequestedEventDataType;
    struct InspectorConsole;
    struct InspectorNotification<T>;
    struct Interceptable;
    struct Interface;
    struct InternalPropertyDescriptor;
    struct IntervalHistogram;
    struct InvalidArgumentError;
    struct InvalidReturnValueError;
    struct IpcNetConnectOpts;
    struct IpcSocketConnectOpts;
    struct IsDeepStrictEqualOptions;
    struct Iterator<T, TReturn, TNext>;
    struct IteratorObject<T, TReturn, TNext>;
    struct JsonWebKey;
    struct JsonWebKeyInput;
    struct JwkKeyExportOptions;
    struct Key;
    struct KeyAlgorithm;
    struct KeyExportOptions<T>;
    struct KeyObject;
    struct KeyPairKeyObjectResult;
    struct KeyPairSyncResult<T1, T2>;
    struct KmacImportParams;
    struct KmacKeyAlgorithm;
    struct KmacKeyGenParams;
    struct KmacParams;
    struct LastSeenObjectIdEventDataType;
    struct LcovReporter;
    struct ListenOptions;
    struct LoadFnOutput;
    struct LoadHookContext;
    struct LoadNetworkResourcePageResult;
    struct LoadNetworkResourceParameterType;
    struct LoadNetworkResourceReturnType;
    struct LoadingFailedEventDataType;
    struct LoadingFinishedEventDataType;
    struct Location;
    struct LocationInfo;
    struct Lock;
    struct LockGrantedCallback<T>;
    struct LockInfo;
    struct LockManager;
    struct LockManagerSnapshot;
    struct LockOptions;
    struct LookupAddress;
    struct LookupAllOptions;
    struct LookupOneOptions;
    struct LookupOptions;
    struct MIMEParams;
    struct MIMEType;
    struct MLDSAKeyPairKeyObjectOptions;
    struct MLDSAKeyPairOptions<PubF, PrivF>;
    struct MLKEMKeyPairKeyObjectOptions;
    struct MLKEMKeyPairOptions<PubF, PrivF>;
    struct MakeDirectoryOptions;
    struct MarkOptions;
    struct MaxOriginsReachedError;
    struct MeasureMemoryOptions;
    struct MeasureOptions;
    struct MemoryCacheStore;
    struct MemoryCacheStoreOpts;
    struct MemoryMeasurement;
    struct MemoryUsage;
    struct MemoryUsageFn;
    struct MessageAddedEventDataType;
    struct MessageChannel;
    struct MessageEvent<T>;
    struct MessageEventInit<T>;
    struct MessageOptions;
    struct MessagePort;
    struct MessagingOptions;
    struct MockAgent<TMockAgentOptions>;
    struct MockCallHistory;
    struct MockCallHistoryLog;
    struct MockClient;
    struct MockDispatch<TData, TError>;
    struct MockDispatchData<TData, TError>;
    struct MockFunctionCall<F, ReturnType, Args>;
    struct MockFunctionContext<F>;
    struct MockFunctionOptions;
    struct MockInterceptor;
    struct MockMethodOptions;
    struct MockModuleContext;
    struct MockModuleOptions;
    struct MockNotMatchedError;
    struct MockPool;
    struct MockPropertyContext<PropertyType>;
    struct MockResponseCallbackOptions;
    struct MockResponseOptions;
    struct MockScope<TData>;
    struct MockTimers;
    struct MockTimersOptions;
    struct MockTracker;
    struct Module;
    struct ModuleEvaluateOptions;
    struct ModuleHooks;
    struct ModuleRequest;
    struct MultiCacheQueryOptions;
    struct MxRecord;
    struct NaptrRecord;
    struct Navigator;
    struct NetworkInterfaceBase;
    struct NetworkInterfaceInfoIPv4;
    struct NetworkInterfaceInfoIPv6;
    struct NodeEventTarget;
    struct NodeGCPerformanceDetail;
    struct NodeModule;
    struct NodeRequire;
    struct NotSupportedError;
    struct NotifyWhenWaitingForDisconnectParameterType;
    struct ObjectEncodingOptions;
    struct ObjectPreview;
    struct OnReadOpts;
    struct OneShotDigestOptions;
    struct OneShotDigestOptionsWithBufferEncoding;
    struct OneShotDigestOptionsWithStringEncoding;
    struct OpenAsBlobOptions;
    struct OpenDirOptions;
    struct Options;
    struct OptionsInterceptors;
    struct OutgoingHttpHeaders;
    struct OutgoingMessage<Request>;
    struct PSKCallbackNegotation;
    struct ParseArgsConfig;
    struct ParseArgsOptionDescriptor;
    struct ParseArgsOptionsConfig;
    struct ParseOptions;
    struct ParsedPath;
    struct ParsedUrlQuery;
    struct ParsedUrlQueryInput;
    struct PassThrough;
    struct PathToFileUrlOptions;
    struct PauseOnAsyncCallParameterType;
    struct PausedEventDataType;
    struct Pbkdf2Params;
    struct PeerCertificate;
    struct PendingInterceptor;
    struct PendingInterceptorsFormatter;
    struct Performance;
    struct PerformanceEntry;
    struct PerformanceMark;
    struct PerformanceMeasure;
    struct PerformanceNodeTiming;
    struct PerformanceObserver;
    struct PerformanceObserverEntryList;
    struct PerformanceResourceTiming;
    struct Pipe;
    struct PipelineHandlerData<TOpaque>;
    struct PipelineOptions<TOpaque>;
    struct PlatformPath;
    struct Pool;
    struct PoolStats;
    struct PositionTickInfo;
    struct PragmaOptions;
    struct PrivateKeyInput;
    struct Process;
    struct ProcessConfig;
    struct ProcessEnv;
    struct ProcessEnvOptions;
    struct ProcessFeatures;
    struct ProcessPermission;
    struct ProcessRelease;
    struct ProcessReport;
    struct ProcessVersions;
    struct Profile;
    struct ProfileNode;
    struct PromiseHooks;
    struct PromiseWithChild<T>;
    struct PropertyDescriptor;
    struct PropertyPreview;
    struct ProxyAgent;
    struct ProxyEnv;
    struct PublicKeyInput;
    struct PxfObject;
    struct QueryObjectsParameterType;
    struct QueryObjectsReturnType;
    struct QueuingStrategy<T>;
    struct QueuingStrategyInit;
    struct QueuingStrategySize<T>;
    struct REPLCommand;
    struct REPLServer;
    struct REPLServerSetupHistoryOptions;
    struct RSAKeyPairKeyObjectOptions;
    struct RSAKeyPairOptions<PubF, PrivF>;
    struct RSAPSSKeyPairKeyObjectOptions;
    struct RSAPSSKeyPairOptions<PubF, PrivF>;
    struct RandomUUIDOptions;
    struct ReadAsyncOptions<T>;
    struct ReadLineOptions;
    struct ReadOnlyDict<T>;
    struct ReadOptions;
    struct ReadOptionsWithBuffer<T>;
    struct ReadParameterType;
    struct ReadReturnType;
    struct ReadStream;
    struct ReadStreamOptions;
    struct ReadSyncOptions;
    struct ReadVResult<T>;
    struct ReadWriteStream;
    struct Readable;
    struct ReadableByteStreamController;
    struct ReadableByteStreamControllerCallback;
    struct ReadableOptions<T>;
    struct ReadableStream;
    struct ReadableStreamAsyncIterator<T>;
    struct ReadableStreamBYOBReader;
    struct ReadableStreamBYOBRequest;
    struct ReadableStreamDefaultController<R>;
    struct ReadableStreamDefaultReader<R>;
    struct ReadableStreamErrorCallback;
    struct ReadableStreamGenericReader;
    struct ReadableStreamGetReaderOptions;
    struct ReadableStreamReadDoneResult<T>;
    struct ReadableStreamReadValueResult<T>;
    struct ReadableWebStreamOptions;
    struct ReadableWritablePair<R, W>;
    struct Readline;
    struct ReceivedMessageFromWorkerEventDataType;
    struct RecordWithTtl;
    struct RecordableHistogram;
    struct Recoverable;
    struct RedirectHandler;
    struct RefCounted;
    struct RegisterHooksOptions;
    struct RegisterOptions<Data>;
    struct RegistrationOptions;
    struct ReleaseObjectGroupParameterType;
    struct ReleaseObjectParameterType;
    struct RemoteInfo;
    struct RemoteObject;
    struct RemoveBreakpointParameterType;
    struct ReplOptions;
    struct ReportHeapSnapshotProgressEventDataType;
    struct ReporterConstructorWrapper<T>;
    struct Request;
    struct RequestAbortedError;
    struct RequestBodyChunkReceivedMessage;
    struct RequestBodyChunkSentMessage;
    struct RequestBodySentMessage;
    struct RequestContentLengthMismatchError;
    struct RequestCreateMessage;
    struct RequestErrorMessage;
    struct RequestHeadersMessage;
    struct RequestInit;
    struct RequestOptions<TOpaque>;
    struct RequestRetryError;
    struct RequestTrailersMessage;
    struct RequestWillBeSentEventDataType;
    struct Require;
    struct RequireExtensions;
    struct RequireResolve;
    struct RequireResolveOptions;
    struct ResolveFnOutput;
    struct ResolveHookContext;
    struct ResolveOptions;
    struct ResolveWithTtlOptions;
    struct Resolver;
    struct ResolverOptions;
    struct ResourceLimits;
    struct ResourceUsage;
    struct Response;
    struct ResponseContentLengthMismatchError;
    struct ResponseData<TOpaque>;
    struct ResponseError;
    struct ResponseExceededMaxSizeError;
    struct ResponseInit;
    struct ResponseReceivedEventDataType;
    struct RestartFrameParameterType;
    struct RestartFrameReturnType;
    struct RetryAgent;
    struct RetryHandler;
    struct RetryHandlers;
    struct RetryOptions;
    struct RmDirOptions;
    struct RmOptions;
    struct RsaHashedImportParams;
    struct RsaHashedKeyAlgorithm;
    struct RsaHashedKeyGenParams;
    struct RsaKeyAlgorithm;
    struct RsaKeyGenParams;
    struct RsaOaepParams;
    struct RsaOtherPrimesInfo;
    struct RsaPrivateKey;
    struct RsaPssParams;
    struct RsaPublicKey;
    struct RunOptions;
    struct RunResult;
    struct RunScriptParameterType;
    struct RunScriptReturnType;
    struct RunningCodeInNewContextOptions;
    struct RunningCodeOptions;
    struct RunningScriptInNewContextOptions;
    struct RunningScriptOptions;
    struct SLHDSAKeyPairKeyObjectOptions;
    struct SLHDSAKeyPairOptions<PubF, PrivF>;
    struct SQLTagStore;
    struct SamplingHeapProfile;
    struct SamplingHeapProfileNode;
    struct Scheduler;
    struct Scope;
    struct Script;
    struct ScriptCoverage;
    struct ScriptFailedToParseEventDataType;
    struct ScriptOptions;
    struct ScriptParsedEventDataType;
    struct ScriptPosition;
    struct ScryptOptions;
    struct SearchInContentParameterType;
    struct SearchInContentReturnType;
    struct SearchMatch;
    struct SecureClientSessionOptions;
    struct SecureContext;
    struct SecureContextOptions;
    struct SecureHeapUsage;
    struct SecureProxyConnectionError;
    struct SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct SendMessageToWorkerParameterType;
    struct SerializeOptions;
    struct Serializer;
    struct Server;
    struct ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct ServerHttp2Stream;
    struct ServerOptions<Request, Response>;
    struct ServerOpts;
    struct ServerResponse<Request>;
    struct ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct ServerStreamFileResponseOptions;
    struct ServerStreamFileResponseOptionsWithError;
    struct ServerStreamResponseOptions;
    struct Session;
    struct SessionOptions;
    struct SessionState;
    struct SetAsyncCallStackDepthParameterType;
    struct SetAutoAttachParameterType;
    struct SetBlackboxPatternsParameterType;
    struct SetBlackboxedRangesParameterType;
    struct SetBreakpointByUrlParameterType;
    struct SetBreakpointByUrlReturnType;
    struct SetBreakpointParameterType;
    struct SetBreakpointReturnType;
    struct SetBreakpointsActiveParameterType;
    struct SetCustomObjectFormatterEnabledParameterType;
    struct SetPauseOnExceptionsParameterType;
    struct SetReturnValueParameterType;
    struct SetSamplingIntervalParameterType;
    struct SetScriptSourceParameterType;
    struct SetScriptSourceReturnType;
    struct SetSkipAllPausesParameterType;
    struct SetSourceMapsSupportOptions;
    struct SetVariableValueParameterType;
    struct Settings;
    struct Settled;
    struct Sign;
    struct SignJsonWebKeyInput;
    struct SignKeyObjectInput;
    struct SignPrivateKeyInput;
    struct SigningOptions;
    struct Snapshot;
    struct SnapshotAgent;
    struct SnapshotData;
    struct SnapshotInfo;
    struct SnapshotRecorder;
    struct SoaRecord;
    struct Socket;
    struct SocketAddress;
    struct SocketAddressInitOptions;
    struct SocketConstructorOpts;
    struct SocketError;
    struct SocketInfo;
    struct SocketOptions;
    struct SourceMap;
    struct SourceMapConstructorOptions;
    struct SourceMapPayload;
    struct SourceMapping;
    struct SourceMapsSupport;
    struct SourceOrigin;
    struct SourceTextModule;
    struct SourceTextModuleOptions;
    struct SpawnOptions;
    struct SpawnOptionsWithStdioTuple<Stdin, Stdout, Stderr>;
    struct SpawnOptionsWithoutStdio;
    struct SpawnSyncOptions;
    struct SpawnSyncOptionsWithBufferEncoding;
    struct SpawnSyncOptionsWithStringEncoding;
    struct SpawnSyncReturns<T>;
    struct SpecIterable<T>;
    struct SpecIterableIterator<T>;
    struct SpecIterator<T, TReturn, TNext>;
    struct SpecReporter;
    struct SqliteCacheStore;
    struct SqliteCacheStoreOpts;
    struct SqliteErrorClass;
    struct SrvRecord;
    struct StackTrace;
    struct StackTraceId;
    struct StartParameterType;
    struct StartPreciseCoverageParameterType;
    struct StartSamplingParameterType;
    struct StartTrackingHeapObjectsParameterType;
    struct StatFsOptions;
    struct StatOptions;
    struct StatSyncFn;
    struct StatSyncOptions;
    struct StatWatcher;
    struct Statement<BindParameters, Result>;
    struct StatementColumnMetadata;
    struct StatementResultingChanges;
    struct StatementSync;
    struct StaticEventEmitterIteratorOptions;
    struct StaticEventEmitterOptions;
    struct Stats;
    struct StatsBase<T>;
    struct StatsFs;
    struct StatsFsBase<T>;
    struct StepIntoParameterType;
    struct StopReturnType;
    struct StopSamplingReturnType;
    struct StopTrackingHeapObjectsParameterType;
    struct Storage;
    struct Stream;
    struct StreamData<TOpaque>;
    struct StreamFactoryData<TOpaque>;
    struct StreamOptions;
    struct StreamPipeOptions;
    struct StreamResourceContentParameterType;
    struct StreamResourceContentReturnType;
    struct StreamState;
    struct StringDecoder;
    struct StringifyOptions;
    struct StripTypeScriptTypesOptions;
    struct StyleTextOptions;
    struct SubtleCrypto;
    struct SuiteContext;
    struct SyntheticModule;
    struct SyntheticModuleOptions;
    struct TLSSocket;
    struct TLSSocketOptions;
    struct TakeHeapSnapshotParameterType;
    struct TakePreciseCoverageReturnType;
    struct TargetCreatedEventDataType;
    struct TargetInfo;
    struct TcpNetConnectOpts;
    struct TcpSocketConnectOpts;
    struct TestComplete;
    struct TestContext;
    struct TestContextAssert;
    struct TestContextPlanOptions;
    struct TestContextWaitForOptions;
    struct TestCoverage;
    struct TestDequeue;
    struct TestDiagnostic;
    struct TestEnqueue;
    struct TestFail;
    struct TestOptions;
    struct TestPass;
    struct TestPlan;
    struct TestShard;
    struct TestStart;
    struct TestStderr;
    struct TestStdout;
    struct TestSummary;
    struct TestsStream;
    struct TextDecoder;
    struct TextDecoderOptions;
    struct TextDecoderStream;
    struct TextEncoder;
    struct TextEncoderStream;
    struct Timeout;
    struct Timer;
    struct TimerOptions;
    struct TimerifyOptions;
    struct TlsOptions;
    struct TlsaRecord;
    struct TraceConfig;
    struct Tracing;
    struct TracingChannel<StoreType, ContextType>;
    struct TracingChannelCollection<StoreType, ContextType>;
    struct TracingChannelSubscribers<ContextType>;
    struct Transaction<F>;
    struct Transform;
    struct TransformOptions<T>;
    struct TransformStream<I, O>;
    struct TransformStreamDefaultController<O>;
    struct Transformer<I, O>;
    struct TransformerCancelCallback;
    struct TransformerFlushCallback<O>;
    struct TransformerStartCallback<O>;
    struct TransformerTransformCallback<I, O>;
    struct URL;
    struct URLFormatOptions;
    struct URLPattern;
    struct URLPatternComponentResult;
    struct URLPatternInit;
    struct URLPatternOptions;
    struct URLPatternResult;
    struct URLSearchParams;
    struct URLSearchParamsIterator<T>;
    struct UVMetrics;
    struct UnderlyingByteSource;
    struct UnderlyingSink<W>;
    struct UnderlyingSinkAbortCallback;
    struct UnderlyingSinkCloseCallback;
    struct UnderlyingSinkStartCallback;
    struct UnderlyingSinkWriteCallback<W>;
    struct UnderlyingSource<R>;
    struct UnderlyingSourceCancelCallback;
    struct UnderlyingSourcePullCallback<R>;
    struct UnderlyingSourceStartCallback<R>;
    struct UndiciError;
    struct Unzip;
    struct UpgradeData<TOpaque>;
    struct UpgradeOptions;
    struct Url;
    struct UrlObject;
    struct UrlWithParsedQuery;
    struct UrlWithStringQuery;
    struct UserInfo<T>;
    struct UserInfoOptions;
    struct UserInfoOptionsWithBufferEncoding;
    struct UserInfoOptionsWithStringEncoding;
    struct Utf8Stream;
    struct Utf8StreamOptions;
    struct Verify;
    struct VerifyJsonWebKeyInput;
    struct VerifyKeyObjectInput;
    struct VerifyPublicKeyInput;
    struct VirtualTableOptions;
    struct WASI;
    struct WASIOptions;
    struct WatchFileOptions;
    struct WatchOptions;
    struct WatchOptionsWithBufferEncoding;
    struct WatchOptionsWithStringEncoding;
    struct WebSocket;
    struct WebSocketCloseInfo;
    struct WebSocketClosedEventDataType;
    struct WebSocketCreatedEventDataType;
    struct WebSocketError;
    struct WebSocketEventMap;
    struct WebSocketHandshakeResponseReceivedEventDataType;
    struct WebSocketInit;
    struct WebSocketResponse;
    struct WebSocketStream;
    struct WebSocketStreamOptions;
    struct Worker;
    struct WorkerInfo;
    struct WorkerOptions;
    struct WorkerPerformance;
    struct Writable;
    struct WritableOptions<T>;
    struct WritableStream;
    struct WritableStreamDefaultController;
    struct WritableStreamDefaultWriter<W>;
    struct WriteOptions;
    struct WriteStream;
    struct WriteStreamOptions;
    struct WriteVResult<T>;
    struct X25519KeyPairKeyObjectOptions;
    struct X25519KeyPairOptions<PubF, PrivF>;
    struct X448KeyPairKeyObjectOptions;
    struct X448KeyPairOptions<PubF, PrivF>;
    struct X509Certificate;
    struct X509CheckOptions;
    struct Zlib;
    struct ZlibOptions;
    struct ZlibParams;
    struct ZlibReset;
    struct ZstdCompress;
    struct ZstdDecompress;
    struct ZstdOptions;
    struct _GlobOptions<T>;
    struct connector;
    struct ucs2;

    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    fn checkPrime(value: JsValue, options: CheckPrimeOptions, callback: Option<fn(Option<JsValue>, bool) -> ()>);
    fn deflateSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    fn createGunzip(options: Option<ZlibOptions>) -> Gunzip;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 4 overloads
    fn generatePrime(size: f64, options: GeneratePrimeOptionsBigInt, callback: Option<fn(Option<JsValue>, i64) -> ()>);
    // merged from 2 overloads
    // variable
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    fn stripTypeScriptTypes(code: String, options: Option<StripTypeScriptTypesOptions>) -> String;
    // constant
    fn createHash(algorithm: String, options: Option<HashOptions>) -> Hash;
    // constant
    // merged from 2 overloads
    fn createDeflateRaw(options: Option<ZlibOptions>) -> DeflateRaw;
    // constant
    // constant
    // merged from 4 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn cache(opts: Option<CacheOptions>) -> fn(JsValue) -> JsValue;
    // type params simplified: Http1Request, Http1Response, Http2Request, Http2Response
    fn performServerHandshake(socket: Duplex, options: Option<ServerOptions<JsValue, JsValue, JsValue, JsValue>>) -> ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // merged from 23 overloads
    // merged from 2 overloads
    // constant
    fn zstdCompressSync(buf: JsValue, options: Option<ZstdOptions>) -> JsValue;
    // constant
    // type params simplified: T
    fn isDeepStrictEqual(val1: JsValue, val2: JsValue, options: Option<IsDeepStrictEqualOptions>) -> bool;
    fn monitorEventLoopDelay(options: Option<EventLoopMonitorOptions>) -> IntervalHistogram;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn deflateRawSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    fn cp(source: JsValue, destination: JsValue, opts: CopyOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // merged from 4 overloads
    fn get(url: JsValue, options: RequestOptions, callback: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // merged from 20 overloads
    fn spawn(command: String, args: Option<JsArray<String>>, options: Option<SpawnOptionsWithoutStdio>) -> ChildProcessWithoutNullStreams;
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    // variable
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 4 overloads
    fn execSync(command: String, options: Option<ExecSyncOptionsWithStringEncoding>) -> String;
    // variable
    // merged from 2 overloads
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // type params simplified: T
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn inflateRawSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // variable
    fn gunzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // constant
    // merged from 3 overloads
    fn watchFile(filename: JsValue, options: Option<WatchFileOptions>, listener: Option<JsValue>) -> StatWatcher;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // type params simplified: T
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // type params simplified: T
    // constant
    // constant
    // constant
    // constant
    // merged from 8 overloads
    fn glob(pattern: JsValue, options: Option<GlobOptionsWithFileTypes>, callback: Option<fn(Option<ErrnoException>, JsArray<Dirent>) -> ()>);
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn createInflateRaw(options: Option<ZlibOptions>) -> InflateRaw;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    fn createZstdDecompress(options: Option<ZstdOptions>) -> ZstdDecompress;
    // constant
    // merged from 3 overloads
    fn fstatSync(fd: f64, options: Option<StatOptions>) -> Stats;
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    fn afterEach(fn_: Option<JsValue>, options: Option<HookOptions>);
    // merged from 2 overloads
    fn brotliDecompress(buf: JsValue, options: BrotliOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // variable
    // constant
    // constant
    fn styleText(format: JsValue, text: String, options: Option<StyleTextOptions>) -> String;
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 6 overloads
    fn resolve4(hostname: String, options: Option<ResolveWithTtlOptions>, callback: Option<fn(Option<ErrnoException>, JsArray<RecordWithTtl>) -> ()>);
    // merged from 2 overloads
    // type params simplified: StoreType, ContextType
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    fn opendirSync(path: JsValue, options: Option<OpenDirOptions>) -> Dir;
    // constant
    // constant
    // constant
    // constant
    // type params simplified: T
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn gzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // type params simplified: T
    // constant
    // constant
    // variable
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn inflateRaw(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    // merged from 55 overloads
    fn generateKeyPair(type_: String, options: RSAKeyPairOptions<String, String>, callback: fn(Option<JsValue>, String, String) -> ());
    // constant
    // constant
    // constant
    // merged from 3 overloads
    fn mkdirSync(path: JsValue, options: MakeDirectoryOptions) -> Option<String>;
    // constant
    // constant
    // merged from 3 overloads
    // merged from 14 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // type params simplified: T
    fn randomUUID(options: Option<RandomUUIDOptions>) -> String;
    // constant
    // type params simplified: T
    // constant
    // merged from 6 overloads
    fn resolve6(hostname: String, options: Option<ResolveWithTtlOptions>, callback: Option<fn(Option<ErrnoException>, JsArray<RecordWithTtl>) -> ()>);
    // constant
    // constant
    // constant
    // variable
    // constant
    // constant
    // merged from 3 overloads
    fn register(specifier: JsValue, parentURL: Option<JsValue>, options: Option<RegisterOptions<JsValue>>);
    // merged from 4 overloads
    fn exec(command: String, options: ExecOptionsWithBufferEncoding, callback: Option<fn(Option<ExecException>, JsValue, JsValue) -> ()>) -> ChildProcess;
    // merged from 2 overloads
    // constant
    // constant
    // variable
    fn replDefaults() -> InspectOptions;
    // constant
    // constant
    fn createDeflate(options: Option<ZlibOptions>) -> Deflate;
    // constant
    // merged from 7 overloads
    // constant
    // constant
    // constant
    fn createUnzip(options: Option<ZlibOptions>) -> Unzip;
    // merged from 3 overloads
    fn setImmediate(value: Option<JsValue>, options: Option<TimerOptions>) -> JsPromise<JsValue>;
    // constant
    // constant
    // merged from 4 overloads
    // variable
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // variable
    fn defaultOptions() -> InspectOptions;
    // type params simplified: T
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    fn opendir(path: JsValue, options: OpenDirOptions, cb: Option<fn(Option<ErrnoException>, Dir) -> ()>);
    // merged from 7 overloads
    // merged from 2 overloads
    // constant
    // merged from 3 overloads
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    fn createZstdCompress(options: Option<ZstdOptions>) -> ZstdCompress;
    // constant
    // constant
    // constant
    // variable
    // constant
    // constant
    // constant
    // constant
    fn formatWithOptions(inspectOptions: InspectOptions, format: Option<JsValue>, param: JsArray<JsValue>) -> String;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 5 overloads
    fn createCipheriv(algorithm: String, key: JsValue, iv: JsValue, options: CipherCCMOptions) -> CipherCCM;
    // merged from 2 overloads
    fn upgrade(url: Option<JsValue>, options: Option<UpgradeOptions>) -> JsPromise<UpgradeData>;
    // constant
    // constant
    // constant
    // constant
    // constant
    fn urlToHttpOptions(url: URL) -> ClientRequestArgs;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 8 overloads
    fn only(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 14 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 4 overloads
    fn generatePrimeSync(size: f64, options: Option<GeneratePrimeOptionsBigInt>) -> i64;
    // constant
    // constant
    // constant
    // constant
    // merged from 7 overloads
    fn mkdir(path: JsValue, options: MakeDirectoryOptions, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    // constant
    // constant
    // constant
    // constant
    // constant
    fn createSign(algorithm: String, options: Option<WritableOptions>) -> Sign;
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // merged from 2 overloads
    fn scrypt(password: JsValue, salt: JsValue, keylen: f64, options: ScryptOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    // constant
    fn beforeEach(fn_: Option<JsValue>, options: Option<HookOptions>);
    // constant
    fn createHmac(algorithm: String, key: JsValue, options: Option<TransformOptions>) -> Hmac;
    fn createSecureContext(options: Option<SecureContextOptions>) -> SecureContext;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    fn openAsBlob(path: JsValue, options: Option<OpenAsBlobOptions>) -> JsPromise<Blob>;
    // constant
    fn createBrotliDecompress(options: Option<BrotliOptions>) -> BrotliDecompress;
    // merged from 2 overloads
    fn backup(sourceDb: DatabaseSync, path: JsValue, options: Option<BackupOptions>) -> JsPromise<f64>;
    // constant
    // constant
    // constant
    // merged from 7 overloads
    // merged from 11 overloads
    // constant
    // constant
    // merged from 8 overloads
    fn skip(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 10 overloads
    // constant
    // constant
    fn createGzip(options: Option<ZlibOptions>) -> Gzip;
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 4 overloads
    fn globSync(pattern: JsValue, options: Option<GlobOptionsWithFileTypes>) -> JsArray<Dirent>;
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    fn retry(opts: Option<RetryOptions>) -> fn(JsValue) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn unzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    // constant
    // merged from 3 overloads
    fn rm(path: JsValue, options: RmOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 5 overloads
    fn createDecipheriv(algorithm: String, key: JsValue, iv: JsValue, options: CipherCCMOptions) -> DecipherCCM;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn createTracing(options: CreateTracingOptions) -> Tracing;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 5 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    fn setSourceMapsSupport(enabled: bool, options: Option<SetSourceMapsSupportOptions>);
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn stream(url: Option<JsValue>, options: Option<RequestOptions<JsValue>>, factory: Option<fn(StreamFactoryData<JsValue>) -> Writable>) -> JsPromise<StreamData<JsValue>>;
    // constant
    // constant
    // constant
    // constant
    // constant
    fn scryptSync(password: JsValue, salt: JsValue, keylen: f64, options: Option<ScryptOptions>) -> JsValue;
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 55 overloads
    fn generateKeyPairSync(type_: String, options: RSAKeyPairOptions<String, String>) -> KeyPairSyncResult<String, String>;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 5 overloads
    // merged from 2 overloads
    fn createVerify(algorithm: String, options: Option<WritableOptions>) -> Verify;
    // constant
    // constant
    // variable
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // merged from 4 overloads
    fn parse(str: String, sep: Option<String>, eq: Option<String>, options: Option<ParseOptions>) -> ParsedUrlQuery;
    // merged from 7 overloads
    fn statfs(path: JsValue, options: Option<StatFsOptions>, callback: Option<fn(Option<ErrnoException>, StatsFs) -> ()>);
    // constant
    // constant
    // constant
    // constant
    fn cpSync(source: JsValue, destination: JsValue, opts: Option<CopySyncOptions>);
    // constant
    fn inflateSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // merged from 2 overloads
    fn zstdDecompress(buf: JsValue, options: ZstdOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // merged from 16 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 10 overloads
    fn connect(port: Option<f64>, host: Option<String>, options: Option<ConnectionOptions>, secureConnectListener: Option<fn() -> ()>) -> TLSSocket;
    // constant
    // merged from 4 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 8 overloads
    fn execFile(file: String, args: Option<JsArray<String>>, options: Option<ExecFileOptionsWithBufferEncoding>, callback: Option<fn(Option<ErrnoException>, JsValue, JsValue) -> ()>) -> ChildProcess;
    // constant
    // constant
    fn fileURLToPathBuffer(url: JsValue, options: Option<FileUrlToPathOptions>) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 8 overloads
    fn spawnSync(command: String, args: Option<JsArray<String>>, options: Option<SpawnSyncOptionsWithStringEncoding>) -> SpawnSyncReturns<String>;
    // constant
    fn createContext(contextObject: Option<JsValue>, options: Option<CreateContextOptions>) -> Context;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    fn gunzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // merged from 6 overloads
    fn request(url: Option<JsValue>, options: Option<RequestOptions>, callback: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // constant
    // constant
    // constant
    // constant
    // constant
    // variable
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn writeHeapSnapshot(filename: Option<String>, options: Option<HeapSnapshotOptions>) -> String;
    // constant
    // constant
    // merged from 7 overloads
    fn lstat(path: JsValue, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // constant
    // merged from 8 overloads
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn deflateRaw(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn fork(modulePath: JsValue, args: Option<JsArray<String>>, options: Option<ForkOptions>) -> ChildProcess;
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 3 overloads
    fn setTimeout(delay: Option<f64>, value: Option<JsValue>, options: Option<TimerOptions>) -> JsPromise<JsValue>;
    // constant
    // constant
    fn unzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // merged from 8 overloads
    fn execFileSync(file: String, args: Option<JsArray<String>>, options: Option<ExecFileSyncOptionsWithStringEncoding>) -> String;
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    fn createBrotliCompress(options: Option<BrotliOptions>) -> BrotliCompress;
    // constant
    // constant
    // merged from 5 overloads
    // constant
    // constant
    // constant
    fn duplexPair(options: Option<DuplexOptions>) -> (Duplex, Duplex);
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn gzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // merged from 3 overloads
    fn statfsSync(path: JsValue, options: Option<StatFsOptions>) -> StatsFs;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // variable
    // constant
    // constant
    // constant
    // merged from 4 overloads
    fn fstat(fd: f64, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // constant
    // merged from 2 overloads
    // merged from 3 overloads
    fn finished(stream: JsValue, options: FinishedOptions, callback: Option<fn(Option<ErrnoException>) -> ()>) -> fn() -> ();
    // constant
    // constant
    // constant
    // constant
    // constant
    fn createInflate(options: Option<ZlibOptions>) -> Inflate;
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    fn checkPrimeSync(candidate: JsValue, options: Option<CheckPrimeOptions>) -> bool;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 7 overloads
    // constant
    // constant
    // constant
    // constant
    fn getCipherInfo(nameOrNid: JsValue, options: Option<CipherInfoOptions>) -> Option<CipherInfo>;
    // constant
    // merged from 2 overloads
    fn inflate(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn run(options: Option<RunOptions>) -> TestsStream;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 184 overloads
    fn __promisify__(source: JsValue, transform1: Option<JsValue>, transform2: Option<JsValue>, transform3: Option<JsValue>, transform4: Option<JsValue>, destination: Option<JsValue>, options: Option<PipelineOptions>) -> Promise<JsValue>;
    // constant
    // constant
    // constant
    // constant
    fn pathToFileURL(path: String, options: Option<PathToFileUrlOptions>) -> URL;
    // constant
    // constant
    // constant
    // constant
    // constant
    // variable
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // variable
    // constant
    fn createHistogram(options: Option<CreateHistogramOptions>) -> RecordableHistogram;
    fn getHeapSnapshot(options: Option<HeapSnapshotOptions>) -> Readable;
    // constant
    // merged from 10 overloads
    // constant
    // constant
    // merged from 2 overloads
    // merged from 7 overloads
    fn stat(path: JsValue, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    fn before(fn_: Option<JsValue>, options: Option<HookOptions>);
    // constant
    fn compileFunction(code: String, params: Option<JsArray<String>>, options: Option<CompileFunctionOptions>) -> JsFn;
    // constant
    // merged from 5 overloads
    // merged from 2 overloads
    fn getCallSites(frameCount: Option<f64>, options: Option<GetCallSitesOptions>) -> JsArray<CallSiteObject>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 4 overloads
    fn test(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    fn setInterval(delay: Option<f64>, value: Option<JsValue>, options: Option<TimerOptions>) -> AsyncIterator<JsValue>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 3 overloads
    fn userInfo(options: Option<UserInfoOptionsWithStringEncoding>) -> UserInfo<String>;
    // merged from 2 overloads
    fn createSecureServer(options: SecureServerOptions<JsValue, JsValue, JsValue, JsValue>, onRequestHandler: Option<fn(JsValue, JsValue) -> ()>) -> Http2SecureServer<JsValue, JsValue, JsValue, JsValue>;
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn after(fn_: Option<JsValue>, options: Option<HookOptions>);
    // variable
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 4 overloads
    fn suite(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // type params simplified: T
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn deflate(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    // constant
    fn zstdDecompressSync(buf: JsValue, options: Option<ZstdOptions>) -> JsValue;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // merged from 3 overloads
    fn rmdir(path: JsValue, options: RmDirOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    fn brotliCompressSync(buf: JsValue, options: Option<BrotliOptions>) -> JsValue;
    // constant
    // constant
    fn rmSync(path: JsValue, options: Option<RmOptions>);
    fn measureMemory(options: Option<MeasureMemoryOptions>) -> JsPromise<MemoryMeasurement>;
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 8 overloads
    fn todo(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    fn registerHooks(options: RegisterHooksOptions) -> ModuleHooks;
    // merged from 2 overloads
    // constant
    fn fileURLToPath(url: JsValue, options: Option<FileUrlToPathOptions>) -> String;
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    fn brotliDecompressSync(buf: JsValue, options: Option<BrotliOptions>) -> JsValue;
    // merged from 7 overloads
    // merged from 7 overloads
    // constant
    fn rmdirSync(path: JsValue, options: Option<RmDirOptions>);
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    fn brotliCompress(buf: JsValue, options: BrotliOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn kOptions() -> JsValue;
    // merged from 2 overloads
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // constant
    // constant
    // merged from 2 overloads
    fn stringify(obj: Option<ParsedUrlQueryInput>, sep: Option<String>, eq: Option<String>, options: Option<StringifyOptions>) -> String;
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 2 overloads
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // constant
    // merged from 3 overloads
    // merged from 2 overloads
    // merged from 2 overloads
    fn zstdCompress(buf: JsValue, options: ZstdOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
}

#[untagged]
enum FilterCallsOperator {
    AND,
    OR,
}

#[untagged]
enum FilterCallsParameter {
    Str(String),
    RegExp(RegExp),
}

#[untagged]
enum UndiciHeaders {
    Record(Record<String, JsValue>),
    IncomingHttpHeaders(IncomingHttpHeaders),
    Array(Vec<String>),
    Iterable(Iterable<(String, JsValue)>),
}

#[untagged]
enum FormDataEntryValue {
    Str(String),
    File(File),
}

#[untagged]
enum RequestInfo {
    Str(String),
    URL(URL),
    Request(Request),
}

#[untagged]
enum BodyInit {
    ArrayBuffer(ArrayBuffer),
    AsyncIterable(AsyncIterable<JsValue>),
    Blob(Blob),
    FormData(FormData),
    Iterable(Iterable<JsValue>),
    ArrayBufferView(ArrayBufferView),
    URLSearchParams(URLSearchParams),
    Str(String),
}

#[untagged]
enum HeadersInit {
    Array(Vec<(String, String)>),
    HeaderRecord(HeaderRecord),
    Headers(Headers),
}

#[untagged]
enum RequestCache {
    Default,
    ForceCache,
    NoCache,
    NoStore,
    OnlyIfCached,
    Reload,
}

#[untagged]
enum RequestCredentials {
    Omit,
    Include,
    SameOrigin,
}

#[untagged]
enum ReferrerPolicy {
    Empty,
    NoReferrer,
    NoReferrerWhenDowngrade,
    Origin,
    OriginWhenCrossOrigin,
    SameOrigin,
    StrictOrigin,
    StrictOriginWhenCrossOrigin,
    UnsafeUrl,
}

#[untagged]
enum RequestMode {
    Cors,
    Navigate,
    NoCors,
    SameOrigin,
}

#[untagged]
enum RequestRedirect {
    Error,
    Follow,
    Manual,
}

#[untagged]
enum ResponseType {
    Basic,
    Cors,
    Default,
    Error,
    Opaque,
    Opaqueredirect,
}

#[untagged]
enum ResponseRedirectStatus {
    N301,
    N302,
    N303,
    N307,
    N308,
}

#[untagged]
enum InputType {
    Str(String),
    ArrayBuffer(ArrayBuffer),
    ArrayBufferView(ArrayBufferView),
}

#[untagged]
enum Transferable {
    ArrayBuffer(ArrayBuffer),
    MessagePort(MessagePort),
    AbortSignal(AbortSignal),
    FileHandle(FileHandle),
    ReadableStream(ReadableStream),
    WritableStream(WritableStream),
    TransformStream(TransformStream),
}

#[untagged]
enum LockMode {
    Exclusive,
    Shared,
}

#[untagged]
enum Serializable {
    Str(String),
    Obj(JsValue),
    Num(f64),
    Bool(bool),
    BigInt(i64),
}

#[untagged]
enum MeasureMemoryMode {
    Summary,
    Detailed,
}

#[untagged]
enum ModuleStatus {
    Unlinked,
    Linking,
    Linked,
    Evaluating,
    Evaluated,
    Errored,
}

#[untagged]
enum DoesZapCodeSpaceFlag {
    N0,
    N1,
}

#[untagged]
enum ParseArgsOptionsType {
    Boolean,
    String,
}

#[untagged]
enum Direction {
    Num(f64),
    N0,
    N1,
}

#[untagged]
enum BufferSource {
    ArrayBufferView(ArrayBufferView),
    ArrayBuffer(ArrayBuffer),
}

#[untagged]
enum CompressionFormat {
    Brotli,
    Deflate,
    DeflateRaw,
    Gzip,
}

#[untagged]
enum SQLInputValue {
    Num(f64),
    BigInt(i64),
    Str(String),
    ArrayBufferView(ArrayBufferView),
}

#[untagged]
enum SQLOutputValue {
    Num(f64),
    BigInt(i64),
    Str(String),
    NonSharedUint8Array(NonSharedUint8Array),
}

#[untagged]
enum Architecture {
    Arm,
    Arm64,
    Ia32,
    Loong64,
    Mips,
    Mipsel,
    Ppc64,
    Riscv64,
    S390x,
    X64,
}

#[untagged]
enum UncaughtExceptionOrigin {
    UncaughtException,
    UnhandledRejection,
}

#[untagged]
enum MultipleResolveType {
    Resolve,
    Reject,
}

#[untagged]
enum EntryType {
    Dns,
    Function,
    Gc,
    Http2,
    Http,
    Mark,
    Measure,
    Net,
    Node,
    Resource,
}

#[untagged]
enum SocketConnectOpts {
    TcpSocketConnectOpts(TcpSocketConnectOpts),
    IpcSocketConnectOpts(IpcSocketConnectOpts),
}

#[untagged]
enum SocketReadyState {
    Opening,
    Open,
    ReadOnly,
    WriteOnly,
    Closed,
}

#[untagged]
enum IPVersion {
    Ipv4,
    Ipv6,
}

#[untagged]
enum NetConnectOpts {
    TcpNetConnectOpts(TcpNetConnectOpts),
    IpcNetConnectOpts(IpcNetConnectOpts),
}

#[untagged]
enum ImportPhase {
    Source,
    Evaluation,
}

#[untagged]
enum ModuleFormat {
    Addon,
    Builtin,
    Commonjs,
    CommonjsTypescript,
    Json,
    Module,
    ModuleTypescript,
    Wasm,
}

#[untagged]
enum ModuleSource {
    Str(String),
    ArrayBuffer(ArrayBuffer),
    TypedArray(TypedArray),
}

#[untagged]
enum OutgoingHttpHeader {
    Num(f64),
    Str(String),
    Array(Vec<String>),
}

#[untagged]
enum PathLike {
    Str(String),
    Buffer(Buffer),
    URL(URL),
}

#[untagged]
enum PathOrFileDescriptor {
    PathLike(PathLike),
    Num(f64),
}

#[untagged]
enum TimeLike {
    Str(String),
    Num(f64),
    Date(Date),
}

#[untagged]
enum EncodingOption {
    ObjectEncodingOptions(ObjectEncodingOptions),
    BufferEncoding(BufferEncoding),
}

#[untagged]
enum OpenMode {
    Num(f64),
    Str(String),
}

#[untagged]
enum Mode {
    Num(f64),
    Str(String),
}

#[untagged]
enum Type {
    Dir,
    File,
    Junction,
}

#[untagged]
enum ReadPosition {
    Num(f64),
    BigInt(i64),
}

#[untagged]
enum WatchEventType {
    Rename,
    Change,
}

#[untagged]
enum AnyRecordWithTtl {
    AnyARecord(AnyARecord),
    AnyAaaaRecord(AnyAaaaRecord),
}

#[untagged]
enum BinaryToTextEncoding {
    Base64,
    Base64url,
    Hex,
    Binary,
}

#[untagged]
enum CharacterEncoding {
    Utf8,
    Utf8,
    Utf16le,
    Utf16le,
    Latin1,
}

#[untagged]
enum LegacyCharacterEncoding {
    Ascii,
    Binary,
    Ucs2,
    Ucs2,
}

#[untagged]
enum Encoding {
    BinaryToTextEncoding(BinaryToTextEncoding),
    CharacterEncoding(CharacterEncoding),
    LegacyCharacterEncoding(LegacyCharacterEncoding),
}

#[untagged]
enum ECDHKeyFormat {
    Compressed,
    Uncompressed,
    Hybrid,
}

#[untagged]
enum KeyObjectType {
    Secret,
    Public,
    Private,
}

#[untagged]
enum CipherCCMTypes {
    Aes128Ccm,
    Aes192Ccm,
    Aes256Ccm,
}

#[untagged]
enum CipherGCMTypes {
    Aes128Gcm,
    Aes192Gcm,
    Aes256Gcm,
}

#[untagged]
enum CipherOCBTypes {
    Aes128Ocb,
    Aes192Ocb,
    Aes256Ocb,
}

#[untagged]
enum BinaryLike {
    Str(String),
    ArrayBufferView(ArrayBufferView),
}

#[untagged]
enum CipherKey {
    BinaryLike(BinaryLike),
    KeyObject(KeyObject),
}

#[untagged]
enum DSAEncoding {
    Der,
    IeeeP1363,
}

#[untagged]
enum KeyLike {
    Str(String),
    Buffer(Buffer),
    KeyObject(KeyObject),
}

#[untagged]
enum KeyFormat {
    Pem,
    Der,
    Jwk,
}

#[untagged]
enum LargeNumberLike {
    ArrayBufferView(ArrayBufferView),
    SharedArrayBuffer(SharedArrayBuffer),
    ArrayBuffer(ArrayBuffer),
    BigInt(i64),
}

#[untagged]
enum Argon2Algorithm {
    Argon2d,
    Argon2i,
    Argon2id,
}

#[untagged]
enum KeyType {
    Private,
    Public,
    Secret,
}

#[untagged]
enum AlgorithmIdentifier {
    Algorithm(Algorithm),
    Str(String),
}

#[untagged]
enum SerializationType {
    Json,
    Advanced,
}

#[untagged]
enum SendHandle {
    Socket(Socket),
    Server(Server),
    Socket(Socket),
}

#[untagged]
enum IOType {
    Overlapped,
    Pipe,
    Ignore,
    Inherit,
}

#[untagged]
enum StdioOptions {
    IOType(IOType),
    Array(Array<JsValue>),
}

#[untagged]
enum StdioNull {
    Inherit,
    Ignore,
    Stream(Stream),
}

#[untagged]
enum StdioPipeNamed {
    Pipe,
    Overlapped,
}

#[untagged]
enum TranscodeEncoding {
    Ascii,
    Utf8,
    Utf8,
    Utf16le,
    Utf16le,
    Ucs2,
    Ucs2,
    Latin1,
    Binary,
}

#[untagged]
enum BinaryType {
    Blob,
    Arraybuffer,
}

#[untagged]
enum EventListenerOrEventListenerObject {
    EventListener(EventListener),
    EventListenerObject(EventListenerObject),
}

#[untagged]
enum CacheMethods {
    GET,
    HEAD,
    OPTIONS,
    TRACE,
}

#[untagged]
enum SnapshotRecorderMode {
    Record,
    Playback,
    Update,
}

#[untagged]
enum SocketType {
    Udp4,
    Udp6,
}

#[untagged]
enum SecureVersion {
    TLSv13,
    TLSv12,
    TLSv11,
    TLSv1,
}

#[untagged]
enum NetworkInterfaceInfo {
    NetworkInterfaceInfoIPv4(NetworkInterfaceInfoIPv4),
    NetworkInterfaceInfoIPv6(NetworkInterfaceInfoIPv6),
}


impl AbortController {
    #[getter]
    extern "js" signal: JsValue;

    extern "js" fn abort(self, reason: Option<JsValue>);
}

impl AbortSignal {
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    #[setter]
    extern "js" onabort: Option<JsFn>;
    #[getter]
    extern "js" reason: JsValue;

    extern "js" fn throwIfAborted(self);
}

impl Abortable {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl AddEventListenerOptions {
    #[getter]
    #[setter]
    extern "js" once: Option<bool>;
    #[getter]
    #[setter]
    extern "js" passive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" once: Option<bool>;
    #[getter]
    #[setter]
    extern "js" passive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" capture: Option<bool>;
}

impl AddHeapSnapshotChunkEventDataType {
    #[getter]
    #[setter]
    extern "js" chunk: String;
}

impl AddInspectedHeapObjectParameterType {
    #[getter]
    #[setter]
    extern "js" heapObjectId: String;
}

impl Address {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" addressType: JsValue;
}

impl AddressInfo {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
}

impl AeadParams {
    #[getter]
    #[setter]
    extern "js" additionalData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
    #[getter]
    #[setter]
    extern "js" tagLength: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesCbcParams {
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesCtrParams {
    #[getter]
    #[setter]
    extern "js" counter: JsValue;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesDerivedKeyParams {
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesGcmParams {
    #[getter]
    #[setter]
    extern "js" additionalData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
    #[getter]
    #[setter]
    extern "js" tagLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AesKeyGenParams {
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl Agent {
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
    // property getter
    extern "js" fn closed(self) -> bool;
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    extern "js" fn new_(opts: Option<Options>) -> Agent;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
}

impl AgentOptions {
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveMsecs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" agentKeepAliveTimeoutBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxTotalSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxFreeSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" scheduling: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyEnv: Option<Option<ProxyEnv>>;
    #[getter]
    #[setter]
    extern "js" defaultPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
}

impl AggregateOptions {
    #[getter]
    #[setter]
    extern "js" start: JsValue;
    #[getter]
    #[setter]
    extern "js" result: Option<Option<fn(JsValue) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" inverse: Option<Option<fn(JsValue, JsArray<JsValue>) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" deterministic: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" directOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useBigIntArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" varargs: Option<Option<bool>>;

    // function property
    extern "js" fn step(self) -> fn(JsValue, JsArray<JsValue>) -> JsValue;
}

impl Algorithm {
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AlternativeServiceOptions {
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
}

impl AnyARecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" ttl: f64;
}

impl AnyAaaaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" ttl: f64;
}

impl AnyCaaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" critical: f64;
    #[getter]
    #[setter]
    extern "js" issue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" issuewild: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" iodef: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactemail: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactphone: Option<Option<String>>;
}

impl AnyCnameRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnyMxRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" exchange: String;
}

impl AnyNaptrRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" flags: String;
    #[getter]
    #[setter]
    extern "js" service: String;
    #[getter]
    #[setter]
    extern "js" regexp: String;
    #[getter]
    #[setter]
    extern "js" replacement: String;
    #[getter]
    #[setter]
    extern "js" order: f64;
    #[getter]
    #[setter]
    extern "js" preference: f64;
}

impl AnyNsRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnyPtrRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnySoaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" nsname: String;
    #[getter]
    #[setter]
    extern "js" hostmaster: String;
    #[getter]
    #[setter]
    extern "js" serial: f64;
    #[getter]
    #[setter]
    extern "js" refresh: f64;
    #[getter]
    #[setter]
    extern "js" retry: f64;
    #[getter]
    #[setter]
    extern "js" expire: f64;
    #[getter]
    #[setter]
    extern "js" minttl: f64;
}

impl AnySrvRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" weight: f64;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AnyTlsaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" certUsage: f64;
    #[getter]
    #[setter]
    extern "js" selector: f64;
    #[getter]
    #[setter]
    extern "js" match_: f64;
    #[getter]
    #[setter]
    extern "js" data: JsValue;
}

impl AnyTxtRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" entries: JsArray<String>;
}

impl ApplyChangesetOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String) -> bool>>;
    #[getter]
    #[setter]
    extern "js" onConflict: Option<Option<fn(f64) -> f64>>;
}

impl Argon2Parameters {
    #[getter]
    #[setter]
    extern "js" message: JsValue;
    #[getter]
    #[setter]
    extern "js" nonce: JsValue;
    #[getter]
    #[setter]
    extern "js" parallelism: f64;
    #[getter]
    #[setter]
    extern "js" tagLength: f64;
    #[getter]
    #[setter]
    extern "js" memory: f64;
    #[getter]
    #[setter]
    extern "js" passes: f64;
    #[getter]
    #[setter]
    extern "js" secret: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" associatedData: Option<JsValue>;
}

impl Argon2Params {
    #[getter]
    #[setter]
    extern "js" associatedData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" memory: f64;
    #[getter]
    #[setter]
    extern "js" nonce: JsValue;
    #[getter]
    #[setter]
    extern "js" parallelism: f64;
    #[getter]
    #[setter]
    extern "js" passes: f64;
    #[getter]
    #[setter]
    extern "js" secretValue: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" version: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl ArrayOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl AssertOptions {
    #[getter]
    #[setter]
    extern "js" diff: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" strict: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" skipPrototype: Option<Option<bool>>;
}

impl AssertSnapshotOptions {
    #[getter]
    #[setter]
    extern "js" serializers: Option<Option<JsArray<fn(JsValue) -> JsValue>>>;
}

impl AssertionError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn operator(self) -> String;
    // property setter
    extern "js" fn set_operator(self, value: String);
    // property getter
    extern "js" fn generatedMessage(self) -> bool;
    // property getter
    extern "js" fn actual(self) -> JsValue;
    // property getter
    extern "js" fn expected(self) -> JsValue;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_actual(self, value: JsValue);
    extern "js" fn new_(options: AssertionErrorOptions) -> AssertionError;
    // property setter
    extern "js" fn set_expected(self, value: JsValue);
    // property setter
    extern "js" fn set_generatedMessage(self, value: bool);
}

impl AssertionErrorOptions {
    #[getter]
    #[setter]
    extern "js" message: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" actual: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" expected: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" operator: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stackStartFn: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" diff: Option<JsValue>;
}

impl AsymmetricKeyDetails {
    #[getter]
    #[setter]
    extern "js" modulusLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<i64>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<String>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<String>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" divisorLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" namedCurve: Option<String>;
}

impl AsyncHook {
    extern "js" fn disable(self) -> AsyncHook;
    extern "js" fn enable(self) -> AsyncHook;
}

impl AsyncLocalStorage {
    // merged from 2 overloads
    extern "js" fn run(self, store: JsValue, callback: fn(TArgs) -> R, args: Option<TArgs>) -> R;
    extern "js" fn new_(options: Option<AsyncLocalStorageOptions>) -> AsyncLocalStorage;
    extern "js" fn getStore(self) -> Option<JsValue>;
    extern "js" fn snapshot() -> JsFn;
    extern "js" fn exit(self, callback: fn(TArgs) -> R, args: TArgs) -> R;
    extern "js" fn enterWith(self, store: JsValue);
    extern "js" fn disable(self);
    // property (readonly)
    extern "js" fn name(self) -> String;
    extern "js" fn bind(fn_: Func) -> Func;
}

impl AsyncLocalStorageOptions {
    #[getter]
    #[setter]
    extern "js" defaultValue: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl AsyncResource {
    extern "js" fn new_(type_: String, triggerAsyncId: Option<JsValue>) -> AsyncResource;
    extern "js" fn triggerAsyncId(self) -> f64;
    extern "js" fn runInAsyncScope(self, fn_: JsFn, thisArg: Option<This>, args: JsArray<JsValue>) -> Result;
    extern "js" fn asyncId(self) -> f64;
    extern "js" fn bind(fn_: Func, type_: Option<String>, thisArg: Option<ThisArg>) -> Func;
    extern "js" fn bind(self, fn_: Func) -> Func;
    extern "js" fn emitDestroy(self) -> AsyncResource;
}

impl AsyncResourceOptions {
    #[getter]
    #[setter]
    extern "js" triggerAsyncId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" requireManualDestroy: Option<Option<bool>>;
}

impl AttachedToTargetEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" targetInfo: TargetInfo;
    #[getter]
    #[setter]
    extern "js" waitingForDebugger: bool;
}

impl AttachedToWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" workerInfo: WorkerInfo;
    #[getter]
    #[setter]
    extern "js" waitingForDebugger: bool;
}

impl AwaitPromiseParameterType {
    #[getter]
    #[setter]
    extern "js" promiseObjectId: String;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
}

impl AwaitPromiseReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl BackupMetadata {
    #[getter]
    #[setter]
    extern "js" totalPages: f64;
    #[getter]
    #[setter]
    extern "js" remainingPages: f64;
}

impl BackupOptions {
    #[getter]
    #[setter]
    extern "js" source: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" target: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" rate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" progress: Option<Option<fn(BackupProgressInfo) -> ()>>;

    // function property
    extern "js" fn progress(self) -> fn(BackupMetadata) -> f64;
}

impl BackupProgressInfo {
    #[getter]
    #[setter]
    extern "js" totalPages: f64;
    #[getter]
    #[setter]
    extern "js" remainingPages: f64;
}

impl BalancedPool {
    // property getter
    extern "js" fn closed(self) -> bool;
    // property setter
    extern "js" fn set_upstreams(self, value: JsArray<String>);
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    extern "js" fn removeUpstream(self, upstream: JsValue) -> BalancedPool;
    // property getter
    extern "js" fn upstreams(self) -> JsArray<String>;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn new_(url: JsValue, options: Option<Options>) -> BalancedPool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property setter
    extern "js" fn set_closed(self, value: bool);
    extern "js" fn addUpstream(self, upstream: JsValue) -> BalancedPool;
}

impl BalancedPoolMissingUpstreamError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl BaseOptions {
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl BasePrivateKeyEncodingOptions {
    #[getter]
    #[setter]
    extern "js" format: JsValue;
    #[getter]
    #[setter]
    extern "js" cipher: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
}

impl BigIntOptions {
    #[getter]
    #[setter]
    extern "js" bigint: bool;
}

impl BigIntStats {
    #[getter]
    #[setter]
    extern "js" atimeNs: i64;
    #[getter]
    #[setter]
    extern "js" mtimeNs: i64;
    #[getter]
    #[setter]
    extern "js" ctimeNs: i64;
    #[getter]
    #[setter]
    extern "js" birthtimeNs: i64;
    #[getter]
    #[setter]
    extern "js" dev: T;
    #[getter]
    #[setter]
    extern "js" ino: T;
    #[getter]
    #[setter]
    extern "js" mode: T;
    #[getter]
    #[setter]
    extern "js" nlink: T;
    #[getter]
    #[setter]
    extern "js" uid: T;
    #[getter]
    #[setter]
    extern "js" gid: T;
    #[getter]
    #[setter]
    extern "js" rdev: T;
    #[getter]
    #[setter]
    extern "js" size: T;
    #[getter]
    #[setter]
    extern "js" blksize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" atimeMs: T;
    #[getter]
    #[setter]
    extern "js" mtimeMs: T;
    #[getter]
    #[setter]
    extern "js" ctimeMs: T;
    #[getter]
    #[setter]
    extern "js" birthtimeMs: T;
    #[getter]
    #[setter]
    extern "js" atime: JsValue;
    #[getter]
    #[setter]
    extern "js" mtime: JsValue;
    #[getter]
    #[setter]
    extern "js" ctime: JsValue;
    #[getter]
    #[setter]
    extern "js" birthtime: JsValue;

    // inherited from StatsBase
    extern "js" fn isSymbolicLink(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isFIFO(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isSocket(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isBlockDevice(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isFile(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isDirectory(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isCharacterDevice(self) -> bool;
}

impl BigIntStatsFs {
    #[getter]
    #[setter]
    extern "js" type_: T;
    #[getter]
    #[setter]
    extern "js" bsize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" bfree: T;
    #[getter]
    #[setter]
    extern "js" bavail: T;
    #[getter]
    #[setter]
    extern "js" files: T;
    #[getter]
    #[setter]
    extern "js" ffree: T;
}

impl BindOptions {
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" address: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
}

impl Blob {
    // property (readonly)
    extern "js" fn type_(self) -> String;
    // property (readonly)
    extern "js" fn size(self) -> f64;
    extern "js" fn stream(self) -> JsValue;
    extern "js" fn new_(sources: JsArray<JsValue>, options: Option<BlobOptions>) -> Blob;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn slice(self, start: Option<f64>, end: Option<f64>, type_: Option<String>) -> Blob;
    extern "js" fn text(self) -> JsPromise<String>;
}

impl BlobOptions {
    #[getter]
    #[setter]
    extern "js" endings: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl BlockList {
    extern "js" fn isBlockList(value: JsValue) -> bool;
    extern "js" fn toJSON(self) -> JsArray<String>;
    // merged from 2 overloads
    extern "js" fn addRange(self, start: String, end: String, type_: Option<String>);
    // property setter
    extern "js" fn set_rules(self, value: JsArray<String>);
    // merged from 2 overloads
    extern "js" fn addAddress(self, address: String, type_: Option<String>);
    // merged from 2 overloads
    extern "js" fn check(self, address: String, type_: Option<String>) -> bool;
    extern "js" fn fromJSON(self, data: JsValue);
    // property getter
    extern "js" fn rules(self) -> JsArray<String>;
    // merged from 2 overloads
    extern "js" fn addSubnet(self, net: String, prefix: f64, type_: Option<String>);
}

impl BodyMixin {
    #[getter]
    extern "js" body: Option<()>;
    #[getter]
    extern "js" bodyUsed: bool;
    #[getter]
    extern "js" body: Option<()>;
    #[getter]
    extern "js" bodyUsed: bool;

    extern "js" fn blob(self) -> JsPromise<Blob>;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    extern "js" fn formData(self) -> JsPromise<()>;
    extern "js" fn text(self) -> JsPromise<String>;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn json(self) -> JsPromise<JsValue>;
}

impl BodyReadable {
    extern "js" fn text(self) -> JsPromise<String>;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    extern "js" fn blob(self) -> JsPromise<Blob>;
    extern "js" fn json(self) -> JsPromise<JsValue>;
    // property (readonly)
    extern "js" fn bodyUsed(self) -> bool;
    extern "js" fn formData(self) -> JsPromise<()>;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn dump(self, opts: Option<JsValue>) -> JsPromise<()>;
    // property (readonly)
    extern "js" fn body(self) -> Option<()>;
    extern "js" fn new_(opts: JsValue) -> BodyReadable;
}

impl BodyTimeoutError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
}

impl BreakLocation {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl BreakpointResolvedEventDataType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
}

impl BroadcastChannel {
    // property (readonly)
    extern "js" fn name(self) -> String;
    extern "js" fn close(self);
    // property setter
    extern "js" fn set_onmessage(self, value: fn(MessageEvent) -> ());
    extern "js" fn postMessage(self, message: JsValue);
    // property getter
    extern "js" fn onmessageerror(self) -> fn(MessageEvent) -> ();
    // property setter
    extern "js" fn set_onmessageerror(self, value: fn(MessageEvent) -> ());
    extern "js" fn new_(name: String) -> BroadcastChannel;
    // property getter
    extern "js" fn onmessage(self) -> fn(MessageEvent) -> ();
}

impl BrotliCompress {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl BrotliDecompress {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl BrotliOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" params: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
}

impl Buffer {
    extern "js" fn write(self, string: String, offset: Option<f64>, length: Option<f64>, encoding: Option<String>) -> f64;
    extern "js" fn readDoubleLE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn concat(list: JsArray<Buffer>, totalLength: Option<f64>) -> Buffer;
    extern "js" fn swap16(self) -> Buffer;
    extern "js" fn swap32(self) -> Buffer;
    extern "js" fn writeIntBE(self, value: f64, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readInt32BE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeUInt32BE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readInt16BE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readInt8(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeUInt32LE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn toJSON(self) -> JsValue;
    extern "js" fn writeInt16BE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    // property getter
    extern "js" fn length(self) -> f64;
    extern "js" fn readUInt32LE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeUInt16LE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn includes(self, value: JsValue, byteOffset: Option<f64>, encoding: Option<String>) -> bool;
    extern "js" fn readUInt32BE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn fill(self, value: JsValue, offset: Option<f64>, end: Option<f64>) -> Buffer;
    extern "js" fn readFloatLE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readUInt8(self, offset: f64, noAssert: Option<bool>) -> f64;
    // merged from 4 overloads
    extern "js" fn from(arrayBuffer: JsValue, byteOffset: Option<f64>, length: Option<f64>) -> Buffer;
    extern "js" fn readFloatBE(self, offset: f64, noAssert: Option<bool>) -> f64;
    // merged from 6 overloads
    extern "js" fn new_(str: String, encoding: Option<String>) -> Buffer;
    extern "js" fn readUIntBE(self, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeIntLE(self, value: f64, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeInt16LE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeDoubleLE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn allocUnsafe(size: f64) -> Buffer;
    extern "js" fn lastIndexOf(self, value: JsValue, byteOffset: Option<f64>, encoding: Option<String>) -> f64;
    extern "js" fn compare(self, otherBuffer: Buffer, targetStart: Option<f64>, targetEnd: Option<f64>, sourceStart: Option<f64>, sourceEnd: Option<f64>) -> f64;
    // property setter
    extern "js" fn set_prototype(self, value: Buffer);
    extern "js" fn readUIntLE(self, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn swap64(self) -> Buffer;
    extern "js" fn isEncoding(encoding: String) -> bool;
    extern "js" fn compare(buf1: Buffer, buf2: Buffer) -> f64;
    extern "js" fn reverse(self) -> Buffer;
    extern "js" fn readIntLE(self, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn slice(self, start: Option<f64>, end: Option<f64>) -> Buffer;
    extern "js" fn readDoubleBE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeFloatBE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn isBuffer(obj: JsValue) -> bool;
    extern "js" fn readInt16LE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readUInt16LE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeDoubleBE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    // property getter
    extern "js" fn prototype(self) -> Buffer;
    extern "js" fn copy(self, targetBuffer: Buffer, targetStart: Option<f64>, sourceStart: Option<f64>, sourceEnd: Option<f64>) -> f64;
    extern "js" fn writeUInt16BE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeFloatLE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    // property setter
    extern "js" fn set_length(self, value: f64);
    extern "js" fn equals(self, otherBuffer: Buffer) -> bool;
    extern "js" fn readUInt16BE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn indexOf(self, value: JsValue, byteOffset: Option<f64>, encoding: Option<String>) -> f64;
    extern "js" fn readInt32LE(self, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeUInt8(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn toString(self, encoding: Option<String>, start: Option<f64>, end: Option<f64>) -> String;
    extern "js" fn writeInt8(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeInt32BE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn readIntBE(self, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn alloc(size: f64, fill: Option<JsValue>, encoding: Option<String>) -> Buffer;
    extern "js" fn allocUnsafeSlow(size: f64) -> Buffer;
    extern "js" fn writeUIntBE(self, value: f64, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn writeInt32LE(self, value: f64, offset: f64, noAssert: Option<bool>) -> f64;
    extern "js" fn byteLength(string: String, encoding: Option<String>) -> f64;
    extern "js" fn writeUIntLE(self, value: f64, offset: f64, byteLength: f64, noAssert: Option<bool>) -> f64;
}

impl BufferConstructor {
    #[getter]
    #[setter]
    extern "js" poolSize: f64;

    // merged from 4 overloads
    extern "js" fn new_(str: String, encoding: Option<String>) -> Buffer<JsValue>;
    extern "js" fn concat(self, list: JsArray<JsValue>, totalLength: Option<f64>) -> Buffer<JsValue>;
    extern "js" fn copyBytesFrom(self, view: JsValue, offset: Option<f64>, length: Option<f64>) -> Buffer<JsValue>;
    extern "js" fn allocUnsafe(self, size: f64) -> Buffer<JsValue>;
    // merged from 4 overloads
    extern "js" fn from(self, arrayBuffer: JsValue, byteOffset: Option<f64>, length: Option<f64>) -> JsValue;
    extern "js" fn of(self, items: JsArray<f64>) -> Buffer<JsValue>;
    extern "js" fn allocUnsafeSlow(self, size: f64) -> Buffer<JsValue>;
    extern "js" fn alloc(self, size: f64, fill: Option<JsValue>, encoding: Option<String>) -> Buffer<JsValue>;
}

impl BuiltInModule {
    #[getter]
    #[setter]
    extern "js" assert: JsValue;
    #[getter]
    #[setter]
    extern "js" node_assert: JsValue;
    #[getter]
    #[setter]
    extern "js" assert_strict: JsValue;
    #[getter]
    #[setter]
    extern "js" node_assert_strict: JsValue;
    #[getter]
    #[setter]
    extern "js" async_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" node_async_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" buffer: JsValue;
    #[getter]
    #[setter]
    extern "js" node_buffer: JsValue;
    #[getter]
    #[setter]
    extern "js" child_process: JsValue;
    #[getter]
    #[setter]
    extern "js" node_child_process: JsValue;
    #[getter]
    #[setter]
    extern "js" cluster: JsValue;
    #[getter]
    #[setter]
    extern "js" node_cluster: JsValue;
    #[getter]
    #[setter]
    extern "js" console: JsValue;
    #[getter]
    #[setter]
    extern "js" node_console: JsValue;
    #[getter]
    #[setter]
    extern "js" constants: JsValue;
    #[getter]
    #[setter]
    extern "js" node_constants: JsValue;
    #[getter]
    #[setter]
    extern "js" crypto: JsValue;
    #[getter]
    #[setter]
    extern "js" node_crypto: JsValue;
    #[getter]
    #[setter]
    extern "js" dgram: JsValue;
    #[getter]
    #[setter]
    extern "js" node_dgram: JsValue;
    #[getter]
    #[setter]
    extern "js" diagnostics_channel: JsValue;
    #[getter]
    #[setter]
    extern "js" node_diagnostics_channel: JsValue;
    #[getter]
    #[setter]
    extern "js" dns: JsValue;
    #[getter]
    #[setter]
    extern "js" node_dns: JsValue;
    #[getter]
    #[setter]
    extern "js" dns_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_dns_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" domain: JsValue;
    #[getter]
    #[setter]
    extern "js" node_domain: JsValue;
    #[getter]
    #[setter]
    extern "js" events: JsValue;
    #[getter]
    #[setter]
    extern "js" node_events: JsValue;
    #[getter]
    #[setter]
    extern "js" fs: JsValue;
    #[getter]
    #[setter]
    extern "js" node_fs: JsValue;
    #[getter]
    #[setter]
    extern "js" fs_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_fs_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" http: JsValue;
    #[getter]
    #[setter]
    extern "js" node_http: JsValue;
    #[getter]
    #[setter]
    extern "js" http2: JsValue;
    #[getter]
    #[setter]
    extern "js" node_http2: JsValue;
    #[getter]
    #[setter]
    extern "js" https: JsValue;
    #[getter]
    #[setter]
    extern "js" node_https: JsValue;
    #[getter]
    #[setter]
    extern "js" inspector: JsValue;
    #[getter]
    #[setter]
    extern "js" node_inspector: JsValue;
    #[getter]
    #[setter]
    extern "js" inspector_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_inspector_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" module: JsValue;
    #[getter]
    #[setter]
    extern "js" node_module: JsValue;
    #[getter]
    #[setter]
    extern "js" net: JsValue;
    #[getter]
    #[setter]
    extern "js" node_net: JsValue;
    #[getter]
    #[setter]
    extern "js" os: JsValue;
    #[getter]
    #[setter]
    extern "js" node_os: JsValue;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" node_path: JsValue;
    #[getter]
    #[setter]
    extern "js" path_posix: JsValue;
    #[getter]
    #[setter]
    extern "js" node_path_posix: JsValue;
    #[getter]
    #[setter]
    extern "js" path_win32: JsValue;
    #[getter]
    #[setter]
    extern "js" node_path_win32: JsValue;
    #[getter]
    #[setter]
    extern "js" perf_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" node_perf_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" process: JsValue;
    #[getter]
    #[setter]
    extern "js" node_process: JsValue;
    #[getter]
    #[setter]
    extern "js" punycode: JsValue;
    #[getter]
    #[setter]
    extern "js" node_punycode: JsValue;
    #[getter]
    #[setter]
    extern "js" querystring: JsValue;
    #[getter]
    #[setter]
    extern "js" node_querystring: JsValue;
    #[getter]
    #[setter]
    extern "js" readline: JsValue;
    #[getter]
    #[setter]
    extern "js" node_readline: JsValue;
    #[getter]
    #[setter]
    extern "js" readline_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_readline_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" repl: JsValue;
    #[getter]
    #[setter]
    extern "js" node_repl: JsValue;
    #[getter]
    #[setter]
    extern "js" node_sea: JsValue;
    #[getter]
    #[setter]
    extern "js" node_sqlite: JsValue;
    #[getter]
    #[setter]
    extern "js" stream: JsValue;
    #[getter]
    #[setter]
    extern "js" node_stream: JsValue;
    #[getter]
    #[setter]
    extern "js" stream_consumers: JsValue;
    #[getter]
    #[setter]
    extern "js" node_stream_consumers: JsValue;
    #[getter]
    #[setter]
    extern "js" stream_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_stream_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" stream_web: JsValue;
    #[getter]
    #[setter]
    extern "js" node_stream_web: JsValue;
    #[getter]
    #[setter]
    extern "js" string_decoder: JsValue;
    #[getter]
    #[setter]
    extern "js" node_string_decoder: JsValue;
    #[getter]
    #[setter]
    extern "js" node_test: JsValue;
    #[getter]
    #[setter]
    extern "js" node_test_reporters: JsValue;
    #[getter]
    #[setter]
    extern "js" timers: JsValue;
    #[getter]
    #[setter]
    extern "js" node_timers: JsValue;
    #[getter]
    #[setter]
    extern "js" timers_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node_timers_promises: JsValue;
    #[getter]
    #[setter]
    extern "js" tls: JsValue;
    #[getter]
    #[setter]
    extern "js" node_tls: JsValue;
    #[getter]
    #[setter]
    extern "js" trace_events: JsValue;
    #[getter]
    #[setter]
    extern "js" node_trace_events: JsValue;
    #[getter]
    #[setter]
    extern "js" tty: JsValue;
    #[getter]
    #[setter]
    extern "js" node_tty: JsValue;
    #[getter]
    #[setter]
    extern "js" url: JsValue;
    #[getter]
    #[setter]
    extern "js" node_url: JsValue;
    #[getter]
    #[setter]
    extern "js" util: JsValue;
    #[getter]
    #[setter]
    extern "js" node_util: JsValue;
    #[getter]
    #[setter]
    extern "js" sys: JsValue;
    #[getter]
    #[setter]
    extern "js" node_sys: JsValue;
    #[getter]
    #[setter]
    extern "js" util_types: JsValue;
    #[getter]
    #[setter]
    extern "js" node_util_types: JsValue;
    #[getter]
    #[setter]
    extern "js" v8: JsValue;
    #[getter]
    #[setter]
    extern "js" node_v8: JsValue;
    #[getter]
    #[setter]
    extern "js" vm: JsValue;
    #[getter]
    #[setter]
    extern "js" node_vm: JsValue;
    #[getter]
    #[setter]
    extern "js" wasi: JsValue;
    #[getter]
    #[setter]
    extern "js" node_wasi: JsValue;
    #[getter]
    #[setter]
    extern "js" worker_threads: JsValue;
    #[getter]
    #[setter]
    extern "js" node_worker_threads: JsValue;
    #[getter]
    #[setter]
    extern "js" zlib: JsValue;
    #[getter]
    #[setter]
    extern "js" node_zlib: JsValue;
}

impl ByteLengthQueuingStrategy {
    #[getter]
    extern "js" highWaterMark: f64;
    #[getter]
    extern "js" size: QueuingStrategySize<JsValue>;
}

impl CPUProfileHandle {
    extern "js" fn stop(self) -> JsPromise<String>;
}

impl CShakeParams {
    #[getter]
    #[setter]
    extern "js" customization: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" functionName: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl CaaRecord {
    #[getter]
    #[setter]
    extern "js" critical: f64;
    #[getter]
    #[setter]
    extern "js" issue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" issuewild: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" iodef: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactemail: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactphone: Option<Option<String>>;
}

impl Cache {
    extern "js" fn delete(self, request: JsValue, options: Option<CacheQueryOptions>) -> JsPromise<bool>;
    extern "js" fn put(self, request: JsValue, response: Response) -> JsPromise<()>;
    extern "js" fn keys(self, request: Option<JsValue>, options: Option<CacheQueryOptions>) -> JsPromise<JsArray<Request>>;
    extern "js" fn add(self, request: JsValue) -> JsPromise<()>;
    extern "js" fn match_(self, request: JsValue, options: Option<CacheQueryOptions>) -> JsPromise<Option<Response>>;
    extern "js" fn matchAll(self, request: Option<JsValue>, options: Option<CacheQueryOptions>) -> JsPromise<JsArray<Response>>;
    extern "js" fn addAll(self, requests: JsArray<JsValue>) -> JsPromise<()>;
}

impl CacheControlDirectives {
    #[getter]
    #[setter]
    extern "js" max_stale: Option<f64>;
    #[getter]
    #[setter]
    extern "js" min_fresh: Option<f64>;
    #[getter]
    #[setter]
    extern "js" max_age: Option<f64>;
    #[getter]
    #[setter]
    extern "js" s_maxage: Option<f64>;
    #[getter]
    #[setter]
    extern "js" stale_while_revalidate: Option<f64>;
    #[getter]
    #[setter]
    extern "js" stale_if_error: Option<f64>;
    #[getter]
    #[setter]
    extern "js" public_: Option<bool>;
    #[getter]
    #[setter]
    extern "js" private_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" no_store: Option<bool>;
    #[getter]
    #[setter]
    extern "js" no_cache: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" must_revalidate: Option<bool>;
    #[getter]
    #[setter]
    extern "js" proxy_revalidate: Option<bool>;
    #[getter]
    #[setter]
    extern "js" immutable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" no_transform: Option<bool>;
    #[getter]
    #[setter]
    extern "js" must_understand: Option<bool>;
    #[getter]
    #[setter]
    extern "js" only_if_cached: Option<bool>;
}

impl CacheHandlerOptions {
    #[getter]
    #[setter]
    extern "js" store: CacheStore;
    #[getter]
    #[setter]
    extern "js" cacheByDefault: Option<f64>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
}

impl CacheKey {
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl CacheOptions {
    #[getter]
    #[setter]
    extern "js" store: Option<CacheStore>;
    #[getter]
    #[setter]
    extern "js" methods: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" cacheByDefault: Option<f64>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
}

impl CacheQueryOptions {
    #[getter]
    #[setter]
    extern "js" ignoreSearch: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreMethod: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreVary: Option<bool>;
}

impl CacheStorage {
    extern "js" fn match_(self, request: JsValue, options: Option<MultiCacheQueryOptions>) -> JsPromise<Option<Response>>;
    extern "js" fn has(self, cacheName: String) -> JsPromise<bool>;
    extern "js" fn open(self, cacheName: String) -> JsPromise<Cache>;
    extern "js" fn keys(self) -> JsPromise<JsArray<String>>;
    extern "js" fn delete(self, cacheName: String) -> JsPromise<bool>;
}

impl CacheStore {
    extern "js" fn createWriteStream(self, key: CacheKey, val: CacheValue) -> Option<Writable>;
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
    extern "js" fn get(self, key: CacheKey) -> JsValue;
}

impl CacheValue {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusMessage: String;
    #[getter]
    #[setter]
    extern "js" headers: JsValue;
    #[getter]
    #[setter]
    extern "js" vary: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" etag: Option<String>;
    #[getter]
    #[setter]
    extern "js" cacheControlDirectives: Option<CacheControlDirectives>;
    #[getter]
    #[setter]
    extern "js" cachedAt: f64;
    #[getter]
    #[setter]
    extern "js" staleAt: f64;
    #[getter]
    #[setter]
    extern "js" deleteAt: f64;
}

impl CallArgument {
    #[getter]
    #[setter]
    extern "js" value: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" unserializableValue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
}

impl CallFrame {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" functionLocation: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" scopeChain: JsArray<Scope>;
    #[getter]
    #[setter]
    extern "js" this: RemoteObject;
    #[getter]
    #[setter]
    extern "js" returnValue: Option<Option<RemoteObject>>;
}

impl CallFunctionOnParameterType {
    #[getter]
    #[setter]
    extern "js" functionDeclaration: String;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" arguments: Option<Option<JsArray<CallArgument>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" userGesture: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
}

impl CallFunctionOnReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl CallSite {
    extern "js" fn isToplevel(self) -> bool;
    extern "js" fn getFileName(self) -> Option<String>;
    extern "js" fn getEnclosingLineNumber(self) -> Option<f64>;
    extern "js" fn isEval(self) -> bool;
    extern "js" fn getPosition(self) -> f64;
    extern "js" fn getLineNumber(self) -> Option<f64>;
    extern "js" fn getEnclosingColumnNumber(self) -> Option<f64>;
    extern "js" fn getPromiseIndex(self) -> Option<f64>;
    extern "js" fn getEvalOrigin(self) -> Option<String>;
    extern "js" fn getThis(self) -> JsValue;
    extern "js" fn getFunction(self) -> Option<JsFn>;
    extern "js" fn getFunctionName(self) -> Option<String>;
    extern "js" fn isAsync(self) -> bool;
    extern "js" fn getTypeName(self) -> Option<String>;
    extern "js" fn isConstructor(self) -> bool;
    extern "js" fn getScriptHash(self) -> String;
    extern "js" fn isNative(self) -> bool;
    extern "js" fn getMethodName(self) -> Option<String>;
    extern "js" fn isPromiseAll(self) -> bool;
    extern "js" fn getColumnNumber(self) -> Option<f64>;
    extern "js" fn getScriptNameOrSourceURL(self) -> Option<String>;
}

impl CallSiteObject {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" scriptName: String;
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl CallTracker {
    // merged from 4 overloads
    extern "js" fn calls(self, fn_: (), exact: Option<f64>) -> fn() -> ();
    extern "js" fn report(self) -> JsArray<CallTrackerReportInformation>;
    extern "js" fn reset(self, fn_: Option<JsFn>);
    extern "js" fn verify(self);
    extern "js" fn getCalls(self, fn_: JsFn) -> JsArray<CallTrackerCall>;
}

impl CallTrackerCall {
    #[getter]
    #[setter]
    extern "js" thisArg: JsValue;
    #[getter]
    #[setter]
    extern "js" arguments: JsArray<JsValue>;
}

impl CallTrackerReportInformation {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" actual: f64;
    #[getter]
    #[setter]
    extern "js" expected: f64;
    #[getter]
    #[setter]
    extern "js" operator: String;
    #[getter]
    #[setter]
    extern "js" stack: JsValue;
}

impl Certificate {
    #[getter]
    #[setter]
    extern "js" C: String;
    #[getter]
    #[setter]
    extern "js" ST: String;
    #[getter]
    #[setter]
    extern "js" L: String;
    #[getter]
    #[setter]
    extern "js" O: String;
    #[getter]
    #[setter]
    extern "js" OU: String;
    #[getter]
    #[setter]
    extern "js" CN: String;

    extern "js" fn exportChallenge(spkac: JsValue) -> JsValue;
    extern "js" fn exportPublicKey(spkac: JsValue, encoding: Option<String>) -> JsValue;
    extern "js" fn exportChallenge(self, spkac: JsValue) -> JsValue;
    extern "js" fn verifySpkac(self, spkac: JsValue) -> bool;
    extern "js" fn verifySpkac(spkac: JsValue) -> bool;
    extern "js" fn exportPublicKey(self, spkac: JsValue, encoding: Option<String>) -> JsValue;
}

impl Channel {
    // property (readonly)
    extern "js" fn name(self) -> JsValue;
    extern "js" fn subscribe(self, onMessage: fn(JsValue, JsValue) -> ());
    // property (readonly)
    extern "js" fn hasSubscribers(self) -> bool;
    extern "js" fn unsubscribe(self, onMessage: fn(JsValue, JsValue) -> ());
    extern "js" fn bindStore(self, store: AsyncLocalStorage<JsValue>, transform: Option<fn(JsValue) -> JsValue>);
    extern "js" fn publish(self, message: JsValue);
    extern "js" fn new_(name: JsValue) -> Channel;
    extern "js" fn runStores(self, context: JsValue, fn_: JsFn, thisArg: Option<ThisArg>, args: Args) -> Result;
    extern "js" fn unbindStore(self, store: AsyncLocalStorage<JsValue>) -> bool;
}

impl CheckPrimeOptions {
    #[getter]
    #[setter]
    extern "js" checks: Option<Option<f64>>;
}

impl ChildProcess {
    // property getter
    extern "js" fn stdout(self) -> Option<Readable>;
    extern "js" fn disconnect(self);
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // property setter
    extern "js" fn set_stdout(self, value: Option<Readable>);
    // property (readonly)
    extern "js" fn exitCode(self) -> Option<f64>;
    // property setter
    extern "js" fn set_stderr(self, value: Option<Readable>);
    // property (readonly)
    extern "js" fn spawnfile(self) -> String;
    // property (readonly)
    extern "js" fn pid(self) -> Option<Option<f64>>;
    // property (readonly)
    extern "js" fn spawnargs(self) -> JsArray<String>;
    // merged from 3 overloads
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    extern "js" fn ref_(self);
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    extern "js" fn unref(self);
    // property (readonly)
    extern "js" fn killed(self) -> bool;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // property getter
    extern "js" fn stdin(self) -> Option<Writable>;
    extern "js" fn kill(self, signal: Option<JsValue>) -> bool;
    // property (readonly)
    extern "js" fn connected(self) -> bool;
    // property getter
    extern "js" fn stderr(self) -> Option<Readable>;
    // property (readonly)
    extern "js" fn signalCode(self) -> Option<String>;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // property (readonly)
    extern "js" fn channel(self) -> Option<Option<Control>>;
    // property setter
    extern "js" fn set_stdin(self, value: Option<Writable>);
    // property (readonly)
    extern "js" fn stdio(self) -> JsValue;
}

impl ChildProcessByStdio {
    #[getter]
    #[setter]
    extern "js" stdin: JsValue;
    #[getter]
    #[setter]
    extern "js" stdout: JsValue;
    #[getter]
    #[setter]
    extern "js" stderr: JsValue;
    #[getter]
    extern "js" stdio: JsValue;

    // inherited from ChildProcess
    extern "js" fn stdout(self) -> Option<Readable>;
    // inherited from ChildProcess
    extern "js" fn disconnect(self);
    // inherited from ChildProcess
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // inherited from ChildProcess
    extern "js" fn set_stdout(self, value: Option<Readable>);
    // inherited from ChildProcess
    extern "js" fn exitCode(self) -> Option<f64>;
    // inherited from ChildProcess
    extern "js" fn set_stderr(self, value: Option<Readable>);
    // inherited from ChildProcess
    extern "js" fn spawnfile(self) -> String;
    // inherited from ChildProcess
    extern "js" fn pid(self) -> Option<Option<f64>>;
    // inherited from ChildProcess
    extern "js" fn spawnargs(self) -> JsArray<String>;
    // inherited from ChildProcess
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // inherited from ChildProcess
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn ref_(self);
    // inherited from ChildProcess
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn unref(self);
    // inherited from ChildProcess
    extern "js" fn killed(self) -> bool;
    // inherited from ChildProcess
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn stdin(self) -> Option<Writable>;
    // inherited from ChildProcess
    extern "js" fn kill(self, signal: Option<JsValue>) -> bool;
    // inherited from ChildProcess
    extern "js" fn connected(self) -> bool;
    // inherited from ChildProcess
    extern "js" fn stderr(self) -> Option<Readable>;
    // inherited from ChildProcess
    extern "js" fn signalCode(self) -> Option<String>;
    // inherited from ChildProcess
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn channel(self) -> Option<Option<Control>>;
    // inherited from ChildProcess
    extern "js" fn set_stdin(self, value: Option<Writable>);
    // inherited from ChildProcess
    extern "js" fn stdio(self) -> JsValue;
}

impl ChildProcessWithoutNullStreams {
    #[getter]
    #[setter]
    extern "js" stdin: Writable;
    #[getter]
    #[setter]
    extern "js" stdout: Readable;
    #[getter]
    #[setter]
    extern "js" stderr: Readable;
    #[getter]
    extern "js" stdio: JsValue;

    // inherited from ChildProcess
    extern "js" fn stdout(self) -> Option<Readable>;
    // inherited from ChildProcess
    extern "js" fn disconnect(self);
    // inherited from ChildProcess
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // inherited from ChildProcess
    extern "js" fn set_stdout(self, value: Option<Readable>);
    // inherited from ChildProcess
    extern "js" fn exitCode(self) -> Option<f64>;
    // inherited from ChildProcess
    extern "js" fn set_stderr(self, value: Option<Readable>);
    // inherited from ChildProcess
    extern "js" fn spawnfile(self) -> String;
    // inherited from ChildProcess
    extern "js" fn pid(self) -> Option<Option<f64>>;
    // inherited from ChildProcess
    extern "js" fn spawnargs(self) -> JsArray<String>;
    // inherited from ChildProcess
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // inherited from ChildProcess
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn ref_(self);
    // inherited from ChildProcess
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn unref(self);
    // inherited from ChildProcess
    extern "js" fn killed(self) -> bool;
    // inherited from ChildProcess
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn stdin(self) -> Option<Writable>;
    // inherited from ChildProcess
    extern "js" fn kill(self, signal: Option<JsValue>) -> bool;
    // inherited from ChildProcess
    extern "js" fn connected(self) -> bool;
    // inherited from ChildProcess
    extern "js" fn stderr(self) -> Option<Readable>;
    // inherited from ChildProcess
    extern "js" fn signalCode(self) -> Option<String>;
    // inherited from ChildProcess
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // inherited from ChildProcess
    extern "js" fn channel(self) -> Option<Option<Control>>;
    // inherited from ChildProcess
    extern "js" fn set_stdin(self, value: Option<Writable>);
    // inherited from ChildProcess
    extern "js" fn stdio(self) -> JsValue;
}

impl CipherCCM {
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> CipherCCM;
    extern "js" fn getAuthTag(self) -> JsValue;
    // inherited from Cipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn new_() -> Cipheriv;
    // inherited from Cipheriv
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
}

impl CipherCCMOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: f64;
}

impl CipherChaCha20Poly1305 {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> CipherChaCha20Poly1305;
    // inherited from Cipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn new_() -> Cipheriv;
    // inherited from Cipheriv
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
}

impl CipherChaCha20Poly1305Options {
    #[getter]
    #[setter]
    extern "js" authTagLength: Option<Option<f64>>;
}

impl CipherGCM {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> CipherGCM;
    // inherited from Cipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn new_() -> Cipheriv;
    // inherited from Cipheriv
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
}

impl CipherGCMOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: Option<Option<f64>>;
}

impl CipherInfo {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nid: f64;
    #[getter]
    #[setter]
    extern "js" blockSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ivLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keyLength: f64;
    #[getter]
    #[setter]
    extern "js" mode: String;
}

impl CipherInfoOptions {
    #[getter]
    #[setter]
    extern "js" keyLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ivLength: Option<Option<f64>>;
}

impl CipherNameAndProtocol {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" version: String;
    #[getter]
    #[setter]
    extern "js" standardName: String;
}

impl CipherOCB {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> CipherOCB;
    // inherited from Cipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Cipheriv
    extern "js" fn new_() -> Cipheriv;
    // inherited from Cipheriv
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
}

impl CipherOCBOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: f64;
}

impl Cipheriv {
    // merged from 2 overloads
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // merged from 4 overloads
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    extern "js" fn new_() -> Cipheriv;
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
}

impl Client {
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn pipelining(self) -> f64;
    // property getter
    extern "js" fn closed(self) -> bool;
    // property setter
    extern "js" fn set_pipelining(self, value: f64);
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    extern "js" fn new_(url: JsValue, options: Option<Options>) -> Client;
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
}

impl ClientBeforeConnectMessage {
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientClosedError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl ClientConnectErrorMessage {
    #[getter]
    #[setter]
    extern "js" error: JsValue;
    #[getter]
    #[setter]
    extern "js" socket: Socket;
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientConnectedMessage {
    #[getter]
    #[setter]
    extern "js" socket: Socket;
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientDestroyedError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl ClientHttp2Session {
    #[getter]
    extern "js" alpnProtocol: Option<Option<String>>;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" connecting: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" encrypted: Option<Option<bool>>;
    #[getter]
    extern "js" localSettings: Settings;
    #[getter]
    extern "js" originSet: Option<Option<JsArray<String>>>;
    #[getter]
    extern "js" pendingSettingsAck: bool;
    #[getter]
    extern "js" remoteSettings: Settings;
    #[getter]
    extern "js" socket: JsValue;
    #[getter]
    extern "js" state: SessionState;
    #[getter]
    extern "js" type_: f64;

    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn emit(self, event: String, stream: ClientHttp2Stream, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    extern "js" fn request(self, headers: Option<JsValue>, options: Option<ClientSessionRequestOptions>) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // inherited from Http2Session
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // inherited from Http2Session
    extern "js" fn settings(self, settings: Settings, callback: Option<fn(Option<JsValue>, Settings, f64) -> ()>);
    // inherited from Http2Session
    extern "js" fn goaway(self, code: Option<f64>, lastStreamID: Option<f64>, opaqueData: Option<JsValue>);
    // inherited from Http2Session
    extern "js" fn setLocalWindowSize(self, windowSize: f64);
    // inherited from Http2Session
    extern "js" fn ping(self, payload: JsValue, callback: Option<fn(Option<JsValue>, f64, JsValue) -> ()>) -> bool;
    // inherited from Http2Session
    extern "js" fn unref(self);
    // inherited from Http2Session
    extern "js" fn ref_(self);
    // inherited from Http2Session
    extern "js" fn destroy(self, error: Option<JsValue>, code: Option<f64>);
    // inherited from Http2Session
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl ClientHttp2Stream {
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    extern "js" bufferSize: f64;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" endAfterHeaders: bool;
    #[getter]
    extern "js" id: Option<Option<f64>>;
    #[getter]
    extern "js" pending: bool;
    #[getter]
    extern "js" rstCode: f64;
    #[getter]
    extern "js" sentHeaders: OutgoingHttpHeaders;
    #[getter]
    extern "js" sentInfoHeaders: Option<Option<JsArray<OutgoingHttpHeaders>>>;
    #[getter]
    extern "js" sentTrailers: Option<Option<OutgoingHttpHeaders>>;
    #[getter]
    extern "js" session: Option<Http2Session>;
    #[getter]
    extern "js" state: StreamState;

    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn emit(self, event: String, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // inherited from Http2Stream
    extern "js" fn close(self, code: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from Http2Stream
    extern "js" fn sendTrailers(self, headers: OutgoingHttpHeaders);
    // inherited from Http2Stream
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // inherited from Http2Stream
    extern "js" fn priority(self, options: JsValue);
}

impl ClientRequest {
    // property setter
    extern "js" fn set_reusedSocket(self, value: bool);
    extern "js" fn new_(url: JsValue, cb: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // property setter
    extern "js" fn set_maxHeadersCount(self, value: f64);
    // property setter
    extern "js" fn set_method(self, value: String);
    // property setter
    extern "js" fn set_path(self, value: String);
    extern "js" fn setSocketKeepAlive(self, enable: Option<bool>, initialDelay: Option<f64>);
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property getter
    extern "js" fn aborted(self) -> bool;
    // property setter
    extern "js" fn set_host(self, value: String);
    // property getter
    extern "js" fn method(self) -> String;
    // property setter
    extern "js" fn set_protocol(self, value: String);
    // property getter
    extern "js" fn path(self) -> String;
    // property getter
    extern "js" fn maxHeadersCount(self) -> f64;
    extern "js" fn getRawHeaderNames(self) -> JsArray<String>;
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> ClientRequest;
    extern "js" fn setTimeout(self, timeout: f64, callback: Option<fn() -> ()>) -> ClientRequest;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property getter
    extern "js" fn reusedSocket(self) -> bool;
    // property getter
    extern "js" fn host(self) -> String;
    extern "js" fn setNoDelay(self, noDelay: Option<bool>);
    // property getter
    extern "js" fn protocol(self) -> String;
    // property setter
    extern "js" fn set_aborted(self, value: bool);
    extern "js" fn abort(self);
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    extern "js" fn onSocket(self, socket: Socket);
}

impl ClientRequestArgs {
    #[getter]
    #[setter]
    extern "js" _defaultAgent: Option<Option<Agent>>;
    #[getter]
    #[setter]
    extern "js" agent: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" createConnection: Option<Option<fn(ClientRequestArgs, fn(Option<JsValue>, Duplex) -> ()) -> Option<Duplex>>>;
    #[getter]
    #[setter]
    extern "js" defaultPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" insecureHTTPParser: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" setDefaultHeaders: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setHost: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uniqueHeaders: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" joinDuplicateHeaders: Option<Option<bool>>;
}

impl ClientSendHeadersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" headers: String;
    #[getter]
    #[setter]
    extern "js" socket: Socket;
}

impl ClientSessionOptions {
    #[getter]
    #[setter]
    extern "js" maxReservedRemoteStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" createConnection: Option<Option<fn(URL, SessionOptions) -> Duplex>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl ClientSessionRequestOptions {
    #[getter]
    #[setter]
    extern "js" endStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" parent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ClientStats {
    // property getter
    extern "js" fn pending(self) -> f64;
    // property setter
    extern "js" fn set_pending(self, value: f64);
    extern "js" fn new_(pool: Client) -> ClientStats;
    // property setter
    extern "js" fn set_running(self, value: f64);
    // property getter
    extern "js" fn connected(self) -> bool;
    // property getter
    extern "js" fn size(self) -> f64;
    // property setter
    extern "js" fn set_connected(self, value: bool);
    // property getter
    extern "js" fn running(self) -> f64;
    // property setter
    extern "js" fn set_size(self, value: f64);
}

impl CloseEvent {
    #[getter]
    extern "js" code: f64;
    #[getter]
    extern "js" reason: String;
    #[getter]
    extern "js" wasClean: bool;
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;

    // inherited from Event
    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    // inherited from Event
    extern "js" fn stopPropagation(self);
    // inherited from Event
    extern "js" fn composedPath(self) -> (EventTarget);
    // inherited from Event
    extern "js" fn stopImmediatePropagation(self);
    // inherited from Event
    extern "js" fn preventDefault(self);
}

impl CloseEventInit {
    #[getter]
    #[setter]
    extern "js" code: Option<f64>;
    #[getter]
    #[setter]
    extern "js" reason: Option<String>;
    #[getter]
    #[setter]
    extern "js" wasClean: Option<bool>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl CloseParameterType {
    #[getter]
    #[setter]
    extern "js" handle: String;
}

impl Cluster {
    #[getter]
    extern "js" isMaster: bool;
    #[getter]
    extern "js" isPrimary: bool;
    #[getter]
    extern "js" isWorker: bool;
    #[getter]
    #[setter]
    extern "js" schedulingPolicy: f64;
    #[getter]
    extern "js" settings: ClusterSettings;
    #[getter]
    extern "js" worker: Option<Worker>;
    #[getter]
    extern "js" workers: Option<Dict<Worker>>;
    #[getter]
    extern "js" SCHED_NONE: f64;
    #[getter]
    extern "js" SCHED_RR: f64;

    extern "js" fn setupPrimary(self, settings: Option<ClusterSettings>);
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    extern "js" fn fork(self, env: Option<JsValue>) -> Worker;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, worker: Worker, code: Option<f64>, signal: Option<String>) -> bool;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    extern "js" fn disconnect(self, callback: Option<fn() -> ()>);
    extern "js" fn setupMaster(self, settings: Option<ClusterSettings>);
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl ClusterSettings {
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" exec: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" inspectPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
}

impl ColumnDefinition {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" column: Option<String>;
    #[getter]
    #[setter]
    extern "js" table: Option<String>;
    #[getter]
    #[setter]
    extern "js" database: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
}

impl CommonConnectionOptions {
    #[getter]
    #[setter]
    extern "js" secureContext: Option<Option<SecureContext>>;
    #[getter]
    #[setter]
    extern "js" enableTrace: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requestCert: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNProtocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" SNICallback: Option<Option<fn(String, fn(Option<JsValue>, SecureContext) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
}

impl CommonExecOptions {
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl CommonOptions {
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl CommonSpawnOptions {
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl CompileFunctionOptions {
    #[getter]
    #[setter]
    extern "js" parsingContext: Option<Option<Context>>;
    #[getter]
    #[setter]
    extern "js" contextExtensions: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl CompileScriptParameterType {
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" sourceURL: String;
    #[getter]
    #[setter]
    extern "js" persistScript: bool;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl CompileScriptReturnType {
    #[getter]
    #[setter]
    extern "js" scriptId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl ComposedDispatcher {
    // inherited from Dispatcher
    extern "js" fn upgrade(self, options: UpgradeOptions, callback: Option<fn(Option<JsValue>, UpgradeData) -> ()>);
    // inherited from Dispatcher
    extern "js" fn addListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn listeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // inherited from Dispatcher
    extern "js" fn destroy(self, err: Option<JsValue>, callback: Option<fn() -> ()>);
    // inherited from Dispatcher
    extern "js" fn connect(self, options: ConnectOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ConnectData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    // inherited from Dispatcher
    extern "js" fn removeListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn prependListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn pipeline(self, options: PipelineOptions<TOpaque>, handler: fn(PipelineHandlerData<TOpaque>) -> Readable) -> Duplex;
    // inherited from Dispatcher
    extern "js" fn on(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn rawListeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // inherited from Dispatcher
    extern "js" fn once(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn off(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn request(self, options: RequestOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ResponseData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn stream(self, options: RequestOptions<TOpaque>, factory: fn(StreamFactoryData<TOpaque>) -> Writable, callback: Option<fn(Option<JsValue>, StreamData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Dispatcher
    extern "js" fn compose(self, dispatchers: JsArray<fn(JsValue) -> JsValue>) -> ComposedDispatcher;
    // inherited from Dispatcher
    extern "js" fn prependOnceListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn emit(self, eventName: String, origin: URL, targets: Option<JsArray<Dispatcher>>, error: Option<UndiciError>) -> bool;
}

impl CompressionStream {
    // property (readonly)
    extern "js" fn readable(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn writable(self) -> WritableStream;
    extern "js" fn new_(format: String) -> CompressionStream;
}

impl ConnectData {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
}

impl ConnectOptions {
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
}

impl ConnectParams {
    #[getter]
    #[setter]
    extern "js" host: JsValue;
    #[getter]
    #[setter]
    extern "js" hostname: JsValue;
    #[getter]
    #[setter]
    extern "js" protocol: JsValue;
    #[getter]
    #[setter]
    extern "js" port: JsValue;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
}

impl ConnectTimeoutError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl ConnectionOptions {
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" socket: Option<Option<Duplex>>;
    #[getter]
    #[setter]
    extern "js" checkServerIdentity: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" servername: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" session: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" minDHSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" pskCallback: Option<Option<fn(Option<String>) -> Option<PSKCallbackNegotation>>>;
    #[getter]
    #[setter]
    extern "js" ALPNCallback: Option<Option<fn(JsValue) -> Option<String>>>;
    #[getter]
    #[setter]
    extern "js" allowPartialTrustChain: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ca: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cert: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sigalgs: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ciphers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" clientCertEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dhparam: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" ecdhCurve: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" honorCipherOrder: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" key: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" privateKeyEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" privateKeyIdentifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" maxVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" minVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pfx: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" secureOptions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureProtocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sessionIdContext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureContext: Option<Option<SecureContext>>;
    #[getter]
    #[setter]
    extern "js" enableTrace: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requestCert: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNProtocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" SNICallback: Option<Option<fn(String, fn(Option<JsValue>, SecureContext) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
}

impl Console {
    #[getter]
    #[setter]
    extern "js" Console: ConsoleConstructor;

    extern "js" fn assert(self, value: JsValue, message: Option<String>, optionalParams: JsArray<JsValue>);
    extern "js" fn debug(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn dirxml(self, data: JsArray<JsValue>);
    extern "js" fn timeEnd(self, label: Option<String>);
    extern "js" fn timeLog(self, label: Option<String>, data: JsArray<JsValue>);
    extern "js" fn log(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn warn(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn clear(self);
    extern "js" fn trace(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn error(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn table(self, tabularData: JsValue, properties: Option<JsArray<String>>);
    extern "js" fn count(self, label: Option<String>);
    extern "js" fn profileEnd(self, label: Option<String>);
    extern "js" fn time(self, label: Option<String>);
    extern "js" fn profile(self, label: Option<String>);
    extern "js" fn timeStamp(self, label: Option<String>);
    extern "js" fn info(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn groupCollapsed(self, label: JsArray<JsValue>);
    extern "js" fn groupEnd(self);
    extern "js" fn dir(self, obj: JsValue, options: Option<InspectOptions>);
    extern "js" fn countReset(self, label: Option<String>);
    extern "js" fn group(self, label: JsArray<JsValue>);
}

impl ConsoleAPICalledEventDataType {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" args: JsArray<RemoteObject>;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<String>>;
}

impl ConsoleConstructor {
    #[getter]
    #[setter]
    extern "js" prototype: Console;

    // merged from 2 overloads
    extern "js" fn new_(stdout: WritableStream, stderr: Option<WritableStream>, ignoreErrors: Option<bool>) -> Console;
}

impl ConsoleConstructorOptions {
    #[getter]
    #[setter]
    extern "js" stdout: WritableStream;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" ignoreErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" colorMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" inspectOptions: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" groupIndentation: Option<Option<f64>>;
}

impl ConsoleMessage {
    #[getter]
    #[setter]
    extern "js" source: String;
    #[getter]
    #[setter]
    extern "js" level: String;
    #[getter]
    #[setter]
    extern "js" text: String;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" line: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" column: Option<Option<f64>>;
}

impl ConsoleProfileFinishedEventDataType {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" profile: Profile;
    #[getter]
    #[setter]
    extern "js" title: Option<Option<String>>;
}

impl ConsoleProfileStartedEventDataType {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" title: Option<Option<String>>;
}

impl ContextParams {
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl ContinueToLocationParameterType {
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" targetCallFrames: Option<Option<String>>;
}

impl Control {
    extern "js" fn ref_(self);
    extern "js" fn unref(self);
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl Cookie {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: String;
    #[getter]
    #[setter]
    extern "js" expires: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxAge: Option<f64>;
    #[getter]
    #[setter]
    extern "js" domain: Option<String>;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" secure: Option<bool>;
    #[getter]
    #[setter]
    extern "js" httpOnly: Option<bool>;
    #[getter]
    #[setter]
    extern "js" sameSite: Option<String>;
    #[getter]
    #[setter]
    extern "js" unparsed: Option<JsArray<String>>;
}

impl CopyOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String, String) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" dereference: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" errorOnExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" preserveTimestamps: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" verbatimSymlinks: Option<Option<bool>>;
}

impl CopyOptionsBase {
    #[getter]
    #[setter]
    extern "js" dereference: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" errorOnExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" preserveTimestamps: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" verbatimSymlinks: Option<Option<bool>>;
}

impl CopySyncOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String, String) -> bool>>;
    #[getter]
    #[setter]
    extern "js" dereference: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" errorOnExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" preserveTimestamps: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" verbatimSymlinks: Option<Option<bool>>;
}

impl CountQueuingStrategy {
    #[getter]
    extern "js" highWaterMark: f64;
    #[getter]
    extern "js" size: QueuingStrategySize;
}

impl CoverageRange {
    #[getter]
    #[setter]
    extern "js" startOffset: f64;
    #[getter]
    #[setter]
    extern "js" endOffset: f64;
    #[getter]
    #[setter]
    extern "js" count: f64;
}

impl CpuInfo {
    #[getter]
    #[setter]
    extern "js" model: String;
    #[getter]
    #[setter]
    extern "js" speed: f64;
    #[getter]
    #[setter]
    extern "js" times: JsValue;
}

impl CpuUsage {
    #[getter]
    #[setter]
    extern "js" user: f64;
    #[getter]
    #[setter]
    extern "js" system: f64;
}

impl CreateContextOptions {
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" codeGeneration: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" microtaskMode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl CreateHistogramOptions {
    #[getter]
    #[setter]
    extern "js" lowest: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" highest: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" figures: Option<Option<f64>>;
}

impl CreateReadStreamFSImplementation {
    // function property
    extern "js" fn read(self) -> fn(JsArray<JsValue>) -> JsValue;
    // inherited from FSImplementation
    extern "js" fn open(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
    // inherited from FSImplementation
    extern "js" fn close(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
}

impl CreateReadStreamOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl CreateSessionOptions {
    #[getter]
    #[setter]
    extern "js" table: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" db: Option<Option<String>>;
}

impl CreateTracingOptions {
    #[getter]
    #[setter]
    extern "js" categories: JsArray<String>;
}

impl CreateWriteStreamFSImplementation {
    // function property
    extern "js" fn write(self) -> fn(JsArray<JsValue>) -> JsValue;
    // function property
    extern "js" fn writev(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
    // inherited from FSImplementation
    extern "js" fn open(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
    // inherited from FSImplementation
    extern "js" fn close(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
}

impl CreateWriteStreamOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<bool>>;
}

impl Crypto {
    #[getter]
    extern "js" subtle: SubtleCrypto;

    extern "js" fn getRandomValues(self, typedArray: JsValue) -> JsValue;
    extern "js" fn randomUUID(self) -> String;
}

impl CryptoKey {
    #[getter]
    extern "js" algorithm: KeyAlgorithm;
    #[getter]
    extern "js" extractable: bool;
    #[getter]
    extern "js" type_: String;
    #[getter]
    extern "js" usages: JsArray<String>;
}

impl CryptoKeyPair {
    #[getter]
    #[setter]
    extern "js" privateKey: CryptoKey;
    #[getter]
    #[setter]
    extern "js" publicKey: CryptoKey;
}

impl CursorPos {
    #[getter]
    #[setter]
    extern "js" rows: f64;
    #[getter]
    #[setter]
    extern "js" cols: f64;
}

impl CustomEvent {
    #[getter]
    extern "js" detail: JsValue;
}

impl CustomEventInit {
    #[getter]
    #[setter]
    extern "js" detail: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl CustomPreview {
    #[getter]
    #[setter]
    extern "js" header: String;
    #[getter]
    #[setter]
    extern "js" hasBody: bool;
    #[getter]
    #[setter]
    extern "js" formatterObjectId: String;
    #[getter]
    #[setter]
    extern "js" bindRemoteObjectFunctionId: String;
    #[getter]
    #[setter]
    extern "js" configObjectId: Option<Option<String>>;
}

impl CustomPromisifyLegacy {
    #[getter]
    #[setter]
    extern "js" __promisify__: JsValue;
}

impl DOMException {
    #[getter]
    extern "js" code: f64;
    #[getter]
    extern "js" message: String;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" INDEX_SIZE_ERR: f64;
    #[getter]
    extern "js" DOMSTRING_SIZE_ERR: f64;
    #[getter]
    extern "js" HIERARCHY_REQUEST_ERR: f64;
    #[getter]
    extern "js" WRONG_DOCUMENT_ERR: f64;
    #[getter]
    extern "js" INVALID_CHARACTER_ERR: f64;
    #[getter]
    extern "js" NO_DATA_ALLOWED_ERR: f64;
    #[getter]
    extern "js" NO_MODIFICATION_ALLOWED_ERR: f64;
    #[getter]
    extern "js" NOT_FOUND_ERR: f64;
    #[getter]
    extern "js" NOT_SUPPORTED_ERR: f64;
    #[getter]
    extern "js" INUSE_ATTRIBUTE_ERR: f64;
    #[getter]
    extern "js" INVALID_STATE_ERR: f64;
    #[getter]
    extern "js" SYNTAX_ERR: f64;
    #[getter]
    extern "js" INVALID_MODIFICATION_ERR: f64;
    #[getter]
    extern "js" NAMESPACE_ERR: f64;
    #[getter]
    extern "js" INVALID_ACCESS_ERR: f64;
    #[getter]
    extern "js" VALIDATION_ERR: f64;
    #[getter]
    extern "js" TYPE_MISMATCH_ERR: f64;
    #[getter]
    extern "js" SECURITY_ERR: f64;
    #[getter]
    extern "js" NETWORK_ERR: f64;
    #[getter]
    extern "js" ABORT_ERR: f64;
    #[getter]
    extern "js" URL_MISMATCH_ERR: f64;
    #[getter]
    extern "js" QUOTA_EXCEEDED_ERR: f64;
    #[getter]
    extern "js" TIMEOUT_ERR: f64;
    #[getter]
    extern "js" INVALID_NODE_TYPE_ERR: f64;
    #[getter]
    extern "js" DATA_CLONE_ERR: f64;
}

impl DSAKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" divisorLength: f64;
}

impl DSAKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" divisorLength: f64;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl DataCollectedEventDataType {
    #[getter]
    #[setter]
    extern "js" value: JsArray<JsValue>;
}

impl DataReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" dataLength: f64;
    #[getter]
    #[setter]
    extern "js" encodedDataLength: f64;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<String>>;
}

impl Database {
    #[getter]
    #[setter]
    extern "js" memory: bool;
    #[getter]
    #[setter]
    extern "js" readonly_: bool;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" open: bool;
    #[getter]
    #[setter]
    extern "js" inTransaction: bool;

    extern "js" fn transaction(self, fn_: JsValue) -> JsValue;
    extern "js" fn loadExtension(self, path: String) -> Database;
    // merged from 2 overloads
    extern "js" fn function_(self, name: String, options: RegistrationOptions, cb: Option<fn(JsArray<JsValue>) -> JsValue>) -> Database;
    extern "js" fn pragma(self, source: String, options: Option<PragmaOptions>) -> JsValue;
    extern "js" fn defaultSafeIntegers(self, toggleState: Option<bool>) -> Database;
    extern "js" fn aggregate(self, name: String, options: RegistrationOptions) -> Database;
    extern "js" fn backup(self, destinationFile: String, options: Option<BackupOptions>) -> JsPromise<BackupMetadata>;
    extern "js" fn serialize(self, options: Option<SerializeOptions>) -> Buffer;
    extern "js" fn exec(self, source: String) -> Database;
    extern "js" fn close(self) -> Database;
    extern "js" fn table(self, name: String, options: VirtualTableOptions) -> Database;
    extern "js" fn prepare(self, source: String) -> Statement<JsValue, JsValue>;
    extern "js" fn unsafeMode(self, unsafe: Option<bool>) -> Database;
}

impl DatabaseConstructor {
    #[getter]
    #[setter]
    extern "js" prototype: Database;
    #[getter]
    #[setter]
    extern "js" SqliteError: JsValue;

    // constructor
    extern "js" fn new_(filename: Option<JsValue>, options: Option<Options>) -> Database;
}

impl DatabaseSync {
    extern "js" fn prepare(self, sql: String) -> StatementSync;
    extern "js" fn location(self, dbName: Option<String>) -> Option<String>;
    // property (readonly)
    extern "js" fn isTransaction(self) -> bool;
    extern "js" fn close(self);
    extern "js" fn setAuthorizer(self, callback: Option<fn(f64, Option<String>, Option<String>, Option<String>, Option<String>) -> f64>);
    // property (readonly)
    extern "js" fn isOpen(self) -> bool;
    extern "js" fn exec(self, sql: String);
    // merged from 2 overloads
    extern "js" fn function_(self, name: String, options: FunctionOptions, func: Option<fn(JsArray<JsValue>) -> JsValue>);
    extern "js" fn applyChangeset(self, changeset: JsValue, options: Option<ApplyChangesetOptions>) -> bool;
    extern "js" fn loadExtension(self, path: String);
    extern "js" fn createTagStore(self, maxSize: Option<f64>) -> SQLTagStore;
    // merged from 2 overloads
    extern "js" fn aggregate(self, name: String, options: JsValue);
    extern "js" fn open(self);
    extern "js" fn new_(path: JsValue, options: Option<DatabaseSyncOptions>) -> DatabaseSync;
    extern "js" fn enableLoadExtension(self, allow: bool);
    extern "js" fn createSession(self, options: Option<CreateSessionOptions>) -> Session;
}

impl DatabaseSyncOptions {
    #[getter]
    #[setter]
    extern "js" open: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" enableForeignKeyConstraints: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" enableDoubleQuotedStringLiterals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowExtension: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" readBigInts: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnArrays: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowBareNamedParameters: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowUnknownNamedParameters: Option<Option<bool>>;
}

impl DebugLogger {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl DecipherCCM {
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherCCM;
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> DecipherCCM;
    // inherited from Decipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn new_() -> Decipheriv;
    // inherited from Decipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
}

impl DecipherChaCha20Poly1305 {
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherChaCha20Poly1305;
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> DecipherChaCha20Poly1305;
    // inherited from Decipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn new_() -> Decipheriv;
    // inherited from Decipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
}

impl DecipherGCM {
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherGCM;
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> DecipherGCM;
    // inherited from Decipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn new_() -> Decipheriv;
    // inherited from Decipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
}

impl DecipherOCB {
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> DecipherOCB;
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherOCB;
    // inherited from Decipheriv
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn new_() -> Decipheriv;
    // inherited from Decipheriv
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    // inherited from Decipheriv
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
}

impl Decipheriv {
    // merged from 2 overloads
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    extern "js" fn new_() -> Decipheriv;
    // merged from 4 overloads
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
}

impl DecompressionStream {
    // property (readonly)
    extern "js" fn writable(self) -> WritableStream;
    // property (readonly)
    extern "js" fn readable(self) -> ReadableStream;
    extern "js" fn new_(format: String) -> DecompressionStream;
}

impl DecoratorHandler {
    extern "js" fn new_(handler: DispatchHandler) -> DecoratorHandler;
}

impl Deflate {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from ZlibReset
    extern "js" fn reset(self);
    // inherited from ZlibParams
    extern "js" fn params(self, level: f64, strategy: f64, callback: fn() -> ());
}

impl DeflateRaw {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from ZlibReset
    extern "js" fn reset(self);
    // inherited from ZlibParams
    extern "js" fn params(self, level: f64, strategy: f64, callback: fn() -> ());
}

impl DeleteByUri {
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" path: String;
}

impl Deserializer {
    extern "js" fn readDouble(self) -> f64;
    extern "js" fn readUint32(self) -> f64;
    extern "js" fn readHeader(self) -> bool;
    extern "js" fn getWireFormatVersion(self) -> f64;
    extern "js" fn new_(data: JsValue) -> Deserializer;
    extern "js" fn readValue(self) -> JsValue;
    extern "js" fn readUint64(self) -> (f64, f64);
    extern "js" fn readRawBytes(self, length: f64) -> Buffer;
    extern "js" fn transferArrayBuffer(self, id: f64, arrayBuffer: JsValue);
}

impl DetachParameterType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl DetachedFromWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl DetailedPeerCertificate {
    #[getter]
    #[setter]
    extern "js" issuerCertificate: DetailedPeerCertificate;
    #[getter]
    #[setter]
    extern "js" ca: bool;
    #[getter]
    #[setter]
    extern "js" raw: Buffer<JsValue>;
    #[getter]
    #[setter]
    extern "js" subject: Certificate;
    #[getter]
    #[setter]
    extern "js" issuer: Certificate;
    #[getter]
    #[setter]
    extern "js" valid_from: String;
    #[getter]
    #[setter]
    extern "js" valid_to: String;
    #[getter]
    #[setter]
    extern "js" serialNumber: String;
    #[getter]
    #[setter]
    extern "js" fingerprint: String;
    #[getter]
    #[setter]
    extern "js" fingerprint256: String;
    #[getter]
    #[setter]
    extern "js" fingerprint512: String;
    #[getter]
    #[setter]
    extern "js" ext_key_usage: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" subjectaltname: Option<String>;
    #[getter]
    #[setter]
    extern "js" infoAccess: Option<Dict<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" bits: Option<f64>;
    #[getter]
    #[setter]
    extern "js" exponent: Option<String>;
    #[getter]
    #[setter]
    extern "js" modulus: Option<String>;
    #[getter]
    #[setter]
    extern "js" pubkey: Option<Buffer<JsValue>>;
    #[getter]
    #[setter]
    extern "js" asn1Curve: Option<String>;
    #[getter]
    #[setter]
    extern "js" nistCurve: Option<String>;
}

impl DiffieHellman {
    // property getter
    extern "js" fn verifyError(self) -> f64;
    // merged from 2 overloads
    extern "js" fn getPublicKey(self, encoding: Option<String>) -> String;
    // merged from 4 overloads
    extern "js" fn computeSecret(self, otherPublicKey: JsValue, inputEncoding: Option<()>, outputEncoding: Option<()>) -> JsValue;
    extern "js" fn new_() -> DiffieHellman;
    // merged from 2 overloads
    extern "js" fn getGenerator(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn setPublicKey(self, publicKey: String, encoding: Option<JsValue>);
    // merged from 2 overloads
    extern "js" fn generateKeys(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getPrime(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getPrivateKey(self, encoding: Option<String>) -> String;
    // property setter
    extern "js" fn set_verifyError(self, value: f64);
    // merged from 2 overloads
    extern "js" fn setPrivateKey(self, privateKey: String, encoding: Option<JsValue>);
}

impl DiffieHellmanGroupConstructor {
    #[getter]
    extern "js" prototype: JsValue;

    // constructor
    extern "js" fn new_(name: String) -> JsValue;
}

impl Dir {
    extern "js" fn readSync(self) -> Option<Dirent>;
    // property (readonly)
    extern "js" fn path(self) -> String;
    // merged from 2 overloads
    extern "js" fn close(self, cb: Option<fn(Option<ErrnoException>) -> ()>);
    extern "js" fn closeSync(self);
    // merged from 2 overloads
    extern "js" fn read(self, cb: Option<fn(Option<ErrnoException>, Option<Dirent>) -> ()>);
}

impl Dirent {
    extern "js" fn isBlockDevice(self) -> bool;
    // property setter
    extern "js" fn set_name(self, value: JsValue);
    extern "js" fn isSocket(self) -> bool;
    // property getter
    extern "js" fn parentPath(self) -> String;
    // property setter
    extern "js" fn set_parentPath(self, value: String);
    extern "js" fn isFile(self) -> bool;
    extern "js" fn isFIFO(self) -> bool;
    // property getter
    extern "js" fn name(self) -> JsValue;
    extern "js" fn isSymbolicLink(self) -> bool;
    extern "js" fn isCharacterDevice(self) -> bool;
    extern "js" fn isDirectory(self) -> bool;
}

impl DispatchController {
    extern "js" fn abort(self, reason: JsValue);
    extern "js" fn aborted(self) -> bool;
    extern "js" fn resume(self);
    extern "js" fn paused(self) -> bool;
    extern "js" fn pause(self);
    extern "js" fn reason(self) -> Option<JsValue>;
}

impl DispatchHandler {
    extern "js" fn onComplete(self, trailers: Option<JsArray<String>>);
    extern "js" fn onResponseStart(self, controller: DispatchController, statusCode: f64, headers: IncomingHttpHeaders, statusMessage: Option<String>);
    extern "js" fn onResponseEnd(self, controller: DispatchController, trailers: IncomingHttpHeaders);
    extern "js" fn onBodySent(self, chunkSize: f64, totalBytesSent: f64);
    extern "js" fn onResponseData(self, controller: DispatchController, chunk: Buffer);
    extern "js" fn onConnect(self, abort: fn(JsValue) -> ());
    extern "js" fn onError(self, err: JsValue);
    extern "js" fn onRequestStart(self, controller: DispatchController, context: JsValue);
    extern "js" fn onRequestUpgrade(self, controller: DispatchController, statusCode: f64, headers: IncomingHttpHeaders, socket: Duplex);
    extern "js" fn onResponseStarted(self);
    extern "js" fn onHeaders(self, statusCode: f64, headers: JsArray<Buffer>, resume: fn() -> (), statusText: String) -> bool;
    extern "js" fn onResponseError(self, controller: DispatchController, error: JsValue);
    extern "js" fn onData(self, chunk: Buffer) -> bool;
    extern "js" fn onUpgrade(self, statusCode: f64, headers: JsValue, socket: Duplex);
}

impl DispatchOptions {
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;
}

impl Dispatcher {
    // merged from 2 overloads
    extern "js" fn upgrade(self, options: UpgradeOptions, callback: Option<fn(Option<JsValue>, UpgradeData) -> ()>);
    // merged from 4 overloads
    extern "js" fn addListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn listeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // merged from 4 overloads
    extern "js" fn destroy(self, err: Option<JsValue>, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ConnectData<TOpaque>) -> ()>);
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    // merged from 4 overloads
    extern "js" fn removeListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn prependListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    extern "js" fn pipeline(self, options: PipelineOptions<TOpaque>, handler: fn(PipelineHandlerData<TOpaque>) -> Readable) -> Duplex;
    // merged from 4 overloads
    extern "js" fn on(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn rawListeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // merged from 4 overloads
    extern "js" fn once(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn off(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 2 overloads
    extern "js" fn request(self, options: RequestOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ResponseData<TOpaque>) -> ()>);
    // merged from 2 overloads
    extern "js" fn stream(self, options: RequestOptions<TOpaque>, factory: fn(StreamFactoryData<TOpaque>) -> Writable, callback: Option<fn(Option<JsValue>, StreamData<TOpaque>) -> ()>);
    // merged from 2 overloads
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn compose(self, dispatchers: JsArray<fn(JsValue) -> JsValue>) -> ComposedDispatcher;
    // merged from 4 overloads
    extern "js" fn prependOnceListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn emit(self, eventName: String, origin: URL, targets: Option<JsArray<Dispatcher>>, error: Option<UndiciError>) -> bool;
}

impl DisposableTempDir {
    #[getter]
    #[setter]
    extern "js" path: String;

    extern "js" fn remove(self) -> JsPromise<()>;
}

impl Domain {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" version: String;

    // property getter
    extern "js" fn members(self) -> JsArray<JsValue>;
    // property setter
    extern "js" fn set_members(self, value: JsArray<JsValue>);
    extern "js" fn add(self, emitter: JsValue);
    extern "js" fn bind(self, callback: T) -> T;
    extern "js" fn remove(self, emitter: JsValue);
    extern "js" fn enter(self);
    extern "js" fn exit(self);
    extern "js" fn intercept(self, callback: T) -> T;
    extern "js" fn run(self, fn_: fn(JsArray<JsValue>) -> T, args: JsArray<JsValue>) -> T;
}

impl DropArgument {
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
}

impl Duplex {
    // merged from 12 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // property getter
    extern "js" fn allowHalfOpen(self) -> bool;
    // merged from 12 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // merged from 12 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Duplex;
    extern "js" fn toWeb(streamDuplex: Duplex) -> JsValue;
    extern "js" fn new_(opts: Option<DuplexOptions>) -> Duplex;
    extern "js" fn fromWeb(duplexStream: JsValue, options: Option<DuplexOptions>) -> Duplex;
    // property setter
    extern "js" fn set_allowHalfOpen(self, value: bool);
    // merged from 12 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // merged from 12 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Duplex;
    extern "js" fn from(src: JsValue) -> Duplex;
    // merged from 12 overloads
    extern "js" fn emit(self, event: String, chunk: Option<JsValue>) -> bool;
    // merged from 12 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Duplex;
    // inherited from Readable
    extern "js" fn _read(self, size: f64);
    // inherited from Readable
    extern "js" fn isDisturbed(stream: JsValue) -> bool;
    // inherited from Readable
    extern "js" fn asIndexedPairs(self, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn take(self, limit: f64, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    // inherited from Readable
    extern "js" fn find(self, fn_: fn(JsValue, JsValue) -> bool, options: Option<ArrayOptions>) -> JsPromise<Option<T>>;
    // inherited from Readable
    extern "js" fn pause(self) -> Readable;
    // inherited from Readable
    extern "js" fn wrap(self, stream: ReadableStream) -> Readable;
    // inherited from Readable
    extern "js" fn readableObjectMode(self) -> bool;
    // inherited from Readable
    extern "js" fn map(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<JsValue>);
    // inherited from Readable
    extern "js" fn errored(self) -> Option<JsValue>;
    // inherited from Readable
    extern "js" fn every(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    // inherited from Readable
    extern "js" fn closed(self) -> bool;
    // inherited from Readable
    extern "js" fn readableEnded(self) -> bool;
    // inherited from Readable
    extern "js" fn destroyed(self) -> bool;
    // inherited from Readable
    extern "js" fn forEach(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<()>;
    // inherited from Readable
    extern "js" fn toArray(self, options: Option<JsValue>) -> JsPromise<JsArray<JsValue>>;
    // inherited from Readable
    extern "js" fn flatMap(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn drop(self, limit: f64, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn push(self, chunk: JsValue, encoding: Option<JsValue>) -> bool;
    // inherited from Readable
    extern "js" fn filter(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn iterator(self, options: Option<JsValue>) -> AsyncIterator<JsValue>;
    // inherited from Readable
    extern "js" fn readableAborted(self) -> bool;
    // inherited from Readable
    extern "js" fn reduce(self, fn_: fn(JsValue, JsValue, JsValue) -> T, initial: Option<()>, options: Option<JsValue>) -> JsPromise<T>;
    // inherited from Readable
    extern "js" fn readableDidRead(self) -> bool;
    // inherited from Readable
    extern "js" fn isPaused(self) -> bool;
    // inherited from Readable
    extern "js" fn readable(self) -> bool;
    // inherited from Readable
    extern "js" fn resume(self) -> Readable;
    // inherited from Readable
    extern "js" fn some(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    // inherited from Readable
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> Readable;
    // inherited from Readable
    extern "js" fn readableLength(self) -> f64;
    // inherited from Readable
    extern "js" fn readableEncoding(self) -> Option<JsValue>;
    // inherited from Readable
    extern "js" fn readableFlowing(self) -> Option<bool>;
    // inherited from Readable
    extern "js" fn readableHighWaterMark(self) -> f64;
    // inherited from Readable
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    // inherited from Readable
    extern "js" fn set_destroyed(self, value: bool);
    // inherited from Readable
    extern "js" fn set_readable(self, value: bool);
    // inherited from Readable
    extern "js" fn setEncoding(self, encoding: JsValue) -> Readable;
    // inherited from Readable
    extern "js" fn destroy(self, error: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    // inherited from Writable
    extern "js" fn writableFinished(self) -> bool;
    // inherited from Writable
    extern "js" fn writableCorked(self) -> f64;
    // inherited from Writable
    extern "js" fn cork(self);
    // inherited from Writable
    extern "js" fn writable(self) -> bool;
    // inherited from Writable
    extern "js" fn writableNeedDrain(self) -> bool;
    // inherited from Writable
    extern "js" fn end(self, chunk: JsValue, encoding: Option<JsValue>, cb: Option<fn() -> ()>) -> Writable;
    // inherited from Writable
    extern "js" fn setDefaultEncoding(self, encoding: JsValue) -> Writable;
    // inherited from Writable
    extern "js" fn _final(self, callback: fn(Option<JsValue>) -> ());
    // inherited from Writable
    extern "js" fn write(self, chunk: JsValue, encoding: JsValue, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // inherited from Writable
    extern "js" fn writableLength(self) -> f64;
    // inherited from Writable
    extern "js" fn writableEnded(self) -> bool;
    // inherited from Writable
    extern "js" fn _writev(self, chunks: JsArray<JsValue>, callback: fn(Option<JsValue>) -> ());
    // inherited from Writable
    extern "js" fn uncork(self);
    // inherited from Writable
    extern "js" fn writableHighWaterMark(self) -> f64;
    // inherited from Writable
    extern "js" fn writableAborted(self) -> bool;
    // inherited from Writable
    extern "js" fn writableObjectMode(self) -> bool;
    // inherited from Writable
    extern "js" fn _write(self, chunk: JsValue, encoding: JsValue, callback: fn(Option<JsValue>) -> ());
}

impl DuplexOptions {
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableCorked: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" read: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" decodeStrings: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultEncoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" write: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" writev: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" final: Option<Option<JsFn>>;
}

impl ECDH {
    // merged from 2 overloads
    extern "js" fn generateKeys(self, encoding: Option<String>, format: Option<String>) -> String;
    // merged from 4 overloads
    extern "js" fn computeSecret(self, otherPublicKey: String, inputEncoding: Option<String>, outputEncoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getPrivateKey(self, encoding: Option<String>) -> String;
    extern "js" fn convertKey(key: JsValue, curve: String, inputEncoding: Option<String>, outputEncoding: Option<String>, format: Option<String>) -> JsValue;
    // merged from 2 overloads
    extern "js" fn getPublicKey(self, encoding: Option<()>, format: Option<String>) -> JsValue;
    // merged from 2 overloads
    extern "js" fn setPrivateKey(self, privateKey: String, encoding: Option<String>);
    extern "js" fn new_() -> ECDH;
}

impl ECKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" paramEncoding: Option<JsValue>;
}

impl ECKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" paramEncoding: Option<JsValue>;
}

impl ED25519KeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl ED448KeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl EcKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl EcKeyGenParams {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl EcKeyImportParams {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl EcdhKeyDeriveParams {
    #[getter]
    #[setter]
    extern "js" public_: CryptoKey;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl EcdsaParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl EmitWarningOptions {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" code: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ctor: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" detail: Option<Option<String>>;
}

impl EnableCompileCacheResult {
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" message: Option<String>;
    #[getter]
    #[setter]
    extern "js" directory: Option<String>;
}

impl EnableParameterType {
    #[getter]
    #[setter]
    extern "js" waitForDebuggerOnStart: bool;
}

impl EnableReturnType {
    #[getter]
    #[setter]
    extern "js" debuggerId: String;
}

impl EncapsulatedBits {
    #[getter]
    #[setter]
    extern "js" sharedKey: JsValue;
    #[getter]
    #[setter]
    extern "js" ciphertext: JsValue;
}

impl EncapsulatedKey {
    #[getter]
    #[setter]
    extern "js" sharedKey: CryptoKey;
    #[getter]
    #[setter]
    extern "js" ciphertext: JsValue;
}

impl EncodeIntoResult {
    #[getter]
    #[setter]
    extern "js" read: f64;
    #[getter]
    #[setter]
    extern "js" written: f64;
}

impl EntryPreview {
    #[getter]
    #[setter]
    extern "js" key: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" value: ObjectPreview;
}

impl EnvHttpProxyAgent {
    extern "js" fn new_(opts: Option<Options>) -> EnvHttpProxyAgent;
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
}

impl EphemeralKeyInfo {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" size: f64;
}

impl ErrnoException {
    #[getter]
    #[setter]
    extern "js" errno: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" code: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" syscall: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cause: JsValue;
}

impl Error {
    #[getter]
    #[setter]
    extern "js" cause: JsValue;
}

impl ErrorConstructor {
    #[getter]
    #[setter]
    extern "js" stackTraceLimit: f64;

    extern "js" fn captureStackTrace(self, targetObject: JsValue, constructorOpt: Option<JsFn>);
    extern "js" fn prepareStackTrace(self, err: JsValue, stackTraces: JsArray<CallSite>) -> JsValue;
}

impl ErrorEvent {
    #[getter]
    extern "js" message: String;
    #[getter]
    extern "js" filename: String;
    #[getter]
    extern "js" lineno: f64;
    #[getter]
    extern "js" colno: f64;
    #[getter]
    extern "js" error: JsValue;
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;

    // inherited from Event
    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    // inherited from Event
    extern "js" fn stopPropagation(self);
    // inherited from Event
    extern "js" fn composedPath(self) -> (EventTarget);
    // inherited from Event
    extern "js" fn stopImmediatePropagation(self);
    // inherited from Event
    extern "js" fn preventDefault(self);
}

impl ErrorEventInit {
    #[getter]
    #[setter]
    extern "js" message: Option<String>;
    #[getter]
    #[setter]
    extern "js" filename: Option<String>;
    #[getter]
    #[setter]
    extern "js" lineno: Option<f64>;
    #[getter]
    #[setter]
    extern "js" colno: Option<f64>;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl EvaluateOnCallFrameParameterType {
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" throwOnSideEffect: Option<Option<bool>>;
}

impl EvaluateOnCallFrameReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl EvaluateParameterType {
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" contextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" userGesture: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
}

impl EvaluateReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl Event {
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;

    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    extern "js" fn stopPropagation(self);
    extern "js" fn composedPath(self) -> (EventTarget);
    extern "js" fn stopImmediatePropagation(self);
    extern "js" fn preventDefault(self);
}

impl EventEmitter {
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn getMaxListeners(self) -> f64;
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl EventEmitterAsyncResource {
    extern "js" fn new_(options: Option<EventEmitterAsyncResourceOptions>) -> EventEmitterAsyncResource;
    // property (readonly)
    extern "js" fn asyncId(self) -> f64;
    extern "js" fn emitDestroy(self);
    // property (readonly)
    extern "js" fn triggerAsyncId(self) -> f64;
    // property (readonly)
    extern "js" fn asyncResource(self) -> EventEmitterReferencingAsyncResource;
}

impl EventEmitterAsyncResourceOptions {
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" triggerAsyncId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" requireManualDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" captureRejections: Option<Option<bool>>;
}

impl EventEmitterOptions {
    #[getter]
    #[setter]
    extern "js" captureRejections: Option<Option<bool>>;
}

impl EventEmitterReferencingAsyncResource {
    #[getter]
    extern "js" eventEmitter: EventEmitterAsyncResource;

    // inherited from AsyncResource
    extern "js" fn new_(type_: String, triggerAsyncId: Option<JsValue>) -> AsyncResource;
    // inherited from AsyncResource
    extern "js" fn triggerAsyncId(self) -> f64;
    // inherited from AsyncResource
    extern "js" fn runInAsyncScope(self, fn_: JsFn, thisArg: Option<This>, args: JsArray<JsValue>) -> Result;
    // inherited from AsyncResource
    extern "js" fn asyncId(self) -> f64;
    // inherited from AsyncResource
    extern "js" fn bind(fn_: Func, type_: Option<String>, thisArg: Option<ThisArg>) -> Func;
    // inherited from AsyncResource
    extern "js" fn emitDestroy(self) -> AsyncResource;
}

impl EventInit {
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl EventListenerObject {
    extern "js" fn handleEvent(self, object: Event);
}

impl EventListenerOptions {
    #[getter]
    #[setter]
    extern "js" capture: Option<bool>;
    #[getter]
    #[setter]
    extern "js" capture: Option<bool>;
}

impl EventLoopMonitorOptions {
    #[getter]
    #[setter]
    extern "js" resolution: Option<Option<f64>>;
}

impl EventLoopUtilization {
    #[getter]
    #[setter]
    extern "js" idle: f64;
    #[getter]
    #[setter]
    extern "js" active: f64;
    #[getter]
    #[setter]
    extern "js" utilization: f64;
}

impl EventSource {
    #[getter]
    extern "js" CLOSED: f64;
    #[getter]
    extern "js" CONNECTING: f64;
    #[getter]
    extern "js" OPEN: f64;
    #[getter]
    #[setter]
    extern "js" onerror: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onmessage: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onopen: Option<JsFn>;
    #[getter]
    extern "js" readyState: f64;
    #[getter]
    extern "js" url: String;
    #[getter]
    extern "js" withCredentials: bool;

    extern "js" fn close(self);
    // merged from 2 overloads
    extern "js" fn addEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    // merged from 2 overloads
    extern "js" fn removeEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    // inherited from EventTarget
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
}

impl EventSourceEventMap {
    #[getter]
    #[setter]
    extern "js" error: ErrorEvent;
    #[getter]
    #[setter]
    extern "js" message: MessageEvent;
    #[getter]
    #[setter]
    extern "js" open: Event;
}

impl EventSourceInit {
    #[getter]
    #[setter]
    extern "js" withCredentials: Option<bool>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" node: Option<JsValue>;
}

impl EventTarget {
    extern "js" fn addEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
    extern "js" fn removeEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
}

impl ExceptionDetails {
    #[getter]
    #[setter]
    extern "js" exceptionId: f64;
    #[getter]
    #[setter]
    extern "js" text: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
    #[getter]
    #[setter]
    extern "js" scriptId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" exception: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl ExceptionRevokedEventDataType {
    #[getter]
    #[setter]
    extern "js" reason: String;
    #[getter]
    #[setter]
    extern "js" exceptionId: f64;
}

impl ExceptionThrownEventDataType {
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: ExceptionDetails;
}

impl ExecException {
    #[getter]
    #[setter]
    extern "js" cmd: Option<String>;
    #[getter]
    #[setter]
    extern "js" killed: Option<bool>;
    #[getter]
    #[setter]
    extern "js" code: Option<f64>;
    #[getter]
    #[setter]
    extern "js" signal: Option<String>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<String>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<String>;
    #[getter]
    #[setter]
    extern "js" cause: JsValue;
}

impl ExecFileOptions {
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileOptionsWithOtherEncoding {
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileSyncOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecFileSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<String>;
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecSyncOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ExecutionContextCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" context: ExecutionContextDescription;
}

impl ExecutionContextDescription {
    #[getter]
    #[setter]
    extern "js" id: f64;
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" auxData: Option<Option<JsValue>>;
}

impl ExecutionContextDestroyedEventDataType {
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
}

impl FSImplementation {
    // function property
    extern "js" fn open(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
    // function property
    extern "js" fn close(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
}

impl FSWatcher {
    // merged from 4 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    extern "js" fn close(self);
    extern "js" fn unref(self) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    extern "js" fn ref_(self) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl File {
    // property (readonly)
    extern "js" fn lastModified(self) -> f64;
    // property (readonly)
    extern "js" fn name(self) -> String;
    extern "js" fn new_(sources: JsArray<JsValue>, fileName: String, options: Option<FileOptions>) -> File;
}

impl FileChangeInfo {
    #[getter]
    #[setter]
    extern "js" eventType: JsValue;
    #[getter]
    #[setter]
    extern "js" filename: Option<JsValue>;
}

impl FileHandle {
    #[getter]
    extern "js" fd: f64;

    extern "js" fn writeFile(self, data: JsValue, options: Option<JsValue>) -> JsPromise<()>;
    // merged from 3 overloads
    extern "js" fn write(self, buffer: JsValue, offset: Option<Option<f64>>, length: Option<Option<f64>>, position: Option<Option<f64>>) -> JsPromise<JsValue>;
    extern "js" fn appendFile(self, data: JsValue, options: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn createWriteStream(self, options: Option<CreateWriteStreamOptions>) -> WriteStream;
    extern "js" fn truncate(self, len: Option<f64>) -> JsPromise<()>;
    extern "js" fn chmod(self, mode: JsValue) -> JsPromise<()>;
    extern "js" fn writev(self, buffers: JsValue, position: Option<f64>) -> JsPromise<JsValue>;
    extern "js" fn readv(self, buffers: JsValue, position: Option<f64>) -> JsPromise<JsValue>;
    extern "js" fn readLines(self, options: Option<CreateReadStreamOptions>) -> JsValue;
    extern "js" fn close(self) -> JsPromise<()>;
    // merged from 3 overloads
    extern "js" fn readFile(self, options: Option<Option<Abortable>>) -> JsPromise<JsValue>;
    extern "js" fn sync(self) -> JsPromise<()>;
    extern "js" fn utimes(self, atime: JsValue, mtime: JsValue) -> JsPromise<()>;
    // merged from 3 overloads
    extern "js" fn read(self, buffer: JsValue, offset: Option<Option<f64>>, length: Option<Option<f64>>, position: Option<Option<JsValue>>) -> JsPromise<JsValue>;
    extern "js" fn readableWebStream(self, options: Option<ReadableWebStreamOptions>) -> ReadableStream;
    // merged from 3 overloads
    extern "js" fn stat(self, opts: Option<StatOptions>) -> JsPromise<Stats>;
    extern "js" fn chown(self, uid: f64, gid: f64) -> JsPromise<()>;
    extern "js" fn datasync(self) -> JsPromise<()>;
    extern "js" fn createReadStream(self, options: Option<CreateReadStreamOptions>) -> ReadStream;
}

impl FileOptions {
    #[getter]
    #[setter]
    extern "js" endings: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
    #[getter]
    #[setter]
    extern "js" lastModified: Option<f64>;
}

impl FileReadOptions {
    #[getter]
    #[setter]
    extern "js" buffer: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl FileReadResult {
    #[getter]
    #[setter]
    extern "js" bytesRead: f64;
    #[getter]
    #[setter]
    extern "js" buffer: JsValue;
}

impl FileUrlToPathOptions {
    #[getter]
    #[setter]
    extern "js" windows: Option<Option<bool>>;
}

impl FilterCallsObjectCriteria {
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hash: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" fullUrl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hash: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" fullUrl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
}

impl FilterCallsOptions {
    #[getter]
    #[setter]
    extern "js" operator: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" operator: Option<JsValue>;
}

impl FinalizeBindingsOptions {
    #[getter]
    #[setter]
    extern "js" memory: Option<Option<JsValue>>;
}

impl FinishedOptions {
    #[getter]
    #[setter]
    extern "js" error: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" cleanup: Option<Option<bool>>;
}

impl FlagAndOpenMode {
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" flag: Option<Option<JsValue>>;
}

impl ForkOptions {
    #[getter]
    #[setter]
    extern "js" execPath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl FormData {
    extern "js" fn append(self, name: String, value: JsValue, fileName: Option<String>);
    // property getter
    extern "js" fn keys(self) -> fn() -> SpecIterableIterator<String>;
    // property getter
    extern "js" fn values(self) -> fn() -> SpecIterableIterator<JsValue>;
    // property getter
    extern "js" fn entries(self) -> fn() -> SpecIterableIterator<(String, JsValue)>;
    extern "js" fn delete(self, name: String);
    extern "js" fn has(self, name: String) -> bool;
    extern "js" fn get(self, name: String) -> Option<JsValue>;
    // property setter
    extern "js" fn set_entries(self, value: fn() -> SpecIterableIterator<(String, JsValue)>);
    // property setter
    extern "js" fn set_values(self, value: fn() -> SpecIterableIterator<JsValue>);
    // property getter
    extern "js" fn forEach(self) -> fn(fn(JsValue, String, FormData) -> (), JsValue) -> ();
    extern "js" fn set(self, name: String, value: JsValue, fileName: Option<String>);
    extern "js" fn getAll(self, name: String) -> JsArray<JsValue>;
    // property setter
    extern "js" fn set_keys(self, value: fn() -> SpecIterableIterator<String>);
    // property setter
    extern "js" fn set_forEach(self, value: fn(fn(JsValue, String, FormData) -> (), JsValue) -> ());
}

impl FormatInputPathObject {
    #[getter]
    #[setter]
    extern "js" root: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" dir: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" base: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl FunctionCoverage {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" ranges: JsArray<CoverageRange>;
    #[getter]
    #[setter]
    extern "js" isBlockCoverage: bool;
}

impl FunctionOptions {
    #[getter]
    #[setter]
    extern "js" deterministic: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" directOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useBigIntArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" varargs: Option<Option<bool>>;
}

impl GCOptions {
    #[getter]
    #[setter]
    extern "js" execution: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" flavor: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
}

impl GCProfiler {
    extern "js" fn stop(self) -> GCProfilerResult;
    extern "js" fn start(self);
}

impl GCProfilerResult {
    #[getter]
    #[setter]
    extern "js" version: f64;
    #[getter]
    #[setter]
    extern "js" startTime: f64;
    #[getter]
    #[setter]
    extern "js" endTime: f64;
    #[getter]
    #[setter]
    extern "js" statistics: JsArray<JsValue>;
}

impl GeneratePrimeOptions {
    #[getter]
    #[setter]
    extern "js" add: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" rem: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" safe: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl GeneratePrimeOptionsArrayBuffer {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" add: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" rem: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" safe: Option<Option<bool>>;
}

impl GeneratePrimeOptionsBigInt {
    #[getter]
    #[setter]
    extern "js" bigint: bool;
    #[getter]
    #[setter]
    extern "js" add: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" rem: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" safe: Option<Option<bool>>;
}

impl GetBestEffortCoverageReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<ScriptCoverage>;
}

impl GetCallSitesOptions {
    #[getter]
    #[setter]
    extern "js" sourceMap: Option<Option<bool>>;
}

impl GetCategoriesReturnType {
    #[getter]
    #[setter]
    extern "js" categories: JsArray<String>;
}

impl GetDomainsReturnType {
    #[getter]
    #[setter]
    extern "js" domains: JsArray<Domain>;
}

impl GetHeapObjectIdParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
}

impl GetHeapObjectIdReturnType {
    #[getter]
    #[setter]
    extern "js" heapSnapshotObjectId: String;
}

impl GetObjectByHeapObjectIdParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
}

impl GetObjectByHeapObjectIdReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
}

impl GetPossibleBreakpointsParameterType {
    #[getter]
    #[setter]
    extern "js" start: Location;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" restrictToFunction: Option<Option<bool>>;
}

impl GetPossibleBreakpointsReturnType {
    #[getter]
    #[setter]
    extern "js" locations: JsArray<BreakLocation>;
}

impl GetPropertiesParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
    #[getter]
    #[setter]
    extern "js" ownProperties: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" accessorPropertiesOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
}

impl GetPropertiesReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<PropertyDescriptor>;
    #[getter]
    #[setter]
    extern "js" internalProperties: Option<Option<JsArray<InternalPropertyDescriptor>>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl GetRequestPostDataParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl GetRequestPostDataReturnType {
    #[getter]
    #[setter]
    extern "js" postData: String;
}

impl GetResponseBodyParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl GetResponseBodyReturnType {
    #[getter]
    #[setter]
    extern "js" body: String;
    #[getter]
    #[setter]
    extern "js" base64Encoded: bool;
}

impl GetSamplingProfileReturnType {
    #[getter]
    #[setter]
    extern "js" profile: SamplingHeapProfile;
}

impl GetScriptSourceParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
}

impl GetScriptSourceReturnType {
    #[getter]
    #[setter]
    extern "js" scriptSource: String;
}

impl GetStackTraceParameterType {
    #[getter]
    #[setter]
    extern "js" stackTraceId: StackTraceId;
}

impl GetStackTraceReturnType {
    #[getter]
    #[setter]
    extern "js" stackTrace: StackTrace;
}

impl GlobOptions {
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" withFileTypes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exclude: Option<JsValue>;
}

impl GlobOptionsWithFileTypes {
    #[getter]
    #[setter]
    extern "js" withFileTypes: bool;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" exclude: Option<JsValue>;
}

impl GlobOptionsWithoutFileTypes {
    #[getter]
    #[setter]
    extern "js" withFileTypes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" exclude: Option<JsValue>;
}

impl GlobalLexicalScopeNamesParameterType {
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl GlobalLexicalScopeNamesReturnType {
    #[getter]
    #[setter]
    extern "js" names: JsArray<String>;
}

impl Gunzip {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl Gzip {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl H2CClient {
    // property setter
    extern "js" fn set_pipelining(self, value: f64);
    extern "js" fn new_(url: JsValue, options: Option<Options>) -> H2CClient;
    // property getter
    extern "js" fn closed(self) -> bool;
    // property getter
    extern "js" fn pipelining(self) -> f64;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property setter
    extern "js" fn set_closed(self, value: bool);
}

impl HRTime {
    extern "js" fn bigint(self) -> i64;
}

impl HTTP2ServerCommon {
    extern "js" fn setTimeout(self, msec: Option<f64>, callback: Option<fn() -> ()>) -> HTTP2ServerCommon;
    extern "js" fn updateSettings(self, settings: Settings);
}

impl HTTPParserError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
}

impl Hash {
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Hash;
    // merged from 2 overloads
    extern "js" fn digest(self, encoding: Option<String>) -> String;
    extern "js" fn new_() -> Hash;
    extern "js" fn copy(self, options: Option<HashOptions>) -> Hash;
}

impl HashOptions {
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl Headers {
    // property (readonly)
    extern "js" fn delete(self) -> fn(String) -> ();
    extern "js" fn new_(init: Option<JsValue>) -> Headers;
    // property (readonly)
    extern "js" fn forEach(self) -> fn(fn(String, String, Headers) -> (), JsValue) -> ();
    // property (readonly)
    extern "js" fn has(self) -> fn(String) -> bool;
    // property (readonly)
    extern "js" fn get(self) -> fn(String) -> Option<String>;
    // property (readonly)
    extern "js" fn keys(self) -> fn() -> SpecIterableIterator<String>;
    // property (readonly)
    extern "js" fn values(self) -> fn() -> SpecIterableIterator<String>;
    // property (readonly)
    extern "js" fn append(self) -> fn(String, String) -> ();
    // property (readonly)
    extern "js" fn entries(self) -> fn() -> SpecIterableIterator<(String, String)>;
    // property (readonly)
    extern "js" fn getSetCookie(self) -> fn() -> JsArray<String>;
    // property (readonly)
    extern "js" fn set(self) -> fn(String, String) -> ();
}

impl HeadersOverflowError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl HeadersTimeoutError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
}

impl HeapCodeStatistics {
    #[getter]
    #[setter]
    extern "js" code_and_metadata_size: f64;
    #[getter]
    #[setter]
    extern "js" bytecode_and_metadata_size: f64;
    #[getter]
    #[setter]
    extern "js" external_script_source_size: f64;
}

impl HeapInfo {
    #[getter]
    #[setter]
    extern "js" total_heap_size: f64;
    #[getter]
    #[setter]
    extern "js" total_heap_size_executable: f64;
    #[getter]
    #[setter]
    extern "js" total_physical_size: f64;
    #[getter]
    #[setter]
    extern "js" total_available_size: f64;
    #[getter]
    #[setter]
    extern "js" used_heap_size: f64;
    #[getter]
    #[setter]
    extern "js" heap_size_limit: f64;
    #[getter]
    #[setter]
    extern "js" malloced_memory: f64;
    #[getter]
    #[setter]
    extern "js" peak_malloced_memory: f64;
    #[getter]
    #[setter]
    extern "js" does_zap_garbage: f64;
    #[getter]
    #[setter]
    extern "js" number_of_native_contexts: f64;
    #[getter]
    #[setter]
    extern "js" number_of_detached_contexts: f64;
    #[getter]
    #[setter]
    extern "js" total_global_handles_size: f64;
    #[getter]
    #[setter]
    extern "js" used_global_handles_size: f64;
    #[getter]
    #[setter]
    extern "js" external_memory: f64;
}

impl HeapProfileHandle {
    extern "js" fn stop(self) -> JsPromise<String>;
}

impl HeapSnapshotOptions {
    #[getter]
    #[setter]
    extern "js" exposeInternals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exposeNumericValues: Option<Option<bool>>;
}

impl HeapSpaceInfo {
    #[getter]
    #[setter]
    extern "js" space_name: String;
    #[getter]
    #[setter]
    extern "js" space_size: f64;
    #[getter]
    #[setter]
    extern "js" space_used_size: f64;
    #[getter]
    #[setter]
    extern "js" space_available_size: f64;
    #[getter]
    #[setter]
    extern "js" physical_space_size: f64;
}

impl HeapSpaceStatistics {
    #[getter]
    #[setter]
    extern "js" spaceName: String;
    #[getter]
    #[setter]
    extern "js" spaceSize: f64;
    #[getter]
    #[setter]
    extern "js" spaceUsedSize: f64;
    #[getter]
    #[setter]
    extern "js" spaceAvailableSize: f64;
    #[getter]
    #[setter]
    extern "js" physicalSpaceSize: f64;
}

impl HeapStatistics {
    #[getter]
    #[setter]
    extern "js" totalHeapSize: f64;
    #[getter]
    #[setter]
    extern "js" totalHeapSizeExecutable: f64;
    #[getter]
    #[setter]
    extern "js" totalPhysicalSize: f64;
    #[getter]
    #[setter]
    extern "js" totalAvailableSize: f64;
    #[getter]
    #[setter]
    extern "js" totalGlobalHandlesSize: f64;
    #[getter]
    #[setter]
    extern "js" usedGlobalHandlesSize: f64;
    #[getter]
    #[setter]
    extern "js" usedHeapSize: f64;
    #[getter]
    #[setter]
    extern "js" heapSizeLimit: f64;
    #[getter]
    #[setter]
    extern "js" mallocedMemory: f64;
    #[getter]
    #[setter]
    extern "js" externalMemory: f64;
    #[getter]
    #[setter]
    extern "js" peakMallocedMemory: f64;
}

impl HeapStatsUpdateEventDataType {
    #[getter]
    #[setter]
    extern "js" statsUpdate: JsArray<f64>;
}

impl Histogram {
    #[getter]
    extern "js" count: f64;
    #[getter]
    extern "js" countBigInt: i64;
    #[getter]
    extern "js" exceeds: f64;
    #[getter]
    extern "js" exceedsBigInt: i64;
    #[getter]
    extern "js" max: f64;
    #[getter]
    extern "js" maxBigInt: f64;
    #[getter]
    extern "js" mean: f64;
    #[getter]
    extern "js" min: f64;
    #[getter]
    extern "js" minBigInt: i64;
    #[getter]
    extern "js" percentiles: JsValue;
    #[getter]
    extern "js" percentilesBigInt: JsValue;
    #[getter]
    extern "js" stddev: f64;

    extern "js" fn reset(self);
    extern "js" fn percentile(self, percentile: f64) -> f64;
    extern "js" fn percentileBigInt(self, percentile: f64) -> i64;
}

impl HkdfParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" info: JsValue;
    #[getter]
    #[setter]
    extern "js" salt: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl Hmac {
    // merged from 2 overloads
    extern "js" fn digest(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Hmac;
    extern "js" fn new_() -> Hmac;
}

impl HmacImportParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl HmacKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" hash: KeyAlgorithm;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl HmacKeyGenParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl HookCallbacks {
    #[getter]
    #[setter]
    extern "js" init: Option<Init>;
    #[getter]
    #[setter]
    extern "js" before: Option<Before>;
    #[getter]
    #[setter]
    extern "js" after: Option<After>;
    #[getter]
    #[setter]
    extern "js" settled: Option<Settled>;

    extern "js" fn after(self, asyncId: f64);
    extern "js" fn destroy(self, asyncId: f64);
    extern "js" fn before(self, asyncId: f64);
    extern "js" fn promiseResolve(self, asyncId: f64);
    extern "js" fn init(self, asyncId: f64, type_: String, triggerAsyncId: f64, resource: JsValue);
}

impl HookOptions {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl Http2SecureServer {
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, stream: Option<ServerHttp2Stream>, headers: Option<IncomingHttpHeaders>, flags: Option<f64>) -> bool;
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // inherited from HTTP2ServerCommon
    extern "js" fn setTimeout(self, msec: Option<f64>, callback: Option<fn() -> ()>) -> HTTP2ServerCommon;
    // inherited from HTTP2ServerCommon
    extern "js" fn updateSettings(self, settings: Settings);
}

impl Http2Server {
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, stream: Option<ServerHttp2Stream>, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // inherited from HTTP2ServerCommon
    extern "js" fn setTimeout(self, msec: Option<f64>, callback: Option<fn() -> ()>) -> HTTP2ServerCommon;
    // inherited from HTTP2ServerCommon
    extern "js" fn updateSettings(self, settings: Settings);
}

impl Http2ServerRequest {
    // property (readonly)
    extern "js" fn httpVersionMajor(self) -> f64;
    // property (readonly)
    extern "js" fn httpVersion(self) -> String;
    // property (readonly)
    extern "js" fn complete(self) -> bool;
    // property (readonly)
    extern "js" fn rawTrailers(self) -> JsArray<String>;
    // property (readonly)
    extern "js" fn method(self) -> String;
    // property (readonly)
    extern "js" fn socket(self) -> JsValue;
    // property (readonly)
    extern "js" fn trailers(self) -> IncomingHttpHeaders;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    extern "js" fn new_(stream: ServerHttp2Stream, headers: IncomingHttpHeaders, options: ReadableOptions, rawHeaders: JsArray<String>) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn scheme(self) -> String;
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    // property (readonly)
    extern "js" fn connection(self) -> JsValue;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn httpVersionMinor(self) -> f64;
    // property (readonly)
    extern "js" fn authority(self) -> String;
    // property (readonly)
    extern "js" fn aborted(self) -> bool;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn headers(self) -> IncomingHttpHeaders;
    // property (readonly)
    extern "js" fn rawHeaders(self) -> JsArray<String>;
    // property getter
    extern "js" fn url(self) -> String;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn stream(self) -> ServerHttp2Stream;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, hadError: Option<bool>, code: Option<f64>) -> bool;
    // property setter
    extern "js" fn set_url(self, value: String);
}

impl Http2ServerResponse {
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    extern "js" fn getHeader(self, name: String) -> String;
    extern "js" fn writeEarlyHints(self, hints: JsValue);
    // property (readonly)
    extern "js" fn req(self) -> JsValue;
    // property setter
    extern "js" fn set_sendDate(self, value: bool);
    extern "js" fn setHeader(self, name: String, value: JsValue);
    // property (readonly)
    extern "js" fn connection(self) -> JsValue;
    // property (readonly)
    extern "js" fn headersSent(self) -> bool;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // property (readonly)
    extern "js" fn finished(self) -> bool;
    // property (readonly)
    extern "js" fn socket(self) -> JsValue;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    extern "js" fn getHeaders(self) -> OutgoingHttpHeaders;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // property getter
    extern "js" fn statusCode(self) -> f64;
    extern "js" fn removeHeader(self, name: String);
    extern "js" fn createPushResponse(self, headers: OutgoingHttpHeaders, callback: fn(Option<JsValue>, Http2ServerResponse) -> ());
    extern "js" fn hasHeader(self, name: String) -> bool;
    // merged from 2 overloads
    extern "js" fn write(self, chunk: JsValue, encoding: JsValue, callback: Option<fn(JsValue) -> ()>) -> bool;
    extern "js" fn new_(stream: ServerHttp2Stream) -> Http2ServerResponse;
    // merged from 3 overloads
    extern "js" fn end(self, data: JsValue, encoding: Option<JsValue>, callback: Option<fn() -> ()>) -> Http2ServerResponse;
    // property getter
    extern "js" fn sendDate(self) -> bool;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    extern "js" fn appendHeader(self, name: String, value: JsValue);
    extern "js" fn getHeaderNames(self) -> JsArray<String>;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // merged from 2 overloads
    extern "js" fn writeHead(self, statusCode: f64, statusMessage: String, headers: Option<JsValue>) -> Http2ServerResponse;
    // property setter
    extern "js" fn set_statusMessage(self, value: String);
    extern "js" fn writeContinue(self);
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, error: Option<JsValue>) -> bool;
    // property (readonly)
    extern "js" fn stream(self) -> ServerHttp2Stream;
    // property getter
    extern "js" fn statusMessage(self) -> String;
    extern "js" fn addTrailers(self, trailers: OutgoingHttpHeaders);
}

impl Http2Session {
    #[getter]
    extern "js" alpnProtocol: Option<Option<String>>;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" connecting: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" encrypted: Option<Option<bool>>;
    #[getter]
    extern "js" localSettings: Settings;
    #[getter]
    extern "js" originSet: Option<Option<JsArray<String>>>;
    #[getter]
    extern "js" pendingSettingsAck: bool;
    #[getter]
    extern "js" remoteSettings: Settings;
    #[getter]
    extern "js" socket: JsValue;
    #[getter]
    extern "js" state: SessionState;
    #[getter]
    extern "js" type_: f64;

    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    extern "js" fn settings(self, settings: Settings, callback: Option<fn(Option<JsValue>, Settings, f64) -> ()>);
    extern "js" fn goaway(self, code: Option<f64>, lastStreamID: Option<f64>, opaqueData: Option<JsValue>);
    // merged from 9 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn setLocalWindowSize(self, windowSize: f64);
    // merged from 9 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2Session;
    // merged from 2 overloads
    extern "js" fn ping(self, payload: JsValue, callback: Option<fn(Option<JsValue>, f64, JsValue) -> ()>) -> bool;
    extern "js" fn unref(self);
    extern "js" fn ref_(self);
    // merged from 9 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn destroy(self, error: Option<JsValue>, code: Option<f64>);
    // merged from 9 overloads
    extern "js" fn emit(self, event: String, frameType: Option<f64>, errorCode: Option<f64>, streamID: Option<f64>) -> bool;
    // merged from 9 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // merged from 9 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl Http2Stream {
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    extern "js" bufferSize: f64;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" endAfterHeaders: bool;
    #[getter]
    extern "js" id: Option<Option<f64>>;
    #[getter]
    extern "js" pending: bool;
    #[getter]
    extern "js" rstCode: f64;
    #[getter]
    extern "js" sentHeaders: OutgoingHttpHeaders;
    #[getter]
    extern "js" sentInfoHeaders: Option<Option<JsArray<OutgoingHttpHeaders>>>;
    #[getter]
    extern "js" sentTrailers: Option<Option<OutgoingHttpHeaders>>;
    #[getter]
    extern "js" session: Option<Http2Session>;
    #[getter]
    extern "js" state: StreamState;

    extern "js" fn close(self, code: Option<f64>, callback: Option<fn() -> ()>);
    // merged from 15 overloads
    extern "js" fn emit(self, event: String, frameType: Option<f64>, errorCode: Option<f64>) -> bool;
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    extern "js" fn sendTrailers(self, headers: OutgoingHttpHeaders);
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    extern "js" fn priority(self, options: JsValue);
}

impl Immediate {
    extern "js" fn unref(self) -> Immediate;
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn ref_(self) -> Immediate;
    extern "js" fn _onImmediate(self, args: JsArray<JsValue>);
}

impl ImportAttributes {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl ImportMeta {
    #[getter]
    #[setter]
    extern "js" dirname: String;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" main: bool;

    extern "js" fn resolve(self, specifier: String, parent: Option<JsValue>) -> String;
}

impl IncomingHttpHeaders {
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" authority: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" scheme: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept_encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept_language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept_patch: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept_ranges: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_credentials: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_methods: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_expose_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_max_age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_request_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_request_method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" allow: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" alt_svc: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cache_control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" connection: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_disposition: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_length: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_type: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cookie: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" date: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" etag: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expect: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expires: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" forwarded: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" from: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_modified_since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_none_match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_unmodified_since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" last_modified: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pragma: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" proxy_authenticate: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" proxy_authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public_key_pins: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" retry_after: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_fetch_site: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_fetch_mode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_fetch_user: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_fetch_dest: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_extensions: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_key: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_version: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" set_cookie: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" strict_transport_security: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" tk: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" trailer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" transfer_encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" user_agent: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" vary: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" via: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" warning: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" www_authenticate: Option<Option<String>>;
}

impl IncomingHttpStatusHeader {
    #[getter]
    #[setter]
    extern "js" status: Option<Option<f64>>;
}

impl IncomingMessage {
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>) -> IncomingMessage;
    // property setter
    extern "js" fn set_headers(self, value: IncomingHttpHeaders);
    // property setter
    extern "js" fn set_method(self, value: Option<Option<String>>);
    // property setter
    extern "js" fn set_httpVersion(self, value: String);
    // property setter
    extern "js" fn set_socket(self, value: Socket);
    // property setter
    extern "js" fn set_rawTrailers(self, value: JsArray<String>);
    // property getter
    extern "js" fn httpVersionMajor(self) -> f64;
    // property setter
    extern "js" fn set_complete(self, value: bool);
    // property getter
    extern "js" fn method(self) -> Option<Option<String>>;
    // property setter
    extern "js" fn set_rawHeaders(self, value: JsArray<String>);
    // property getter
    extern "js" fn statusCode(self) -> Option<Option<f64>>;
    // property setter
    extern "js" fn set_headersDistinct(self, value: Dict<JsArray<String>>);
    // property setter
    extern "js" fn set_httpVersionMajor(self, value: f64);
    // property getter
    extern "js" fn trailersDistinct(self) -> Dict<JsArray<String>>;
    // property getter
    extern "js" fn statusMessage(self) -> Option<Option<String>>;
    extern "js" fn new_(socket: Socket) -> IncomingMessage;
    // property setter
    extern "js" fn set_trailers(self, value: Dict<String>);
    // property setter
    extern "js" fn set_connection(self, value: Socket);
    // property getter
    extern "js" fn rawHeaders(self) -> JsArray<String>;
    // property setter
    extern "js" fn set_trailersDistinct(self, value: Dict<JsArray<String>>);
    // property getter
    extern "js" fn connection(self) -> Socket;
    extern "js" fn destroy(self, error: Option<JsValue>) -> IncomingMessage;
    // property getter
    extern "js" fn socket(self) -> Socket;
    // property setter
    extern "js" fn set_url(self, value: Option<Option<String>>);
    // property getter
    extern "js" fn httpVersionMinor(self) -> f64;
    // property setter
    extern "js" fn set_httpVersionMinor(self, value: f64);
    // property getter
    extern "js" fn url(self) -> Option<Option<String>>;
    // property getter
    extern "js" fn headersDistinct(self) -> Dict<JsArray<String>>;
    // property getter
    extern "js" fn complete(self) -> bool;
    // property getter
    extern "js" fn headers(self) -> IncomingHttpHeaders;
    // property getter
    extern "js" fn trailers(self) -> Dict<String>;
    // property setter
    extern "js" fn set_statusCode(self, value: Option<Option<f64>>);
    // property setter
    extern "js" fn set_statusMessage(self, value: Option<Option<String>>);
    // property setter
    extern "js" fn set_aborted(self, value: bool);
    // property getter
    extern "js" fn aborted(self) -> bool;
    // property getter
    extern "js" fn rawTrailers(self) -> JsArray<String>;
    // property getter
    extern "js" fn httpVersion(self) -> String;
}

impl Inflate {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from ZlibReset
    extern "js" fn reset(self);
}

impl InflateRaw {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from ZlibReset
    extern "js" fn reset(self);
}

impl InformationEvent {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusMessage: String;
    #[getter]
    #[setter]
    extern "js" httpVersion: String;
    #[getter]
    #[setter]
    extern "js" httpVersionMajor: f64;
    #[getter]
    #[setter]
    extern "js" httpVersionMinor: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" rawHeaders: JsArray<String>;
}

impl InformationalError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl Initiator {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" stack: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" requestId: Option<Option<String>>;
}

impl InspectOptions {
    #[getter]
    #[setter]
    extern "js" showHidden: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" depth: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" colors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" customInspect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" showProxy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxArrayLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxStringLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" compact: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sorted: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" getters: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" numericSeparator: Option<Option<bool>>;
}

impl InspectOptionsStylized {
    #[getter]
    #[setter]
    extern "js" showHidden: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" depth: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" colors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" customInspect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" showProxy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxArrayLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxStringLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" compact: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sorted: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" getters: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" numericSeparator: Option<Option<bool>>;

    extern "js" fn stylize(self, text: String, styleType: String) -> String;
}

impl InspectRequestedEventDataType {
    #[getter]
    #[setter]
    extern "js" object: RemoteObject;
    #[getter]
    #[setter]
    extern "js" hints: JsValue;
}

impl InspectorConsole {
    extern "js" fn dirxml(self, data: JsArray<JsValue>);
    extern "js" fn assert(self, value: Option<JsValue>, data: JsArray<JsValue>);
    extern "js" fn warn(self, data: JsArray<JsValue>);
    extern "js" fn trace(self, data: JsArray<JsValue>);
    extern "js" fn groupCollapsed(self, data: JsArray<JsValue>);
    extern "js" fn debug(self, data: JsArray<JsValue>);
    extern "js" fn groupEnd(self, data: JsArray<JsValue>);
    extern "js" fn timeLog(self, label: Option<JsValue>);
    extern "js" fn error(self, data: JsArray<JsValue>);
    extern "js" fn clear(self, data: JsArray<JsValue>);
    extern "js" fn countReset(self, label: Option<JsValue>);
    extern "js" fn info(self, data: JsArray<JsValue>);
    extern "js" fn group(self, data: JsArray<JsValue>);
    extern "js" fn log(self, data: JsArray<JsValue>);
    extern "js" fn timeStamp(self, label: Option<JsValue>);
    extern "js" fn dir(self, data: JsArray<JsValue>);
    extern "js" fn table(self, data: JsArray<JsValue>);
    extern "js" fn profile(self, label: Option<JsValue>);
    extern "js" fn time(self, label: Option<JsValue>);
    extern "js" fn profileEnd(self, label: Option<JsValue>);
    extern "js" fn count(self, label: Option<JsValue>);
}

impl InspectorNotification {
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" params: JsValue;
}

impl Interceptable {
    extern "js" fn cleanMocks(self);
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
    // inherited from Dispatcher
    extern "js" fn upgrade(self, options: UpgradeOptions, callback: Option<fn(Option<JsValue>, UpgradeData) -> ()>);
    // inherited from Dispatcher
    extern "js" fn addListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn listeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // inherited from Dispatcher
    extern "js" fn destroy(self, err: Option<JsValue>, callback: Option<fn() -> ()>);
    // inherited from Dispatcher
    extern "js" fn connect(self, options: ConnectOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ConnectData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    // inherited from Dispatcher
    extern "js" fn removeListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn prependListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn pipeline(self, options: PipelineOptions<TOpaque>, handler: fn(PipelineHandlerData<TOpaque>) -> Readable) -> Duplex;
    // inherited from Dispatcher
    extern "js" fn on(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn rawListeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // inherited from Dispatcher
    extern "js" fn once(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn off(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn request(self, options: RequestOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ResponseData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn stream(self, options: RequestOptions<TOpaque>, factory: fn(StreamFactoryData<TOpaque>) -> Writable, callback: Option<fn(Option<JsValue>, StreamData<TOpaque>) -> ()>);
    // inherited from Dispatcher
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Dispatcher
    extern "js" fn compose(self, dispatchers: JsArray<fn(JsValue) -> JsValue>) -> ComposedDispatcher;
    // inherited from Dispatcher
    extern "js" fn prependOnceListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // inherited from Dispatcher
    extern "js" fn emit(self, eventName: String, origin: URL, targets: Option<JsArray<Dispatcher>>, error: Option<UndiciError>) -> bool;
}

impl Interface {
    extern "js" fn setPrompt(self, prompt: String);
    // merged from 9 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // merged from 9 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    // merged from 2 overloads
    extern "js" fn question(self, query: String, options: Abortable, callback: Option<fn(String) -> ()>);
    extern "js" fn prompt(self, preserveCursor: Option<bool>);
    // property (readonly)
    extern "js" fn cursor(self) -> f64;
    // merged from 9 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // merged from 2 overloads
    extern "js" fn write(self, data: JsValue, key: Option<Key>);
    // property (readonly)
    extern "js" fn terminal(self) -> bool;
    extern "js" fn pause(self) -> Interface;
    extern "js" fn close(self);
    // merged from 2 overloads
    extern "js" fn new_(input: ReadableStream, output: Option<WritableStream>, completer: Option<JsValue>, terminal: Option<bool>) -> Interface;
    extern "js" fn getCursorPos(self) -> CursorPos;
    // merged from 9 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    extern "js" fn getPrompt(self) -> String;
    // merged from 9 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    extern "js" fn resume(self) -> Interface;
    // merged from 9 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // property (readonly)
    extern "js" fn line(self) -> String;
}

impl InternalPropertyDescriptor {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<RemoteObject>>;
}

impl IntervalHistogram {
    #[getter]
    extern "js" count: f64;
    #[getter]
    extern "js" countBigInt: i64;
    #[getter]
    extern "js" exceeds: f64;
    #[getter]
    extern "js" exceedsBigInt: i64;
    #[getter]
    extern "js" max: f64;
    #[getter]
    extern "js" maxBigInt: f64;
    #[getter]
    extern "js" mean: f64;
    #[getter]
    extern "js" min: f64;
    #[getter]
    extern "js" minBigInt: i64;
    #[getter]
    extern "js" percentiles: JsValue;
    #[getter]
    extern "js" percentilesBigInt: JsValue;
    #[getter]
    extern "js" stddev: f64;

    extern "js" fn enable(self) -> bool;
    extern "js" fn disable(self) -> bool;
    // inherited from Histogram
    extern "js" fn reset(self);
    // inherited from Histogram
    extern "js" fn percentile(self, percentile: f64) -> f64;
    // inherited from Histogram
    extern "js" fn percentileBigInt(self, percentile: f64) -> i64;
}

impl InvalidArgumentError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl InvalidReturnValueError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl IpcNetConnectOpts {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onread: Option<Option<OnReadOpts>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl IpcSocketConnectOpts {
    #[getter]
    #[setter]
    extern "js" path: String;
}

impl IsDeepStrictEqualOptions {
    #[getter]
    #[setter]
    extern "js" skipPrototype: Option<Option<bool>>;
}

impl JsonWebKey {
    #[getter]
    #[setter]
    extern "js" crv: Option<String>;
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" dp: Option<String>;
    #[getter]
    #[setter]
    extern "js" dq: Option<String>;
    #[getter]
    #[setter]
    extern "js" e: Option<String>;
    #[getter]
    #[setter]
    extern "js" k: Option<String>;
    #[getter]
    #[setter]
    extern "js" kty: Option<String>;
    #[getter]
    #[setter]
    extern "js" n: Option<String>;
    #[getter]
    #[setter]
    extern "js" p: Option<String>;
    #[getter]
    #[setter]
    extern "js" q: Option<String>;
    #[getter]
    #[setter]
    extern "js" qi: Option<String>;
    #[getter]
    #[setter]
    extern "js" x: Option<String>;
    #[getter]
    #[setter]
    extern "js" y: Option<String>;
    #[getter]
    #[setter]
    extern "js" alg: Option<String>;
    #[getter]
    #[setter]
    extern "js" crv: Option<String>;
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" dp: Option<String>;
    #[getter]
    #[setter]
    extern "js" dq: Option<String>;
    #[getter]
    #[setter]
    extern "js" e: Option<String>;
    #[getter]
    #[setter]
    extern "js" ext: Option<bool>;
    #[getter]
    #[setter]
    extern "js" k: Option<String>;
    #[getter]
    #[setter]
    extern "js" key_ops: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" kty: Option<String>;
    #[getter]
    #[setter]
    extern "js" n: Option<String>;
    #[getter]
    #[setter]
    extern "js" oth: Option<JsArray<RsaOtherPrimesInfo>>;
    #[getter]
    #[setter]
    extern "js" p: Option<String>;
    #[getter]
    #[setter]
    extern "js" q: Option<String>;
    #[getter]
    #[setter]
    extern "js" qi: Option<String>;
    #[getter]
    #[setter]
    extern "js" use_: Option<String>;
    #[getter]
    #[setter]
    extern "js" x: Option<String>;
    #[getter]
    #[setter]
    extern "js" y: Option<String>;
}

impl JsonWebKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsonWebKey;
    #[getter]
    #[setter]
    extern "js" format: String;
}

impl JwkKeyExportOptions {
    #[getter]
    #[setter]
    extern "js" format: String;
}

impl Key {
    #[getter]
    #[setter]
    extern "js" sequence: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ctrl: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" meta: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shift: Option<Option<bool>>;
}

impl KeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl KeyExportOptions {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" format: JsValue;
    #[getter]
    #[setter]
    extern "js" cipher: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<JsValue>;
}

impl KeyObject {
    #[getter]
    #[setter]
    extern "js" pem: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;

    // property getter
    extern "js" fn type_(self) -> String;
    extern "js" fn from(key: CryptoKey) -> KeyObject;
    // property setter
    extern "js" fn set_asymmetricKeyDetails(self, value: Option<AsymmetricKeyDetails>);
    extern "js" fn new_() -> KeyObject;
    extern "js" fn toCryptoKey(self, algorithm: JsValue, extractable: bool, keyUsages: JsArray<JsValue>) -> CryptoKey;
    // property getter
    extern "js" fn asymmetricKeyDetails(self) -> Option<AsymmetricKeyDetails>;
    // property getter
    extern "js" fn symmetricKeySize(self) -> Option<f64>;
    // property setter
    extern "js" fn set_symmetricKeySize(self, value: Option<f64>);
    // merged from 3 overloads
    extern "js" fn export_(self, options: KeyExportOptions<String>) -> JsValue;
    // property setter
    extern "js" fn set_asymmetricKeyType(self, value: Option<JsValue>);
    // property setter
    extern "js" fn set_type_(self, value: String);
    extern "js" fn equals(self, otherKeyObject: KeyObject) -> bool;
    // property getter
    extern "js" fn asymmetricKeyType(self) -> Option<JsValue>;
}

impl KeyPairKeyObjectResult {
    #[getter]
    #[setter]
    extern "js" publicKey: KeyObject;
    #[getter]
    #[setter]
    extern "js" privateKey: KeyObject;
}

impl KeyPairSyncResult {
    #[getter]
    #[setter]
    extern "js" publicKey: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKey: JsValue;
}

impl KmacImportParams {
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl KmacKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl KmacKeyGenParams {
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl KmacParams {
    #[getter]
    #[setter]
    extern "js" customization: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl LastSeenObjectIdEventDataType {
    #[getter]
    #[setter]
    extern "js" lastSeenObjectId: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl LcovReporter {
    extern "js" fn new_(opts: Option<TransformOptions>) -> LcovReporter;
}

impl ListenOptions {
    #[getter]
    #[setter]
    extern "js" backlog: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ipv6Only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" reusePort: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" readableAll: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writableAll: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl LoadFnOutput {
    #[getter]
    #[setter]
    extern "js" format: Option<String>;
    #[getter]
    #[setter]
    extern "js" shortCircuit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" source: Option<Option<JsValue>>;
}

impl LoadHookContext {
    #[getter]
    #[setter]
    extern "js" conditions: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" format: Option<String>;
    #[getter]
    #[setter]
    extern "js" importAttributes: ImportAttributes;
}

impl LoadNetworkResourcePageResult {
    #[getter]
    #[setter]
    extern "js" success: bool;
    #[getter]
    #[setter]
    extern "js" stream: Option<Option<JsValue>>;
}

impl LoadNetworkResourceParameterType {
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl LoadNetworkResourceReturnType {
    #[getter]
    #[setter]
    extern "js" resource: LoadNetworkResourcePageResult;
}

impl LoadingFailedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" errorText: String;
}

impl LoadingFinishedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl Location {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
}

impl LocationInfo {
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl Lock {
    #[getter]
    extern "js" mode: JsValue;
    #[getter]
    extern "js" name: String;
}

impl LockInfo {
    #[getter]
    #[setter]
    extern "js" clientId: String;
    #[getter]
    #[setter]
    extern "js" mode: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl LockManager {
    extern "js" fn query(self) -> JsPromise<LockManagerSnapshot>;
    // merged from 2 overloads
    extern "js" fn request(self, name: String, options: LockOptions, callback: Option<JsValue>) -> JsPromise<JsValue>;
}

impl LockManagerSnapshot {
    #[getter]
    #[setter]
    extern "js" held: JsArray<LockInfo>;
    #[getter]
    #[setter]
    extern "js" pending: JsArray<LockInfo>;
}

impl LockOptions {
    #[getter]
    #[setter]
    extern "js" ifAvailable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" steal: Option<bool>;
}

impl LookupAddress {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: f64;
}

impl LookupAllOptions {
    #[getter]
    #[setter]
    extern "js" all: bool;
    #[getter]
    #[setter]
    extern "js" family: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" order: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" verbatim: Option<Option<bool>>;
}

impl LookupOneOptions {
    #[getter]
    #[setter]
    extern "js" all: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" family: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" order: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" verbatim: Option<Option<bool>>;
}

impl LookupOptions {
    #[getter]
    #[setter]
    extern "js" family: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" all: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" order: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" verbatim: Option<Option<bool>>;
}

impl MIMEParams {
    extern "js" fn get(self, name: String) -> Option<String>;
    extern "js" fn set(self, name: String, value: String);
    extern "js" fn values(self) -> Iterator<String>;
    extern "js" fn delete(self, name: String);
    extern "js" fn has(self, name: String) -> bool;
    extern "js" fn keys(self) -> Iterator<String>;
    extern "js" fn entries(self) -> Iterator<(String, String)>;
}

impl MIMEType {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: String;
    #[getter]
    #[setter]
    extern "js" parameters: JsValue;
    #[getter]
    #[setter]
    extern "js" essence: String;

    // property (readonly)
    extern "js" fn essence(self) -> String;
    // property getter
    extern "js" fn type_(self) -> String;
    // property setter
    extern "js" fn set_type_(self, value: String);
    extern "js" fn new_(input: JsValue) -> MIMEType;
    // property setter
    extern "js" fn set_subtype(self, value: String);
    extern "js" fn toString(self) -> String;
    // property getter
    extern "js" fn subtype(self) -> String;
    // property (readonly)
    extern "js" fn params(self) -> MIMEParams;
}

impl MLDSAKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl MLKEMKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl MakeDirectoryOptions {
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<JsValue>>;
}

impl MarkOptions {
    #[getter]
    #[setter]
    extern "js" detail: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" startTime: Option<Option<f64>>;
}

impl MaxOriginsReachedError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl MeasureMemoryOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" execution: Option<JsValue>;
}

impl MeasureOptions {
    #[getter]
    #[setter]
    extern "js" detail: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" duration: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" end: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" start: Option<JsValue>;
}

impl MemoryCacheStore {
    extern "js" fn new_(opts: Option<MemoryCacheStoreOpts>) -> MemoryCacheStore;
    extern "js" fn get(self, key: CacheKey) -> JsValue;
    extern "js" fn createWriteStream(self, key: CacheKey, value: CacheValue) -> Option<Writable>;
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
}

impl MemoryCacheStoreOpts {
    #[getter]
    #[setter]
    extern "js" maxCount: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxEntrySize: Option<f64>;

    // function property
    extern "js" fn errorCallback(self) -> Option<fn(JsValue) -> ()>;
}

impl MemoryMeasurement {
    #[getter]
    #[setter]
    extern "js" total: JsValue;
}

impl MemoryUsage {
    #[getter]
    #[setter]
    extern "js" rss: f64;
    #[getter]
    #[setter]
    extern "js" heapTotal: f64;
    #[getter]
    #[setter]
    extern "js" heapUsed: f64;
    #[getter]
    #[setter]
    extern "js" external: f64;
    #[getter]
    #[setter]
    extern "js" arrayBuffers: f64;
}

impl MemoryUsageFn {
    extern "js" fn rss(self) -> f64;
}

impl MessageAddedEventDataType {
    #[getter]
    #[setter]
    extern "js" message: ConsoleMessage;
}

impl MessageChannel {
    // property (readonly)
    extern "js" fn port2(self) -> MessagePort;
    // property (readonly)
    extern "js" fn port1(self) -> MessagePort;
}

impl MessageEvent {
    #[getter]
    extern "js" data: JsValue;
    #[getter]
    extern "js" lastEventId: String;
    #[getter]
    extern "js" origin: String;
    #[getter]
    extern "js" ports: JsArray<JsValue>;
    #[getter]
    extern "js" source: Option<JsValue>;
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;

    extern "js" fn initMessageEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>, data: Option<JsValue>, origin: Option<String>, lastEventId: Option<String>, source: Option<Option<JsValue>>, ports: Option<JsArray<JsValue>>);
    // inherited from Event
    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    // inherited from Event
    extern "js" fn stopPropagation(self);
    // inherited from Event
    extern "js" fn composedPath(self) -> (EventTarget);
    // inherited from Event
    extern "js" fn stopImmediatePropagation(self);
    // inherited from Event
    extern "js" fn preventDefault(self);
}

impl MessageEventInit {
    #[getter]
    #[setter]
    extern "js" data: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" lastEventId: Option<String>;
    #[getter]
    #[setter]
    extern "js" origin: Option<String>;
    #[getter]
    #[setter]
    extern "js" ports: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" source: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl MessageOptions {
    #[getter]
    #[setter]
    extern "js" keepOpen: Option<Option<bool>>;
}

impl MessagePort {
    // merged from 4 overloads
    extern "js" fn once(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
    extern "js" fn postMessage(self, value: JsValue, transferList: Option<JsArray<JsValue>>);
    // merged from 4 overloads
    extern "js" fn off(self, event: String, listener: fn(Event) -> (), options: Option<EventListenerOptions>) -> MessagePort;
    extern "js" fn unref(self);
    // merged from 4 overloads
    extern "js" fn emit(self, event: String, ev: Event) -> bool;
    extern "js" fn close(self);
    // merged from 4 overloads
    extern "js" fn on(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
    extern "js" fn ref_(self);
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn start(self);
    // merged from 4 overloads
    extern "js" fn removeListener(self, event: String, listener: fn(Event) -> (), options: Option<EventListenerOptions>) -> MessagePort;
    // merged from 4 overloads
    extern "js" fn addListener(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
    // inherited from NodeEventTarget
    extern "js" fn removeAllListeners(self, type_: Option<String>) -> NodeEventTarget;
    // inherited from NodeEventTarget
    extern "js" fn listenerCount(self, type_: String) -> f64;
    // inherited from NodeEventTarget
    extern "js" fn setMaxListeners(self, n: f64);
    // inherited from NodeEventTarget
    extern "js" fn eventNames(self) -> JsArray<String>;
    // inherited from NodeEventTarget
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventTarget
    extern "js" fn addEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
    // inherited from EventTarget
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
    // inherited from EventTarget
    extern "js" fn removeEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
}

impl MessagingOptions {
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl MockAgent {
    extern "js" fn activate(self);
    extern "js" fn deactivate(self);
    extern "js" fn pendingInterceptors(self) -> JsArray<PendingInterceptor>;
    extern "js" fn enableCallHistory(self) -> MockAgent;
    extern "js" fn clearCallHistory(self);
    extern "js" fn getCallHistory(self) -> Option<MockCallHistory>;
    extern "js" fn assertNoPendingInterceptors(self, options: Option<JsValue>);
    extern "js" fn disableCallHistory(self) -> MockAgent;
    // merged from 3 overloads
    extern "js" fn get(self, origin: String) -> TInterceptable;
    extern "js" fn new_(options: Option<JsValue>) -> MockAgent;
    extern "js" fn close(self) -> JsPromise<()>;
    // merged from 4 overloads
    extern "js" fn enableNetConnect(self, host: Option<String>);
    extern "js" fn disableNetConnect(self);
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
}

impl MockCallHistory {
    extern "js" fn lastCall(self) -> Option<MockCallHistoryLog>;
    extern "js" fn filterCallsByOrigin(self, origin: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByMethod(self, method: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByProtocol(self, protocol: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByHash(self, hash: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn firstCall(self) -> Option<MockCallHistoryLog>;
    extern "js" fn filterCallsByFullUrl(self, fullUrl: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn new_(name: String) -> MockCallHistory;
    extern "js" fn filterCalls(self, criteria: JsValue, options: Option<FilterCallsOptions>) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByPort(self, port: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn clear(self);
    extern "js" fn calls(self) -> JsArray<MockCallHistoryLog>;
    extern "js" fn nthCall(self, position: f64) -> Option<MockCallHistoryLog>;
    extern "js" fn filterCallsByPath(self, path: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByHost(self, host: JsValue) -> JsArray<MockCallHistoryLog>;
}

impl MockCallHistoryLog {
    extern "js" fn new_(requestInit: DispatchOptions) -> MockCallHistoryLog;
    // property setter
    extern "js" fn set_origin(self, value: String);
    // property getter
    extern "js" fn path(self) -> String;
    // property setter
    extern "js" fn set_hash(self, value: String);
    // property getter
    extern "js" fn body(self) -> Option<String>;
    // property setter
    extern "js" fn set_protocol(self, value: String);
    // property getter
    extern "js" fn fullUrl(self) -> String;
    // property setter
    extern "js" fn set_searchParams(self, value: JsValue);
    // property getter
    extern "js" fn hash(self) -> String;
    // property getter
    extern "js" fn port(self) -> String;
    extern "js" fn toString(self) -> String;
    // property getter
    extern "js" fn origin(self) -> String;
    // property getter
    extern "js" fn host(self) -> String;
    // property setter
    extern "js" fn set_headers(self, value: Option<JsValue>);
    // property getter
    extern "js" fn protocol(self) -> String;
    // property getter
    extern "js" fn searchParams(self) -> JsValue;
    // property getter
    extern "js" fn method(self) -> String;
    // property setter
    extern "js" fn set_port(self, value: String);
    // property setter
    extern "js" fn set_host(self, value: String);
    // property setter
    extern "js" fn set_path(self, value: String);
    // property setter
    extern "js" fn set_fullUrl(self, value: String);
    // property setter
    extern "js" fn set_body(self, value: Option<String>);
    // property getter
    extern "js" fn headers(self) -> Option<JsValue>;
    extern "js" fn toMap(self) -> JsValue;
    // property setter
    extern "js" fn set_method(self, value: String);
}

impl MockClient {
    extern "js" fn dispatch(self, options: DispatchOptions, handlers: DispatchHandler) -> bool;
    extern "js" fn cleanMocks(self);
    extern "js" fn new_(origin: String, options: Options) -> MockClient;
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
    extern "js" fn close(self) -> JsPromise<()>;
}

impl MockDispatch {
    #[getter]
    #[setter]
    extern "js" times: Option<f64>;
    #[getter]
    #[setter]
    extern "js" persist: bool;
    #[getter]
    #[setter]
    extern "js" consumed: bool;
    #[getter]
    #[setter]
    extern "js" data: MockDispatchData<JsValue, JsValue>;
    #[getter]
    #[setter]
    extern "js" readonly_: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fileMustExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" verbose: Option<Option<fn(JsValue, JsArray<JsValue>) -> ()>>;
    #[getter]
    #[setter]
    extern "js" nativeBinding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" httpProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpsProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" noProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" uri: String;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" token: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" requestTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTunnel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" ignoreTrailingSlash: Option<bool>;
    #[getter]
    #[setter]
    extern "js" acceptNonStandardSearchParameters: Option<bool>;
    #[getter]
    #[setter]
    extern "js" enableCallHistory: Option<bool>;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxOrigins: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" hostname: String;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: String;
    #[getter]
    #[setter]
    extern "js" port: String;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpSocket: Option<Socket>;

    // inherited from Options
    extern "js" fn factory(self, origin: URL, opts: JsValue) -> Dispatcher;
}

impl MockDispatchData {
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" statusCode: Option<f64>;
    #[getter]
    #[setter]
    extern "js" data: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" trailers: Option<JsValue>;
}

impl MockFunctionCall {
    #[getter]
    #[setter]
    extern "js" arguments: JsValue;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" result: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stack: JsValue;
    #[getter]
    #[setter]
    extern "js" target: JsValue;
    #[getter]
    #[setter]
    extern "js" this: JsValue;
}

impl MockFunctionContext {
    #[getter]
    extern "js" calls: JsArray<MockFunctionCall<JsValue>>;

    extern "js" fn mockImplementationOnce(self, implementation: JsValue, onCall: Option<f64>);
    extern "js" fn restore(self);
    extern "js" fn callCount(self) -> f64;
    extern "js" fn resetCalls(self);
    extern "js" fn mockImplementation(self, implementation: JsValue);
}

impl MockFunctionOptions {
    #[getter]
    #[setter]
    extern "js" times: Option<Option<f64>>;
}

impl MockInterceptor {
    extern "js" fn replyContentLength(self) -> MockInterceptor;
    extern "js" fn defaultReplyHeaders(self, headers: IncomingHttpHeaders) -> MockInterceptor;
    extern "js" fn new_(options: Options, mockDispatches: JsArray<MockDispatch>) -> MockInterceptor;
    extern "js" fn replyWithError(self, error: TError) -> MockScope;
    extern "js" fn defaultReplyTrailers(self, trailers: JsValue) -> MockInterceptor;
    // merged from 2 overloads
    extern "js" fn reply(self, statusCode: f64, data: Option<JsValue>, responseOptions: Option<MockResponseOptions>) -> MockScope<TData>;
}

impl MockMethodOptions {
    #[getter]
    #[setter]
    extern "js" getter: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setter: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" times: Option<Option<f64>>;
}

impl MockModuleContext {
    extern "js" fn restore(self);
}

impl MockModuleOptions {
    #[getter]
    #[setter]
    extern "js" cache: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultExport: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" namedExports: Option<Option<JsValue>>;
}

impl MockNotMatchedError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    extern "js" fn new_(message: Option<String>) -> MockNotMatchedError;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl MockPool {
    extern "js" fn dispatch(self, options: DispatchOptions, handlers: DispatchHandler) -> bool;
    extern "js" fn new_(origin: String, options: Options) -> MockPool;
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
    extern "js" fn cleanMocks(self);
    extern "js" fn close(self) -> JsPromise<()>;
}

impl MockPropertyContext {
    extern "js" fn accessCount(self) -> f64;
    extern "js" fn mockImplementation(self, value: JsValue);
    extern "js" fn mockImplementationOnce(self, value: JsValue, onAccess: Option<f64>);
    extern "js" fn restore(self);
    extern "js" fn resetAccesses(self);
    // property (readonly)
    extern "js" fn accesses(self) -> JsArray<JsValue>;
}

impl MockResponseCallbackOptions {
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<String>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
}

impl MockResponseOptions {
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" trailers: Option<JsValue>;
}

impl MockScope {
    extern "js" fn times(self, repeatTimes: f64) -> MockScope<JsValue>;
    extern "js" fn new_(mockDispatch: MockDispatch<JsValue>) -> MockScope;
    extern "js" fn delay(self, waitInMs: f64) -> MockScope<JsValue>;
    extern "js" fn persist(self) -> MockScope<JsValue>;
}

impl MockTimers {
    extern "js" fn reset(self);
    extern "js" fn setTime(self, time: f64);
    extern "js" fn runAll(self);
    extern "js" fn enable(self, options: Option<MockTimersOptions>);
    extern "js" fn tick(self, milliseconds: f64);
}

impl MockTimersOptions {
    #[getter]
    #[setter]
    extern "js" apis: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" now: Option<JsValue>;
}

impl MockTracker {
    #[getter]
    extern "js" timers: MockTimers;

    extern "js" fn reset(self);
    // merged from 2 overloads
    extern "js" fn getter(self, object: JsValue, methodName: JsValue, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
    extern "js" fn property(self, object: JsValue, property: JsValue, value: Option<JsValue>) -> JsValue;
    // merged from 2 overloads
    extern "js" fn setter(self, object: JsValue, methodName: JsValue, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
    extern "js" fn restoreAll(self);
    // merged from 4 overloads
    extern "js" fn method(self, object: JsValue, methodName: JsValue, implementation: JsValue, options: Option<MockFunctionOptions>) -> JsValue;
    extern "js" fn module(self, specifier: String, options: Option<MockModuleOptions>) -> MockModuleContext;
    // merged from 2 overloads
    extern "js" fn fn_(self, original: Option<JsValue>, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
}

impl Module {
    #[getter]
    #[setter]
    extern "js" children: JsArray<Module>;
    #[getter]
    #[setter]
    extern "js" exports: JsValue;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" isPreloading: bool;
    #[getter]
    #[setter]
    extern "js" loaded: bool;
    #[getter]
    #[setter]
    extern "js" parent: Option<Module>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" paths: JsArray<String>;

    extern "js" fn require(self, id: String) -> JsValue;
}

impl ModuleHooks {
    extern "js" fn deregister(self);
}

impl ModuleRequest {
    #[getter]
    #[setter]
    extern "js" specifier: String;
    #[getter]
    #[setter]
    extern "js" attributes: ImportAttributes;
    #[getter]
    #[setter]
    extern "js" phase: JsValue;
}

impl MultiCacheQueryOptions {
    #[getter]
    #[setter]
    extern "js" cacheName: Option<String>;
    #[getter]
    #[setter]
    extern "js" ignoreSearch: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreMethod: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreVary: Option<bool>;
}

impl MxRecord {
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" exchange: String;
}

impl NaptrRecord {
    #[getter]
    #[setter]
    extern "js" flags: String;
    #[getter]
    #[setter]
    extern "js" service: String;
    #[getter]
    #[setter]
    extern "js" regexp: String;
    #[getter]
    #[setter]
    extern "js" replacement: String;
    #[getter]
    #[setter]
    extern "js" order: f64;
    #[getter]
    #[setter]
    extern "js" preference: f64;
}

impl Navigator {
    #[getter]
    extern "js" hardwareConcurrency: f64;
    #[getter]
    extern "js" language: String;
    #[getter]
    extern "js" languages: JsArray<String>;
    #[getter]
    extern "js" locks: LockManager;
    #[getter]
    extern "js" platform: String;
    #[getter]
    extern "js" userAgent: String;
}

impl NetworkInterfaceBase {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" netmask: String;
    #[getter]
    #[setter]
    extern "js" mac: String;
    #[getter]
    #[setter]
    extern "js" internal: bool;
    #[getter]
    #[setter]
    extern "js" cidr: Option<String>;
    #[getter]
    #[setter]
    extern "js" scopeid: Option<f64>;
}

impl NetworkInterfaceInfoIPv4 {
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" netmask: String;
    #[getter]
    #[setter]
    extern "js" mac: String;
    #[getter]
    #[setter]
    extern "js" internal: bool;
    #[getter]
    #[setter]
    extern "js" cidr: Option<String>;
    #[getter]
    #[setter]
    extern "js" scopeid: Option<f64>;
}

impl NetworkInterfaceInfoIPv6 {
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" scopeid: f64;
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" netmask: String;
    #[getter]
    #[setter]
    extern "js" mac: String;
    #[getter]
    #[setter]
    extern "js" internal: bool;
    #[getter]
    #[setter]
    extern "js" cidr: Option<String>;
}

impl NodeEventTarget {
    extern "js" fn once(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
    extern "js" fn emit(self, type_: String, arg: JsValue) -> bool;
    extern "js" fn on(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
    extern "js" fn removeListener(self, type_: String, listener: fn(JsValue) -> (), options: Option<EventListenerOptions>) -> NodeEventTarget;
    extern "js" fn off(self, type_: String, listener: fn(JsValue) -> (), options: Option<EventListenerOptions>) -> NodeEventTarget;
    extern "js" fn removeAllListeners(self, type_: Option<String>) -> NodeEventTarget;
    extern "js" fn addListener(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
    extern "js" fn listenerCount(self, type_: String) -> f64;
    extern "js" fn setMaxListeners(self, n: f64);
    extern "js" fn eventNames(self) -> JsArray<String>;
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventTarget
    extern "js" fn addEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
    // inherited from EventTarget
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
    // inherited from EventTarget
    extern "js" fn removeEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
}

impl NodeGCPerformanceDetail {
    #[getter]
    extern "js" kind: f64;
    #[getter]
    extern "js" flags: f64;
}

impl NotSupportedError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl NotifyWhenWaitingForDisconnectParameterType {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl ObjectEncodingOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl ObjectPreview {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" overflow: bool;
    #[getter]
    #[setter]
    extern "js" properties: JsArray<PropertyPreview>;
    #[getter]
    #[setter]
    extern "js" entries: Option<Option<JsArray<EntryPreview>>>;
}

impl OnReadOpts {
    #[getter]
    #[setter]
    extern "js" buffer: JsValue;

    extern "js" fn callback(self, bytesWritten: f64, buffer: JsValue) -> bool;
}

impl OneShotDigestOptions {
    #[getter]
    #[setter]
    extern "js" outputEncoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl OneShotDigestOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" outputEncoding: String;
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl OneShotDigestOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" outputEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl OpenAsBlobOptions {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl OpenDirOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" bufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
}

impl Options {
    #[getter]
    #[setter]
    extern "js" readonly_: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fileMustExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" verbose: Option<Option<fn(JsValue, JsArray<JsValue>) -> ()>>;
    #[getter]
    #[setter]
    extern "js" nativeBinding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" httpProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpsProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" noProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" uri: String;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" token: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" requestTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTunnel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" agent: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" ignoreTrailingSlash: Option<bool>;
    #[getter]
    #[setter]
    extern "js" acceptNonStandardSearchParameters: Option<bool>;
    #[getter]
    #[setter]
    extern "js" enableCallHistory: Option<bool>;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxOrigins: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<OptionsInterceptors>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<OptionsInterceptors>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" hostname: String;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: String;
    #[getter]
    #[setter]
    extern "js" port: String;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" httpSocket: Option<Socket>;

    extern "js" fn factory(self, origin: URL, opts: JsValue) -> Dispatcher;
}

impl OptionsInterceptors {
    #[getter]
    #[setter]
    extern "js" Client: JsArray<DispatchInterceptor>;
    #[getter]
    #[setter]
    extern "js" Client: JsArray<DispatchInterceptor>;
}

impl OutgoingHttpHeaders {
    #[getter]
    #[setter]
    extern "js" accept: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept_charset: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept_encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept_language: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept_ranges: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_credentials: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_methods: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_allow_origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_expose_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_max_age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_request_headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access_control_request_method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" allow: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cache_control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cdn_cache_control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" connection: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" content_disposition: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_length: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" content_location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_security_policy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_security_policy_report_only: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content_type: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cookie: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dav: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dnt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" date: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" etag: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expect: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expires: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" forwarded: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" from: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_modified_since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_none_match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if_unmodified_since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" last_modified: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" link: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" max_forwards: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pragma: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxy_authenticate: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxy_authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public_key_pins: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public_key_pins_report_only: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referrer_policy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" refresh: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" retry_after: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_extensions: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_key: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sec_websocket_version: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" server: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" set_cookie: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" strict_transport_security: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" te: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" trailer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" transfer_encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" user_agent: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade_insecure_requests: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" vary: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" via: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" warning: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" www_authenticate: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" x_content_type_options: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x_dns_prefetch_control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x_frame_options: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x_xss_protection: Option<Option<String>>;
}

impl OutgoingMessage {
    // property getter
    extern "js" fn useChunkedEncodingByDefault(self) -> bool;
    // property (readonly)
    extern "js" fn headersSent(self) -> bool;
    // property setter
    extern "js" fn set_shouldKeepAlive(self, value: bool);
    // property setter
    extern "js" fn set_useChunkedEncodingByDefault(self, value: bool);
    // property getter
    extern "js" fn finished(self) -> bool;
    // property (readonly)
    extern "js" fn connection(self) -> Option<Socket>;
    extern "js" fn setHeader(self, name: String, value: JsValue) -> OutgoingMessage;
    extern "js" fn removeHeader(self, name: String);
    extern "js" fn flushHeaders(self);
    extern "js" fn getHeader(self, name: String) -> JsValue;
    extern "js" fn getHeaders(self) -> OutgoingHttpHeaders;
    // property (readonly)
    extern "js" fn req(self) -> JsValue;
    // property getter
    extern "js" fn chunkedEncoding(self) -> bool;
    // property setter
    extern "js" fn set_chunkedEncoding(self, value: bool);
    // property getter
    extern "js" fn shouldKeepAlive(self) -> bool;
    extern "js" fn getHeaderNames(self) -> JsArray<String>;
    extern "js" fn setHeaders(self, headers: JsValue) -> OutgoingMessage;
    extern "js" fn hasHeader(self, name: String) -> bool;
    extern "js" fn addTrailers(self, headers: JsValue);
    // property (readonly)
    extern "js" fn socket(self) -> Option<Socket>;
    extern "js" fn appendHeader(self, name: String, value: JsValue) -> OutgoingMessage;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>) -> OutgoingMessage;
    // property setter
    extern "js" fn set_sendDate(self, value: bool);
    extern "js" fn new_() -> OutgoingMessage;
    // property getter
    extern "js" fn sendDate(self) -> bool;
    // property setter
    extern "js" fn set_finished(self, value: bool);
}

impl PSKCallbackNegotation {
    #[getter]
    #[setter]
    extern "js" psk: JsValue;
    #[getter]
    #[setter]
    extern "js" identity: String;
}

impl ParseArgsConfig {
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" options: Option<Option<ParseArgsOptionsConfig>>;
    #[getter]
    #[setter]
    extern "js" strict: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowPositionals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowNegative: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" tokens: Option<Option<bool>>;
}

impl ParseArgsOptionDescriptor {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" multiple: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" short: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" default_: Option<JsValue>;
}

impl ParseOptions {
    #[getter]
    #[setter]
    extern "js" maxKeys: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" decodeURIComponent: Option<Option<fn(String) -> String>>;
}

impl ParsedPath {
    #[getter]
    #[setter]
    extern "js" root: String;
    #[getter]
    #[setter]
    extern "js" dir: String;
    #[getter]
    #[setter]
    extern "js" base: String;
    #[getter]
    #[setter]
    extern "js" ext: String;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl PathToFileUrlOptions {
    #[getter]
    #[setter]
    extern "js" windows: Option<Option<bool>>;
}

impl PauseOnAsyncCallParameterType {
    #[getter]
    #[setter]
    extern "js" parentStackTraceId: StackTraceId;
}

impl PausedEventDataType {
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" reason: String;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" hitBreakpoints: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
    #[getter]
    #[setter]
    extern "js" asyncCallStackTraceId: Option<Option<StackTraceId>>;
}

impl Pbkdf2Params {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" iterations: f64;
    #[getter]
    #[setter]
    extern "js" salt: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl PeerCertificate {
    #[getter]
    #[setter]
    extern "js" ca: bool;
    #[getter]
    #[setter]
    extern "js" raw: Buffer<JsValue>;
    #[getter]
    #[setter]
    extern "js" subject: Certificate;
    #[getter]
    #[setter]
    extern "js" issuer: Certificate;
    #[getter]
    #[setter]
    extern "js" valid_from: String;
    #[getter]
    #[setter]
    extern "js" valid_to: String;
    #[getter]
    #[setter]
    extern "js" serialNumber: String;
    #[getter]
    #[setter]
    extern "js" fingerprint: String;
    #[getter]
    #[setter]
    extern "js" fingerprint256: String;
    #[getter]
    #[setter]
    extern "js" fingerprint512: String;
    #[getter]
    #[setter]
    extern "js" ext_key_usage: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" subjectaltname: Option<String>;
    #[getter]
    #[setter]
    extern "js" infoAccess: Option<Dict<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" bits: Option<f64>;
    #[getter]
    #[setter]
    extern "js" exponent: Option<String>;
    #[getter]
    #[setter]
    extern "js" modulus: Option<String>;
    #[getter]
    #[setter]
    extern "js" pubkey: Option<Buffer<JsValue>>;
    #[getter]
    #[setter]
    extern "js" asn1Curve: Option<String>;
    #[getter]
    #[setter]
    extern "js" nistCurve: Option<String>;
}

impl PendingInterceptor {
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" times: Option<f64>;
    #[getter]
    #[setter]
    extern "js" persist: bool;
    #[getter]
    #[setter]
    extern "js" consumed: bool;
    #[getter]
    #[setter]
    extern "js" data: MockDispatchData<TData, TError>;
    #[getter]
    #[setter]
    extern "js" readonly_: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fileMustExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" verbose: Option<Option<fn(JsValue, JsArray<JsValue>) -> ()>>;
    #[getter]
    #[setter]
    extern "js" nativeBinding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" httpProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpsProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" noProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" uri: String;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" token: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" requestTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTunnel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" ignoreTrailingSlash: Option<bool>;
    #[getter]
    #[setter]
    extern "js" acceptNonStandardSearchParameters: Option<bool>;
    #[getter]
    #[setter]
    extern "js" enableCallHistory: Option<bool>;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxOrigins: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" hostname: String;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: String;
    #[getter]
    #[setter]
    extern "js" port: String;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpSocket: Option<Socket>;

    // inherited from MockDispatch
    extern "js" fn factory(self, origin: URL, opts: JsValue) -> Dispatcher;
}

impl PendingInterceptorsFormatter {
    extern "js" fn format(self, pendingInterceptors: JsArray<PendingInterceptor>) -> String;
}

impl Performance {
    #[getter]
    #[setter]
    extern "js" eventLoopUtilization: fn(EventLoopUtilization, EventLoopUtilization) -> EventLoopUtilization;
    #[getter]
    extern "js" nodeTiming: PerformanceNodeTiming;
    #[getter]
    extern "js" timeOrigin: f64;

    // merged from 2 overloads
    extern "js" fn measure(self, name: String, startMark: Option<String>, endMark: Option<String>) -> PerformanceMeasure;
    extern "js" fn setResourceTimingBufferSize(self, maxSize: f64);
    extern "js" fn timerify(self, fn_: JsValue, options: Option<TimerifyOptions>) -> JsValue;
    extern "js" fn mark(self, name: String, options: Option<MarkOptions>) -> PerformanceMark;
    extern "js" fn markResourceTiming(self, timingInfo: JsValue, requestedUrl: String, initiatorType: String, global_: JsValue, cacheMode: String, bodyInfo: JsValue, responseStatus: f64, deliveryType: Option<String>) -> PerformanceResourceTiming;
    extern "js" fn clearResourceTimings(self, name: Option<String>);
    extern "js" fn getEntries(self) -> JsArray<PerformanceEntry>;
    extern "js" fn clearMeasures(self, name: Option<String>);
    extern "js" fn now(self) -> f64;
    extern "js" fn getEntriesByType(self, type_: String) -> JsArray<PerformanceEntry>;
    extern "js" fn toJSON(self) -> JsValue;
    extern "js" fn getEntriesByName(self, name: String, type_: Option<String>) -> JsArray<PerformanceEntry>;
    extern "js" fn clearMarks(self, name: Option<String>);
}

impl PerformanceEntry {
    extern "js" fn new_() -> PerformanceEntry;
    // property (readonly)
    extern "js" fn startTime(self) -> f64;
    // property (readonly)
    extern "js" fn name(self) -> String;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    extern "js" fn toJSON(self) -> JsValue;
    // property (readonly)
    extern "js" fn duration(self) -> f64;
}

impl PerformanceMark {
    // property (readonly)
    extern "js" fn duration(self) -> f64;
    // property (readonly)
    extern "js" fn detail(self) -> JsValue;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
}

impl PerformanceMeasure {
    // property (readonly)
    extern "js" fn detail(self) -> JsValue;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
}

impl PerformanceNodeTiming {
    // property (readonly)
    extern "js" fn environment(self) -> f64;
    // property (readonly)
    extern "js" fn loopExit(self) -> f64;
    // property (readonly)
    extern "js" fn bootstrapComplete(self) -> f64;
    // property (readonly)
    extern "js" fn loopStart(self) -> f64;
    // property (readonly)
    extern "js" fn idleTime(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn uvMetricsInfo(self) -> UVMetrics;
    // property (readonly)
    extern "js" fn v8Start(self) -> f64;
    // property (readonly)
    extern "js" fn nodeStart(self) -> f64;
}

impl PerformanceObserver {
    extern "js" fn new_(callback: fn(PerformanceObserverEntryList, PerformanceObserver) -> ()) -> PerformanceObserver;
    extern "js" fn disconnect(self);
    extern "js" fn takeRecords(self) -> JsArray<PerformanceEntry>;
    extern "js" fn observe(self, options: JsValue);
}

impl PerformanceObserverEntryList {
    extern "js" fn getEntries(self) -> JsArray<PerformanceEntry>;
    extern "js" fn getEntriesByType(self, type_: String) -> JsArray<PerformanceEntry>;
    extern "js" fn getEntriesByName(self, name: String, type_: Option<String>) -> JsArray<PerformanceEntry>;
}

impl PerformanceResourceTiming {
    // property (readonly)
    extern "js" fn redirectEnd(self) -> f64;
    // property (readonly)
    extern "js" fn connectEnd(self) -> f64;
    // property (readonly)
    extern "js" fn encodedBodySize(self) -> f64;
    // property (readonly)
    extern "js" fn fetchStart(self) -> f64;
    // property (readonly)
    extern "js" fn decodedBodySize(self) -> f64;
    // property (readonly)
    extern "js" fn connectStart(self) -> f64;
    // property (readonly)
    extern "js" fn transferSize(self) -> f64;
    // property (readonly)
    extern "js" fn domainLookupEnd(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn redirectStart(self) -> f64;
    // property (readonly)
    extern "js" fn domainLookupStart(self) -> f64;
    extern "js" fn toJSON(self) -> JsValue;
    // property (readonly)
    extern "js" fn secureConnectionStart(self) -> f64;
    extern "js" fn new_() -> PerformanceResourceTiming;
    // property (readonly)
    extern "js" fn workerStart(self) -> f64;
    // property (readonly)
    extern "js" fn responseEnd(self) -> f64;
    // property (readonly)
    extern "js" fn requestStart(self) -> f64;
}

impl Pipe {
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn unref(self);
    extern "js" fn close(self);
    extern "js" fn ref_(self);
}

impl PipelineHandlerData {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl PipelineOptions {
    #[getter]
    #[setter]
    extern "js" objectMode: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<bool>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" checkServerIdentity: Option<Option<fn(String, DetailedPeerCertificate) -> Option<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" servername: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;

    // inherited from RequestOptions
    extern "js" fn onInfo(self) -> Option<fn(JsValue) -> ()>;
}

impl PlatformPath {
    #[getter]
    extern "js" sep: String;
    #[getter]
    extern "js" delimiter: String;
    #[getter]
    extern "js" posix: PlatformPath;
    #[getter]
    extern "js" win32: PlatformPath;

    extern "js" fn resolve(self, paths: JsArray<String>) -> String;
    extern "js" fn matchesGlob(self, path: String, pattern: String) -> bool;
    extern "js" fn isAbsolute(self, path: String) -> bool;
    extern "js" fn normalize(self, path: String) -> String;
    extern "js" fn relative(self, from: String, to: String) -> String;
    extern "js" fn extname(self, path: String) -> String;
    extern "js" fn toNamespacedPath(self, path: String) -> String;
    extern "js" fn join(self, paths: JsArray<String>) -> String;
    extern "js" fn basename(self, path: String, suffix: Option<String>) -> String;
    extern "js" fn dirname(self, path: String) -> String;
    extern "js" fn parse(self, path: String) -> ParsedPath;
    extern "js" fn format(self, pathObject: FormatInputPathObject) -> String;
}

impl Pool {
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    extern "js" fn new_(url: JsValue, options: Option<Options>) -> Pool;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property getter
    extern "js" fn closed(self) -> bool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
}

impl PoolStats {
    // property setter
    extern "js" fn set_running(self, value: f64);
    // property getter
    extern "js" fn queued(self) -> f64;
    // property getter
    extern "js" fn free(self) -> f64;
    // property setter
    extern "js" fn set_connected(self, value: f64);
    // property getter
    extern "js" fn pending(self) -> f64;
    // property setter
    extern "js" fn set_pending(self, value: f64);
    extern "js" fn new_(pool: Pool) -> PoolStats;
    // property setter
    extern "js" fn set_queued(self, value: f64);
    // property setter
    extern "js" fn set_size(self, value: f64);
    // property getter
    extern "js" fn running(self) -> f64;
    // property getter
    extern "js" fn connected(self) -> f64;
    // property setter
    extern "js" fn set_free(self, value: f64);
    // property getter
    extern "js" fn size(self) -> f64;
}

impl PositionTickInfo {
    #[getter]
    #[setter]
    extern "js" line: f64;
    #[getter]
    #[setter]
    extern "js" ticks: f64;
}

impl PragmaOptions {
    #[getter]
    #[setter]
    extern "js" simple: Option<Option<bool>>;
}

impl PrivateKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl Process {
    #[getter]
    #[setter]
    extern "js" stdout: WriteStream;
    #[getter]
    #[setter]
    extern "js" stderr: WriteStream;
    #[getter]
    #[setter]
    extern "js" stdin: ReadStream;
    #[getter]
    #[setter]
    extern "js" argv: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" argv0: String;
    #[getter]
    #[setter]
    extern "js" execArgv: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" execPath: String;
    #[getter]
    #[setter]
    extern "js" debugPort: f64;
    #[getter]
    #[setter]
    extern "js" env: ProcessEnv;
    #[getter]
    #[setter]
    extern "js" exitCode: JsValue;
    #[getter]
    #[setter]
    extern "js" finalization: JsValue;
    #[getter]
    extern "js" sourceMapsEnabled: bool;
    #[getter]
    extern "js" version: String;
    #[getter]
    extern "js" versions: ProcessVersions;
    #[getter]
    extern "js" config: ProcessConfig;
    #[getter]
    extern "js" pid: f64;
    #[getter]
    extern "js" ppid: f64;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    extern "js" arch: String;
    #[getter]
    extern "js" platform: String;
    #[getter]
    #[setter]
    extern "js" mainModule: Option<Module>;
    #[getter]
    #[setter]
    extern "js" memoryUsage: MemoryUsageFn;
    #[getter]
    #[setter]
    extern "js" permission: ProcessPermission;
    #[getter]
    extern "js" release: ProcessRelease;
    #[getter]
    extern "js" features: ProcessFeatures;
    #[getter]
    #[setter]
    extern "js" hrtime: HRTime;
    #[getter]
    #[setter]
    extern "js" channel: Option<Control>;
    #[getter]
    #[setter]
    extern "js" connected: bool;
    #[getter]
    #[setter]
    extern "js" allowedNodeEnvironmentFlags: JsValue;
    #[getter]
    #[setter]
    extern "js" report: ProcessReport;
    #[getter]
    #[setter]
    extern "js" throwDeprecation: bool;
    #[getter]
    #[setter]
    extern "js" traceDeprecation: bool;

    // function property
    extern "js" fn setgroups(self) -> Option<fn(JsArray<JsValue>) -> ()>;
    // function property
    extern "js" fn seteuid(self) -> Option<fn(JsValue) -> ()>;
    // merged from 13 overloads
    extern "js" fn addListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    // function property
    extern "js" fn getegid(self) -> Option<fn() -> f64>;
    // function property
    extern "js" fn getgid(self) -> Option<fn() -> f64>;
    // merged from 2 overloads
    extern "js" fn umask(self, mask: Option<JsValue>) -> f64;
    extern "js" fn uptime(self) -> f64;
    extern "js" fn kill(self, pid: f64, signal: Option<JsValue>) -> bool;
    extern "js" fn execve(self, file: String, args: Option<JsArray<String>>, env: Option<ProcessEnv>);
    // merged from 14 overloads
    extern "js" fn on(self, event: String, listener: fn(f64) -> ()) -> Process;
    // function property
    extern "js" fn setgid(self) -> Option<fn(JsValue) -> ()>;
    extern "js" fn threadCpuUsage(self, previousValue: Option<CpuUsage>) -> CpuUsage;
    // merged from 14 overloads
    extern "js" fn once(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn ref_(self, maybeRefable: JsValue);
    extern "js" fn availableMemory(self) -> f64;
    // function property
    extern "js" fn geteuid(self) -> Option<fn() -> f64>;
    extern "js" fn cpuUsage(self, previousValue: Option<CpuUsage>) -> CpuUsage;
    extern "js" fn loadEnvFile(self, path: Option<JsValue>);
    // merged from 4 overloads
    extern "js" fn emitWarning(self, warning: JsValue, type_: Option<String>, code: Option<String>, ctor: Option<JsFn>);
    extern "js" fn abort(self);
    // function property
    extern "js" fn getgroups(self) -> Option<fn() -> JsArray<f64>>;
    extern "js" fn hasUncaughtExceptionCaptureCallback(self) -> bool;
    extern "js" fn resourceUsage(self) -> ResourceUsage;
    // merged from 13 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    // function property
    extern "js" fn setegid(self) -> Option<fn(JsValue) -> ()>;
    // merged from 13 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn dlopen(self, module: JsValue, filename: String, flags: Option<f64>);
    // function property
    extern "js" fn setuid(self) -> Option<fn(JsValue) -> ()>;
    extern "js" fn exit(self, code: Option<JsValue>);
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    extern "js" fn setUncaughtExceptionCaptureCallback(self, cb: Option<fn(JsValue) -> ()>);
    // function property
    extern "js" fn getuid(self) -> Option<fn() -> f64>;
    extern "js" fn setSourceMapsEnabled(self, value: bool);
    extern "js" fn constrainedMemory(self) -> f64;
    // merged from 2 overloads
    extern "js" fn getBuiltinModule(self, id: JsValue) -> JsValue;
    extern "js" fn nextTick(self, callback: JsFn, args: JsArray<JsValue>);
    extern "js" fn getActiveResourcesInfo(self) -> JsArray<String>;
    extern "js" fn cwd(self) -> String;
    // merged from 13 overloads
    extern "js" fn listeners(self, event: String) -> JsArray<fn(f64) -> ()>;
    extern "js" fn disconnect(self);
    extern "js" fn chdir(self, directory: String);
    extern "js" fn unref(self, maybeRefable: JsValue);
    // merged from 13 overloads
    extern "js" fn emit(self, event: String, type_: Option<String>, promise: Option<JsPromise<JsValue>>, value: Option<JsValue>) -> Process;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl ProcessConfig {
    #[getter]
    extern "js" target_defaults: JsValue;
    #[getter]
    extern "js" variables: JsValue;
}

impl ProcessEnv {
    #[getter]
    #[setter]
    extern "js" TZ: Option<Option<String>>;
}

impl ProcessEnvOptions {
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ProcessFeatures {
    #[getter]
    extern "js" cached_builtins: bool;
    #[getter]
    extern "js" debug: bool;
    #[getter]
    extern "js" inspector: bool;
    #[getter]
    extern "js" ipv6: bool;
    #[getter]
    extern "js" require_module: bool;
    #[getter]
    extern "js" tls: bool;
    #[getter]
    extern "js" tls_alpn: bool;
    #[getter]
    extern "js" tls_ocsp: bool;
    #[getter]
    extern "js" tls_sni: bool;
    #[getter]
    extern "js" typescript: JsValue;
    #[getter]
    extern "js" uv: bool;
}

impl ProcessPermission {
    extern "js" fn has(self, scope: String, reference: Option<String>) -> bool;
}

impl ProcessRelease {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" sourceUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" headersUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" libUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lts: Option<Option<String>>;
}

impl ProcessReport {
    #[getter]
    #[setter]
    extern "js" compact: bool;
    #[getter]
    #[setter]
    extern "js" directory: String;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" reportOnFatalError: bool;
    #[getter]
    #[setter]
    extern "js" reportOnSignal: bool;
    #[getter]
    #[setter]
    extern "js" reportOnUncaughtException: bool;
    #[getter]
    #[setter]
    extern "js" signal: String;

    // merged from 2 overloads
    extern "js" fn writeReport(self, fileName: Option<String>, err: Option<JsValue>) -> String;
    extern "js" fn getReport(self, err: Option<JsValue>) -> JsValue;
}

impl ProcessVersions {
    #[getter]
    #[setter]
    extern "js" http_parser: String;
    #[getter]
    #[setter]
    extern "js" node: String;
    #[getter]
    #[setter]
    extern "js" v8: String;
    #[getter]
    #[setter]
    extern "js" ares: String;
    #[getter]
    #[setter]
    extern "js" uv: String;
    #[getter]
    #[setter]
    extern "js" zlib: String;
    #[getter]
    #[setter]
    extern "js" modules: String;
    #[getter]
    #[setter]
    extern "js" openssl: String;
}

impl Profile {
    #[getter]
    #[setter]
    extern "js" nodes: JsArray<ProfileNode>;
    #[getter]
    #[setter]
    extern "js" startTime: f64;
    #[getter]
    #[setter]
    extern "js" endTime: f64;
    #[getter]
    #[setter]
    extern "js" samples: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" timeDeltas: Option<Option<JsArray<f64>>>;
}

impl ProfileNode {
    #[getter]
    #[setter]
    extern "js" id: f64;
    #[getter]
    #[setter]
    extern "js" callFrame: CallFrame;
    #[getter]
    #[setter]
    extern "js" hitCount: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" children: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" deoptReason: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" positionTicks: Option<Option<JsArray<PositionTickInfo>>>;
}

impl PromiseHooks {
    // function property
    extern "js" fn onAfter(self) -> fn(After) -> JsFn;
    // function property
    extern "js" fn createHook(self) -> fn(HookCallbacks) -> JsFn;
    // function property
    extern "js" fn onSettled(self) -> fn(Settled) -> JsFn;
    // function property
    extern "js" fn onBefore(self) -> fn(Before) -> JsFn;
    // function property
    extern "js" fn onInit(self) -> fn(Init) -> JsFn;
}

impl PromiseWithChild {
    #[getter]
    #[setter]
    extern "js" child: ChildProcess;
}

impl PropertyDescriptor {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" get: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" set: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" configurable: bool;
    #[getter]
    #[setter]
    extern "js" enumerable: bool;
    #[getter]
    #[setter]
    extern "js" wasThrown: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isOwn: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" symbol: Option<Option<RemoteObject>>;
}

impl PropertyPreview {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" valuePreview: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
}

impl ProxyAgent {
    extern "js" fn new_(options: JsValue) -> ProxyAgent;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
}

impl ProxyEnv {
    #[getter]
    #[setter]
    extern "js" HTTP_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" HTTPS_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" NO_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" http_proxy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" https_proxy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" no_proxy: Option<Option<String>>;
}

impl PublicKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl PxfObject {
    #[getter]
    #[setter]
    extern "js" buf: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
}

impl QueryObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" prototypeObjectId: String;
}

impl QueryObjectsReturnType {
    #[getter]
    #[setter]
    extern "js" objects: RemoteObject;
}

impl QueuingStrategy {
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" size: Option<QueuingStrategySize<JsValue>>;
}

impl QueuingStrategyInit {
    #[getter]
    #[setter]
    extern "js" highWaterMark: f64;
}

impl REPLCommand {
    #[getter]
    #[setter]
    extern "js" help: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" action: JsFn;
}

impl REPLServer {
    // property (readonly)
    extern "js" fn ignoreUndefined(self) -> bool;
    // property (readonly)
    extern "js" fn useColors(self) -> bool;
    // property (readonly)
    extern "js" fn writer(self) -> JsFn;
    // merged from 10 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn output(self) -> WritableStream;
    // property (readonly)
    extern "js" fn eval(self) -> JsFn;
    // property (readonly)
    extern "js" fn replMode(self) -> JsValue;
    // merged from 10 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    // property (readonly)
    extern "js" fn inputStream(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn lastError(self) -> JsValue;
    // merged from 2 overloads
    extern "js" fn setupHistory(self, historyPath: String, callback: fn(Option<JsValue>, REPLServer) -> ());
    // property (readonly)
    extern "js" fn editorMode(self) -> bool;
    // property (readonly)
    extern "js" fn underscoreAssigned(self) -> bool;
    extern "js" fn defineCommand(self, keyword: String, cmd: JsValue);
    // property (readonly)
    extern "js" fn useGlobal(self) -> bool;
    // merged from 10 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    extern "js" fn new_() -> REPLServer;
    extern "js" fn displayPrompt(self, preserveCursor: Option<bool>);
    // property (readonly)
    extern "js" fn completer(self) -> JsValue;
    // merged from 10 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn underscoreErrAssigned(self) -> bool;
    // property (readonly)
    extern "js" fn context(self) -> Context;
    // property (readonly)
    extern "js" fn last(self) -> JsValue;
    // merged from 10 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn input(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn commands(self) -> ReadOnlyDict<REPLCommand>;
    extern "js" fn clearBufferedCommand(self);
    // merged from 10 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn outputStream(self) -> WritableStream;
}

impl REPLServerSetupHistoryOptions {
    #[getter]
    #[setter]
    extern "js" filePath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" size: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" removeHistoryDuplicates: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onHistoryFileLoaded: Option<Option<fn(Option<JsValue>, REPLServer) -> ()>>;
}

impl RSAKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
}

impl RSAKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl RSAPSSKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<String>>;
}

impl RSAPSSKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl RandomUUIDOptions {
    #[getter]
    #[setter]
    extern "js" disableEntropyCache: Option<Option<bool>>;
}

impl ReadAsyncOptions {
    #[getter]
    #[setter]
    extern "js" buffer: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl ReadLineOptions {
    #[getter]
    #[setter]
    extern "js" completer: Option<Option<fn(String) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" input: ReadableStream;
    #[getter]
    #[setter]
    extern "js" output: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" completer: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" terminal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" history: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" historySize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" removeHistoryDuplicates: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" prompt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crlfDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" escapeCodeTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" tabSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ReadOptions {
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl ReadOptionsWithBuffer {
    #[getter]
    #[setter]
    extern "js" buffer: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl ReadParameterType {
    #[getter]
    #[setter]
    extern "js" handle: String;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" size: Option<Option<f64>>;
}

impl ReadReturnType {
    #[getter]
    #[setter]
    extern "js" data: String;
    #[getter]
    #[setter]
    extern "js" eof: bool;
}

impl ReadStream {
    extern "js" fn once(self, event: K, listener: JsValue) -> ReadStream;
    // property setter
    extern "js" fn set_pending(self, value: bool);
    extern "js" fn close(self, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // property setter
    extern "js" fn set_bytesRead(self, value: f64);
    // property getter
    extern "js" fn path(self) -> JsValue;
    extern "js" fn addListener(self, event: K, listener: JsValue) -> ReadStream;
    extern "js" fn on(self, event: K, listener: JsValue) -> ReadStream;
    extern "js" fn prependListener(self, event: K, listener: JsValue) -> ReadStream;
    extern "js" fn prependOnceListener(self, event: K, listener: JsValue) -> ReadStream;
    // property getter
    extern "js" fn pending(self) -> bool;
    // property getter
    extern "js" fn bytesRead(self) -> f64;
    // property setter
    extern "js" fn set_path(self, value: JsValue);
}

impl ReadStreamOptions {
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<CreateReadStreamFSImplementation>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ReadSyncOptions {
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl ReadVResult {
    #[getter]
    #[setter]
    extern "js" bytesRead: f64;
    #[getter]
    #[setter]
    extern "js" buffers: JsValue;
}

impl ReadWriteStream {
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" readable: bool;
    #[getter]
    #[setter]
    extern "js" writable: bool;

    // inherited from ReadableStream
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<String>);
    // inherited from ReadableStream
    extern "js" fn isPaused(self) -> bool;
    // inherited from ReadableStream
    extern "js" fn resume(self) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn pipe(self, destination: JsValue, options: Option<JsValue>) -> JsValue;
    // inherited from ReadableStream
    extern "js" fn setEncoding(self, encoding: String) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    // inherited from ReadableStream
    extern "js" fn pause(self) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn wrap(self, oldStream: ReadableStream) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from ReadableStream
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from ReadableStream
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from ReadableStream
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from ReadableStream
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from ReadableStream
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from ReadableStream
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
    // inherited from WritableStream
    extern "js" fn write(self, str: String, encoding: Option<String>, cb: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // inherited from WritableStream
    extern "js" fn end(self, str: String, encoding: Option<String>, cb: Option<fn() -> ()>) -> WritableStream;
}

impl Readable {
    extern "js" fn _read(self, size: f64);
    extern "js" fn isDisturbed(stream: JsValue) -> bool;
    extern "js" fn asIndexedPairs(self, options: Option<JsValue>) -> Readable;
    extern "js" fn take(self, limit: f64, options: Option<JsValue>) -> Readable;
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    // merged from 2 overloads
    extern "js" fn find(self, fn_: fn(JsValue, JsValue) -> bool, options: Option<ArrayOptions>) -> JsPromise<Option<T>>;
    extern "js" fn new_(opts: Option<ReadableOptions>) -> Readable;
    extern "js" fn pause(self) -> Readable;
    extern "js" fn wrap(self, stream: ReadableStream) -> Readable;
    // property (readonly)
    extern "js" fn readableObjectMode(self) -> bool;
    extern "js" fn map(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<JsValue>);
    // property (readonly)
    extern "js" fn errored(self) -> Option<JsValue>;
    extern "js" fn every(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    // property (readonly)
    extern "js" fn closed(self) -> bool;
    // property (readonly)
    extern "js" fn readableEnded(self) -> bool;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn forEach(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<()>;
    extern "js" fn toArray(self, options: Option<JsValue>) -> JsPromise<JsArray<JsValue>>;
    extern "js" fn flatMap(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    extern "js" fn drop(self, limit: f64, options: Option<JsValue>) -> Readable;
    // merged from 8 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn push(self, chunk: JsValue, encoding: Option<JsValue>) -> bool;
    extern "js" fn filter(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    extern "js" fn iterator(self, options: Option<JsValue>) -> AsyncIterator<JsValue>;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Readable;
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn toWeb(streamReadable: Readable, options: Option<JsValue>) -> ReadableStream;
    // property (readonly)
    extern "js" fn readableAborted(self) -> bool;
    // merged from 2 overloads
    extern "js" fn reduce(self, fn_: fn(JsValue, JsValue, JsValue) -> T, initial: Option<()>, options: Option<JsValue>) -> JsPromise<T>;
    extern "js" fn from(iterable: JsValue, options: Option<ReadableOptions>) -> Readable;
    // property (readonly)
    extern "js" fn readableDidRead(self) -> bool;
    extern "js" fn isPaused(self) -> bool;
    // property getter
    extern "js" fn readable(self) -> bool;
    extern "js" fn resume(self) -> Readable;
    extern "js" fn some(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> Readable;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Readable;
    // property (readonly)
    extern "js" fn readableLength(self) -> f64;
    // property (readonly)
    extern "js" fn readableEncoding(self) -> Option<JsValue>;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Readable;
    // property (readonly)
    extern "js" fn readableFlowing(self) -> Option<bool>;
    // property (readonly)
    extern "js" fn readableHighWaterMark(self) -> f64;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn fromWeb(readableStream: ReadableStream, options: Option<ReadableOptions>) -> Readable;
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property setter
    extern "js" fn set_readable(self, value: bool);
    extern "js" fn setEncoding(self, encoding: JsValue) -> Readable;
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, chunk: Option<JsValue>) -> bool;
    extern "js" fn destroy(self, error: Option<JsValue>) -> Readable;
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
}

impl ReadableByteStreamController {
    #[getter]
    extern "js" byobRequest: ();
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn error(self, error: Option<JsValue>);
    extern "js" fn enqueue(self, chunk: JsValue);
    extern "js" fn close(self);
}

impl ReadableOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" read: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ReadableStream {
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" readable: bool;

    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<String>);
    extern "js" fn isPaused(self) -> bool;
    extern "js" fn resume(self) -> ReadableStream;
    extern "js" fn pipe(self, destination: JsValue, options: Option<JsValue>) -> JsValue;
    extern "js" fn setEncoding(self, encoding: String) -> ReadableStream;
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> ReadableStream;
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    extern "js" fn pause(self) -> ReadableStream;
    extern "js" fn wrap(self, oldStream: ReadableStream) -> ReadableStream;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl ReadableStreamBYOBReader {
    extern "js" fn releaseLock(self);
    extern "js" fn read(self, view: JsValue, options: Option<JsValue>) -> JsPromise<JsValue>;
}

impl ReadableStreamBYOBRequest {
    #[getter]
    extern "js" view: Option<JsValue>;

    extern "js" fn respondWithNewView(self, view: JsValue);
    extern "js" fn respond(self, bytesWritten: f64);
}

impl ReadableStreamDefaultController {
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn close(self);
    extern "js" fn enqueue(self, chunk: Option<JsValue>);
    extern "js" fn error(self, e: Option<JsValue>);
}

impl ReadableStreamDefaultReader {
    extern "js" fn read(self) -> JsPromise<JsValue>;
    extern "js" fn releaseLock(self);
}

impl ReadableStreamGenericReader {
    #[getter]
    extern "js" closed: JsPromise<()>;

    extern "js" fn cancel(self, reason: Option<JsValue>) -> JsPromise<()>;
}

impl ReadableStreamGetReaderOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
}

impl ReadableStreamReadDoneResult {
    #[getter]
    #[setter]
    extern "js" done: bool;
    #[getter]
    #[setter]
    extern "js" value: Option<JsValue>;
}

impl ReadableStreamReadValueResult {
    #[getter]
    #[setter]
    extern "js" done: bool;
    #[getter]
    #[setter]
    extern "js" value: JsValue;
}

impl ReadableWebStreamOptions {
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
}

impl ReadableWritablePair {
    #[getter]
    #[setter]
    extern "js" readable: ReadableStream<JsValue>;
    #[getter]
    #[setter]
    extern "js" writable: WritableStream<JsValue>;
}

impl Readline {
    extern "js" fn cursorTo(self, x: f64, y: Option<f64>) -> Readline;
    extern "js" fn rollback(self) -> Readline;
    extern "js" fn clearLine(self, dir: JsValue) -> Readline;
    extern "js" fn new_(stream: WritableStream, options: Option<JsValue>) -> Readline;
    extern "js" fn clearScreenDown(self) -> Readline;
    extern "js" fn commit(self) -> JsPromise<()>;
    extern "js" fn moveCursor(self, dx: f64, dy: f64) -> Readline;
}

impl ReceivedMessageFromWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl RecordWithTtl {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" ttl: f64;
}

impl RecordableHistogram {
    #[getter]
    extern "js" count: f64;
    #[getter]
    extern "js" countBigInt: i64;
    #[getter]
    extern "js" exceeds: f64;
    #[getter]
    extern "js" exceedsBigInt: i64;
    #[getter]
    extern "js" max: f64;
    #[getter]
    extern "js" maxBigInt: f64;
    #[getter]
    extern "js" mean: f64;
    #[getter]
    extern "js" min: f64;
    #[getter]
    extern "js" minBigInt: i64;
    #[getter]
    extern "js" percentiles: JsValue;
    #[getter]
    extern "js" percentilesBigInt: JsValue;
    #[getter]
    extern "js" stddev: f64;

    extern "js" fn add(self, other: RecordableHistogram);
    extern "js" fn record(self, val: JsValue);
    extern "js" fn recordDelta(self);
    // inherited from Histogram
    extern "js" fn reset(self);
    // inherited from Histogram
    extern "js" fn percentile(self, percentile: f64) -> f64;
    // inherited from Histogram
    extern "js" fn percentileBigInt(self, percentile: f64) -> i64;
}

impl Recoverable {
    extern "js" fn new_(err: JsValue) -> Recoverable;
    // property getter
    extern "js" fn err(self) -> JsValue;
    // property setter
    extern "js" fn set_err(self, value: JsValue);
}

impl RedirectHandler {
    extern "js" fn new_(dispatch: JsValue, maxRedirections: f64, opts: DispatchOptions, handler: DispatchHandler, redirectionLimitReached: bool) -> RedirectHandler;
}

impl RefCounted {
    extern "js" fn unref(self) -> RefCounted;
    extern "js" fn ref_(self) -> RefCounted;
}

impl RegisterHooksOptions {
    #[getter]
    #[setter]
    extern "js" load: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" resolve: Option<Option<JsValue>>;
}

impl RegisterOptions {
    #[getter]
    #[setter]
    extern "js" parentURL: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" transferList: Option<Option<JsArray<JsValue>>>;
}

impl RegistrationOptions {
    #[getter]
    #[setter]
    extern "js" varargs: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" deterministic: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" safeIntegers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" directOnly: Option<Option<bool>>;
}

impl ReleaseObjectGroupParameterType {
    #[getter]
    #[setter]
    extern "js" objectGroup: String;
}

impl ReleaseObjectParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
}

impl RemoteInfo {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" size: f64;
}

impl RemoteObject {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" className: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" value: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" unserializableValue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" preview: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" customPreview: Option<Option<CustomPreview>>;
}

impl RemoveBreakpointParameterType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
}

impl ReplOptions {
    #[getter]
    #[setter]
    extern "js" prompt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<Option<ReadableStream>>;
    #[getter]
    #[setter]
    extern "js" output: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" terminal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" eval: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" preview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useColors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useGlobal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ignoreUndefined: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writer: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" completer: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" replMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" breakEvalOnSigint: Option<Option<bool>>;
}

impl ReportHeapSnapshotProgressEventDataType {
    #[getter]
    #[setter]
    extern "js" done: f64;
    #[getter]
    #[setter]
    extern "js" total: f64;
    #[getter]
    #[setter]
    extern "js" finished: Option<Option<bool>>;
}

impl ReporterConstructorWrapper {
    // constructor
    extern "js" fn new_(args: JsValue) -> JsValue;
}

impl Request {
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
    #[getter]
    #[setter]
    extern "js" hasPostData: bool;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" completed: bool;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: JsValue;

    // property (readonly)
    extern "js" fn integrity(self) -> String;
    // property (readonly)
    extern "js" fn headers(self) -> Headers;
    // property (readonly)
    extern "js" fn credentials(self) -> String;
    // property (readonly)
    extern "js" fn referrerPolicy(self) -> String;
    // property (readonly)
    extern "js" fn mode(self) -> String;
    // property (readonly)
    extern "js" fn method(self) -> String;
    // property (readonly)
    extern "js" fn duplex(self) -> String;
    // property (readonly)
    extern "js" fn redirect(self) -> String;
    // property (readonly)
    extern "js" fn url(self) -> String;
    // property (readonly)
    extern "js" fn keepalive(self) -> bool;
    // property (readonly)
    extern "js" fn signal(self) -> JsValue;
    // property (readonly)
    extern "js" fn referrer(self) -> String;
    // property (readonly)
    extern "js" fn clone(self) -> fn() -> Request;
    // property (readonly)
    extern "js" fn destination(self) -> String;
    extern "js" fn new_(input: JsValue, init: Option<RequestInit>) -> Request;
    // property (readonly)
    extern "js" fn cache(self) -> String;
}

impl RequestAbortedError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl RequestBodyChunkReceivedMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" chunk: Buffer;
}

impl RequestBodyChunkSentMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" chunk: JsValue;
}

impl RequestBodySentMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
}

impl RequestContentLengthMismatchError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl RequestCreateMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
}

impl RequestErrorMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" error: JsValue;
}

impl RequestHeadersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" response: Response;
}

impl RequestInit {
    #[getter]
    #[setter]
    extern "js" body: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" cache: Option<String>;
    #[getter]
    #[setter]
    extern "js" credentials: Option<String>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" duplex: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" integrity: Option<String>;
    #[getter]
    #[setter]
    extern "js" keepalive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" referrer: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrerPolicy: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" window: Option<()>;
    #[getter]
    #[setter]
    extern "js" body: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" cache: Option<String>;
    #[getter]
    #[setter]
    extern "js" credentials: Option<String>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" duplex: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" integrity: Option<String>;
    #[getter]
    #[setter]
    extern "js" keepalive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" redirect: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrer: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrerPolicy: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" window: Option<()>;
}

impl RequestOptions {
    #[getter]
    #[setter]
    extern "js" opaque: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" checkServerIdentity: Option<Option<fn(String, DetailedPeerCertificate) -> Option<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" servername: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;

    // function property
    extern "js" fn onInfo(self) -> Option<fn(JsValue) -> ()>;
}

impl RequestRetryError {
    // property getter
    extern "js" fn statusCode(self) -> f64;
    // property getter
    extern "js" fn headers(self) -> JsValue;
    // property setter
    extern "js" fn set_data(self, value: JsValue);
    // property setter
    extern "js" fn set_headers(self, value: JsValue);
    extern "js" fn new_(message: String, statusCode: f64, headers: Option<JsValue>, body: Option<JsValue>) -> RequestRetryError;
    // property getter
    extern "js" fn data(self) -> JsValue;
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl RequestTrailersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" trailers: JsArray<Buffer>;
}

impl RequestWillBeSentEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" initiator: Initiator;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" wallTime: f64;
}

impl Require {
    #[getter]
    #[setter]
    extern "js" cache: Dict<Module>;
    #[getter]
    #[setter]
    extern "js" extensions: RequireExtensions;
    #[getter]
    #[setter]
    extern "js" main: Option<Module>;
    #[getter]
    #[setter]
    extern "js" resolve: RequireResolve;
}

impl RequireExtensions {
    // function property
    extern "js" fn js_(self) -> fn(Module, String) -> JsValue;
    // function property
    extern "js" fn json(self) -> fn(Module, String) -> JsValue;
    // function property
    extern "js" fn node(self) -> fn(Module, String) -> JsValue;
}

impl RequireResolve {
    extern "js" fn paths(self, request: String) -> Option<JsArray<String>>;
}

impl RequireResolveOptions {
    #[getter]
    #[setter]
    extern "js" paths: Option<Option<JsArray<String>>>;
}

impl ResolveFnOutput {
    #[getter]
    #[setter]
    extern "js" format: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" importAttributes: Option<Option<ImportAttributes>>;
    #[getter]
    #[setter]
    extern "js" shortCircuit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl ResolveHookContext {
    #[getter]
    #[setter]
    extern "js" conditions: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" importAttributes: ImportAttributes;
    #[getter]
    #[setter]
    extern "js" parentURL: Option<String>;
}

impl ResolveOptions {
    #[getter]
    #[setter]
    extern "js" ttl: bool;
}

impl ResolveWithTtlOptions {
    #[getter]
    #[setter]
    extern "js" ttl: bool;
}

impl Resolver {
    // property setter
    extern "js" fn set_resolvePtr(self, value: JsValue);
    // property getter
    extern "js" fn setServers(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveTlsa(self, value: JsValue);
    // property setter
    extern "js" fn set_resolve(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveCaa(self, value: JsValue);
    // property getter
    extern "js" fn resolveMx(self) -> JsValue;
    // property setter
    extern "js" fn set_resolve6(self, value: JsValue);
    // property getter
    extern "js" fn resolve(self) -> JsValue;
    // property getter
    extern "js" fn resolve6(self) -> JsValue;
    // property getter
    extern "js" fn resolveNaptr(self) -> JsValue;
    extern "js" fn new_(options: Option<ResolverOptions>) -> Resolver;
    // property setter
    extern "js" fn set_resolveNs(self, value: JsValue);
    // property getter
    extern "js" fn resolveTxt(self) -> JsValue;
    // property setter
    extern "js" fn set_setServers(self, value: JsValue);
    // property getter
    extern "js" fn resolveSrv(self) -> JsValue;
    // property getter
    extern "js" fn getServers(self) -> JsValue;
    extern "js" fn setLocalAddress(self, ipv4: Option<String>, ipv6: Option<String>);
    // property setter
    extern "js" fn set_resolveAny(self, value: JsValue);
    // property getter
    extern "js" fn resolveAny(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveSoa(self, value: JsValue);
    // property setter
    extern "js" fn set_reverse(self, value: JsValue);
    // property setter
    extern "js" fn set_resolve4(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveCname(self, value: JsValue);
    // property setter
    extern "js" fn set_getServers(self, value: JsValue);
    // property getter
    extern "js" fn resolve4(self) -> JsValue;
    // property getter
    extern "js" fn resolveCname(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveSrv(self, value: JsValue);
    // property getter
    extern "js" fn resolveTlsa(self) -> JsValue;
    // property getter
    extern "js" fn reverse(self) -> JsValue;
    // property getter
    extern "js" fn resolveNs(self) -> JsValue;
    // property getter
    extern "js" fn resolvePtr(self) -> JsValue;
    extern "js" fn cancel(self);
    // property getter
    extern "js" fn resolveCaa(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveMx(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveTxt(self, value: JsValue);
    // property getter
    extern "js" fn resolveSoa(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveNaptr(self, value: JsValue);
}

impl ResolverOptions {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" tries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxTimeout: Option<Option<f64>>;
}

impl ResourceLimits {
    #[getter]
    #[setter]
    extern "js" maxYoungGenerationSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOldGenerationSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" codeRangeSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackSizeMb: Option<Option<f64>>;
}

impl ResourceUsage {
    #[getter]
    #[setter]
    extern "js" fsRead: f64;
    #[getter]
    #[setter]
    extern "js" fsWrite: f64;
    #[getter]
    #[setter]
    extern "js" involuntaryContextSwitches: f64;
    #[getter]
    #[setter]
    extern "js" ipcReceived: f64;
    #[getter]
    #[setter]
    extern "js" ipcSent: f64;
    #[getter]
    #[setter]
    extern "js" majorPageFault: f64;
    #[getter]
    #[setter]
    extern "js" maxRSS: f64;
    #[getter]
    #[setter]
    extern "js" minorPageFault: f64;
    #[getter]
    #[setter]
    extern "js" sharedMemorySize: f64;
    #[getter]
    #[setter]
    extern "js" signalsCount: f64;
    #[getter]
    #[setter]
    extern "js" swappedOut: f64;
    #[getter]
    #[setter]
    extern "js" systemCPUTime: f64;
    #[getter]
    #[setter]
    extern "js" unsharedDataSize: f64;
    #[getter]
    #[setter]
    extern "js" unsharedStackSize: f64;
    #[getter]
    #[setter]
    extern "js" userCPUTime: f64;
    #[getter]
    #[setter]
    extern "js" voluntaryContextSwitches: f64;
}

impl Response {
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
    #[getter]
    #[setter]
    extern "js" mimeType: String;
    #[getter]
    #[setter]
    extern "js" charset: String;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: JsArray<Buffer>;

    // property (readonly)
    extern "js" fn headers(self) -> Headers;
    // property (readonly)
    extern "js" fn statusText(self) -> String;
    extern "js" fn json(data: JsValue, init: Option<ResponseInit>) -> Response;
    // property (readonly)
    extern "js" fn clone(self) -> fn() -> Response;
    extern "js" fn redirect(url: JsValue, status: f64) -> Response;
    // property (readonly)
    extern "js" fn redirected(self) -> bool;
    // property (readonly)
    extern "js" fn ok(self) -> bool;
    extern "js" fn error() -> Response;
    extern "js" fn new_(body: Option<JsValue>, init: Option<ResponseInit>) -> Response;
    // property (readonly)
    extern "js" fn status(self) -> f64;
    // property (readonly)
    extern "js" fn type_(self) -> String;
    // property (readonly)
    extern "js" fn url(self) -> String;
}

impl ResponseContentLengthMismatchError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl ResponseData {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl ResponseError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    extern "js" fn new_(message: String, code: f64, options: JsValue) -> ResponseError;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // property getter
    extern "js" fn body(self) -> JsValue;
    // property getter
    extern "js" fn statusCode(self) -> f64;
    // property setter
    extern "js" fn set_body(self, value: JsValue);
    // property getter
    extern "js" fn headers(self) -> JsValue;
    // property setter
    extern "js" fn set_headers(self, value: JsValue);
    // property getter
    extern "js" fn name(self) -> String;
}

impl ResponseExceededMaxSizeError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl ResponseInit {
    #[getter]
    extern "js" status: Option<f64>;
    #[getter]
    extern "js" statusText: Option<String>;
    #[getter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    extern "js" status: Option<f64>;
    #[getter]
    extern "js" statusText: Option<String>;
    #[getter]
    extern "js" headers: Option<JsValue>;
}

impl ResponseReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" response: Response;
}

impl RestartFrameParameterType {
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
}

impl RestartFrameReturnType {
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
}

impl RetryAgent {
    extern "js" fn new_(dispatcher: Dispatcher, options: Option<RetryOptions>) -> RetryAgent;
}

impl RetryHandler {
    extern "js" fn new_(options: DispatchOptions, retryHandlers: RetryHandlers) -> RetryHandler;
}

impl RetryHandlers {
    #[getter]
    #[setter]
    extern "js" dispatch: JsValue;
    #[getter]
    #[setter]
    extern "js" handler: DispatchHandler;
}

impl RetryOptions {
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" retry: Option<fn(JsValue, JsValue, fn(Option<JsValue>) -> ()) -> ()>;
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" minTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" timeoutFactor: Option<f64>;
    #[getter]
    #[setter]
    extern "js" retryAfter: Option<bool>;
    #[getter]
    #[setter]
    extern "js" methods: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" errorCodes: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" statusCodes: Option<JsArray<f64>>;
}

impl RmDirOptions {
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" retryDelay: Option<Option<f64>>;
}

impl RmOptions {
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" retryDelay: Option<Option<f64>>;
}

impl RsaHashedImportParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaHashedKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" hash: KeyAlgorithm;
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaHashedKeyGenParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaKeyGenParams {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaOaepParams {
    #[getter]
    #[setter]
    extern "js" label: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaOtherPrimesInfo {
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" r: Option<String>;
    #[getter]
    #[setter]
    extern "js" t: Option<String>;
}

impl RsaPrivateKey {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" oaepHash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" oaepLabel: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
}

impl RsaPssParams {
    #[getter]
    #[setter]
    extern "js" saltLength: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl RsaPublicKey {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
}

impl RunOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" files: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" forceExit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" globPatterns: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" inspectPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" isolation: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setup: Option<Option<fn(TestsStream) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" argv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" testNamePatterns: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" testSkipPatterns: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" watch: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shard: Option<Option<TestShard>>;
    #[getter]
    #[setter]
    extern "js" rerunFailuresFilePath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" coverage: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" coverageExcludeGlobs: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" coverageIncludeGlobs: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" lineCoverage: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" branchCoverage: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" functionCoverage: Option<Option<f64>>;
}

impl RunResult {
    #[getter]
    #[setter]
    extern "js" changes: f64;
    #[getter]
    #[setter]
    extern "js" lastInsertRowid: JsValue;
}

impl RunScriptParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
}

impl RunScriptReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl RunningCodeInNewContextOptions {
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" contextName: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextOrigin: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextCodeGeneration: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" displayErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakOnSigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl RunningCodeOptions {
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" displayErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakOnSigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl RunningScriptInNewContextOptions {
    #[getter]
    #[setter]
    extern "js" contextName: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextOrigin: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextCodeGeneration: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" displayErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakOnSigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl RunningScriptOptions {
    #[getter]
    #[setter]
    extern "js" displayErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakOnSigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl SLHDSAKeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl SQLTagStore {
    #[getter]
    extern "js" capacity: f64;
    #[getter]
    extern "js" db: DatabaseSync;

    extern "js" fn clear(self);
    extern "js" fn get(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> Option<JsValue>;
    extern "js" fn size(self) -> f64;
    extern "js" fn iterate(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> Iterator<JsValue>;
    extern "js" fn all(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> JsArray<JsValue>;
    extern "js" fn run(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> StatementResultingChanges;
}

impl SamplingHeapProfile {
    #[getter]
    #[setter]
    extern "js" head: SamplingHeapProfileNode;
}

impl SamplingHeapProfileNode {
    #[getter]
    #[setter]
    extern "js" callFrame: CallFrame;
    #[getter]
    #[setter]
    extern "js" selfSize: f64;
    #[getter]
    #[setter]
    extern "js" children: JsArray<SamplingHeapProfileNode>;
}

impl Scheduler {
    extern "js" fn wait(self, delay: f64, options: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn yield(self) -> JsPromise<()>;
}

impl Scope {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" object: RemoteObject;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" startLocation: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" endLocation: Option<Option<Location>>;
}

impl Script {
    // property getter
    extern "js" fn sourceMapURL(self) -> Option<String>;
    // property setter
    extern "js" fn set_cachedDataProduced(self, value: Option<bool>);
    extern "js" fn createCachedData(self) -> JsValue;
    // property getter
    extern "js" fn cachedDataProduced(self) -> Option<bool>;
    extern "js" fn new_(code: String, options: Option<JsValue>) -> Script;
    extern "js" fn runInContext(self, contextifiedObject: Context, options: Option<RunningScriptOptions>) -> JsValue;
    extern "js" fn runInThisContext(self, options: Option<RunningScriptOptions>) -> JsValue;
    // property setter
    extern "js" fn set_cachedData(self, value: Option<JsValue>);
    extern "js" fn runInNewContext(self, contextObject: Option<JsValue>, options: Option<RunningScriptInNewContextOptions>) -> JsValue;
    // property getter
    extern "js" fn cachedDataRejected(self) -> Option<bool>;
    // property setter
    extern "js" fn set_sourceMapURL(self, value: Option<String>);
    // property setter
    extern "js" fn set_cachedDataRejected(self, value: Option<bool>);
    // property getter
    extern "js" fn cachedData(self) -> Option<JsValue>;
}

impl ScriptCoverage {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" functions: JsArray<FunctionCoverage>;
}

impl ScriptFailedToParseEventDataType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" startLine: f64;
    #[getter]
    #[setter]
    extern "js" startColumn: f64;
    #[getter]
    #[setter]
    extern "js" endLine: f64;
    #[getter]
    #[setter]
    extern "js" endColumn: f64;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" executionContextAuxData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" sourceMapURL: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hasSourceURL: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isModule: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
}

impl ScriptOptions {
    #[getter]
    #[setter]
    extern "js" cachedData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" produceCachedData: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl ScriptParsedEventDataType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" startLine: f64;
    #[getter]
    #[setter]
    extern "js" startColumn: f64;
    #[getter]
    #[setter]
    extern "js" endLine: f64;
    #[getter]
    #[setter]
    extern "js" endColumn: f64;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" executionContextAuxData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" isLiveEdit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" sourceMapURL: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hasSourceURL: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isModule: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
}

impl ScriptPosition {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl ScryptOptions {
    #[getter]
    #[setter]
    extern "js" cost: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" parallelization: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" N: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" r: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" p: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxmem: Option<Option<f64>>;
}

impl SearchInContentParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" query: String;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isRegex: Option<Option<bool>>;
}

impl SearchInContentReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<SearchMatch>;
}

impl SearchMatch {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" lineContent: String;
}

impl SecureClientSessionOptions {
    #[getter]
    #[setter]
    extern "js" maxReservedRemoteStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" createConnection: Option<Option<fn(URL, SessionOptions) -> Duplex>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl SecureContext {
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl SecureContextOptions {
    #[getter]
    #[setter]
    extern "js" ALPNCallback: Option<Option<fn(JsValue) -> Option<String>>>;
    #[getter]
    #[setter]
    extern "js" allowPartialTrustChain: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ca: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cert: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sigalgs: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ciphers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" clientCertEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dhparam: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" ecdhCurve: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" honorCipherOrder: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" key: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" privateKeyEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" privateKeyIdentifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" maxVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" minVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pfx: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" secureOptions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureProtocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sessionIdContext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
}

impl SecureHeapUsage {
    #[getter]
    #[setter]
    extern "js" total: f64;
    #[getter]
    #[setter]
    extern "js" min: f64;
    #[getter]
    #[setter]
    extern "js" used: f64;
    #[getter]
    #[setter]
    extern "js" utilization: f64;
}

impl SecureProxyConnectionError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    extern "js" fn new_(cause: Option<JsValue>, message: Option<String>, options: Option<JsValue>) -> SecureProxyConnectionError;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl SecureServerOptions {
    #[getter]
    #[setter]
    extern "js" allowHTTP1: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" origins: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" streamResetBurst: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" streamResetRate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" Http1IncomingMessage: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http1ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerRequest: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl SecureServerSessionOptions {
    #[getter]
    #[setter]
    extern "js" streamResetBurst: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" streamResetRate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" Http1IncomingMessage: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http1ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerRequest: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl SendMessageToWorkerParameterType {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl SerializeOptions {
    #[getter]
    #[setter]
    extern "js" attached: Option<String>;
}

impl Serializer {
    extern "js" fn writeRawBytes(self, buffer: JsValue);
    extern "js" fn writeValue(self, val: JsValue) -> bool;
    extern "js" fn releaseBuffer(self) -> JsValue;
    extern "js" fn writeUint64(self, hi: f64, lo: f64);
    extern "js" fn transferArrayBuffer(self, id: f64, arrayBuffer: JsValue);
    extern "js" fn writeDouble(self, value: f64);
    extern "js" fn writeUint32(self, value: f64);
    extern "js" fn writeHeader(self);
}

impl Server {
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    extern "js" fn addContext(self, hostname: String, context: JsValue);
    extern "js" fn getTicketKeys(self) -> Buffer<JsValue>;
    extern "js" fn setTicketKeys(self, keys: Buffer);
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, sessionId: Buffer<JsValue>, sessionData: Option<Buffer<JsValue>>, callback: Option<fn() -> ()>) -> bool;
    extern "js" fn setSecureContext(self, options: SecureContextOptions);
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 2 overloads
    extern "js" fn new_(options: TlsOptions, secureConnectionListener: Option<fn(TLSSocket) -> ()>) -> Server;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
}

impl ServerHttp2Session {
    #[getter]
    extern "js" server: JsValue;
    #[getter]
    extern "js" alpnProtocol: Option<Option<String>>;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" connecting: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" encrypted: Option<Option<bool>>;
    #[getter]
    extern "js" localSettings: Settings;
    #[getter]
    extern "js" originSet: Option<Option<JsArray<String>>>;
    #[getter]
    extern "js" pendingSettingsAck: bool;
    #[getter]
    extern "js" remoteSettings: Settings;
    #[getter]
    extern "js" socket: JsValue;
    #[getter]
    extern "js" state: SessionState;
    #[getter]
    extern "js" type_: f64;

    // merged from 3 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>, JsValue) -> ()) -> ServerHttp2Session;
    // merged from 3 overloads
    extern "js" fn once(self, event: String, listener: fn(ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>, JsValue) -> ()) -> ServerHttp2Session;
    extern "js" fn origin(self, origins: JsArray<JsValue>);
    extern "js" fn altsvc(self, alt: String, originOrStream: JsValue);
    // merged from 3 overloads
    extern "js" fn addListener(self, event: String, listener: fn(ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>, JsValue) -> ()) -> ServerHttp2Session;
    // merged from 3 overloads
    extern "js" fn emit(self, event: String, stream: ServerHttp2Stream, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 3 overloads
    extern "js" fn on(self, event: String, listener: fn(ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>, JsValue) -> ()) -> ServerHttp2Session;
    // merged from 3 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(ServerHttp2Session<JsValue, JsValue, JsValue, JsValue>, JsValue) -> ()) -> ServerHttp2Session;
    // inherited from Http2Session
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // inherited from Http2Session
    extern "js" fn settings(self, settings: Settings, callback: Option<fn(Option<JsValue>, Settings, f64) -> ()>);
    // inherited from Http2Session
    extern "js" fn goaway(self, code: Option<f64>, lastStreamID: Option<f64>, opaqueData: Option<JsValue>);
    // inherited from Http2Session
    extern "js" fn setLocalWindowSize(self, windowSize: f64);
    // inherited from Http2Session
    extern "js" fn ping(self, payload: JsValue, callback: Option<fn(Option<JsValue>, f64, JsValue) -> ()>) -> bool;
    // inherited from Http2Session
    extern "js" fn unref(self);
    // inherited from Http2Session
    extern "js" fn ref_(self);
    // inherited from Http2Session
    extern "js" fn destroy(self, error: Option<JsValue>, code: Option<f64>);
    // inherited from Http2Session
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl ServerHttp2Stream {
    #[getter]
    extern "js" headersSent: bool;
    #[getter]
    extern "js" pushAllowed: bool;
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    extern "js" bufferSize: f64;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" endAfterHeaders: bool;
    #[getter]
    extern "js" id: Option<Option<f64>>;
    #[getter]
    extern "js" pending: bool;
    #[getter]
    extern "js" rstCode: f64;
    #[getter]
    extern "js" sentHeaders: OutgoingHttpHeaders;
    #[getter]
    extern "js" sentInfoHeaders: Option<Option<JsArray<OutgoingHttpHeaders>>>;
    #[getter]
    extern "js" sentTrailers: Option<Option<OutgoingHttpHeaders>>;
    #[getter]
    extern "js" session: Option<Http2Session>;
    #[getter]
    extern "js" state: StreamState;

    extern "js" fn additionalHeaders(self, headers: OutgoingHttpHeaders);
    extern "js" fn respond(self, headers: Option<JsValue>, options: Option<ServerStreamResponseOptions>);
    extern "js" fn respondWithFile(self, path: String, headers: Option<OutgoingHttpHeaders>, options: Option<ServerStreamFileResponseOptionsWithError>);
    // merged from 2 overloads
    extern "js" fn pushStream(self, headers: OutgoingHttpHeaders, options: Option<ClientSessionRequestOptions>, callback: Option<fn(Option<JsValue>, ServerHttp2Stream, OutgoingHttpHeaders) -> ()>);
    extern "js" fn respondWithFD(self, fd: JsValue, headers: Option<OutgoingHttpHeaders>, options: Option<ServerStreamFileResponseOptions>);
    // inherited from Http2Stream
    extern "js" fn close(self, code: Option<f64>, callback: Option<fn() -> ()>);
    // inherited from Http2Stream
    extern "js" fn emit(self, event: String, frameType: Option<f64>, errorCode: Option<f64>) -> bool;
    // inherited from Http2Stream
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // inherited from Http2Stream
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // inherited from Http2Stream
    extern "js" fn sendTrailers(self, headers: OutgoingHttpHeaders);
    // inherited from Http2Stream
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // inherited from Http2Stream
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // inherited from Http2Stream
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // inherited from Http2Stream
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // inherited from Http2Stream
    extern "js" fn priority(self, options: JsValue);
}

impl ServerOptions {
    #[getter]
    #[setter]
    extern "js" IncomingMessage: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" joinDuplicateHeaders: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" connectionsCheckingInterval: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" insecureHTTPParser: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requireHostHeader: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uniqueHeaders: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" shouldUpgradeCallback: Option<Option<fn(JsValue) -> bool>>;
    #[getter]
    #[setter]
    extern "js" rejectNonStandardBodyWrites: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" streamResetBurst: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" streamResetRate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" Http1IncomingMessage: Option<Option<Http1Request>>;
    #[getter]
    #[setter]
    extern "js" Http1ServerResponse: Option<Option<Http1Response>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerRequest: Option<Option<Http2Request>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerResponse: Option<Option<Http2Response>>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl ServerOpts {
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" pauseOnConnect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockList: Option<Option<BlockList>>;
}

impl ServerResponse {
    extern "js" fn detachSocket(self, socket: Socket);
    // property getter
    extern "js" fn strictContentLength(self) -> bool;
    extern "js" fn writeProcessing(self, callback: Option<fn() -> ()>);
    // property getter
    extern "js" fn statusCode(self) -> f64;
    // property setter
    extern "js" fn set_strictContentLength(self, value: bool);
    // merged from 2 overloads
    extern "js" fn writeHead(self, statusCode: f64, statusMessage: Option<String>, headers: Option<JsValue>) -> ServerResponse;
    extern "js" fn new_(req: JsValue) -> ServerResponse;
    extern "js" fn assignSocket(self, socket: Socket);
    // property setter
    extern "js" fn set_statusMessage(self, value: String);
    extern "js" fn writeEarlyHints(self, hints: JsValue, callback: Option<fn() -> ()>);
    extern "js" fn writeContinue(self, callback: Option<fn() -> ()>);
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // property getter
    extern "js" fn statusMessage(self) -> String;
}

impl ServerSessionOptions {
    #[getter]
    #[setter]
    extern "js" streamResetBurst: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" streamResetRate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" Http1IncomingMessage: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http1ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerRequest: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerResponse: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl ServerStreamFileResponseOptions {
    #[getter]
    #[setter]
    extern "js" statCheck: Option<Option<fn(Stats, OutgoingHttpHeaders, StatOptions) -> ()>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
}

impl ServerStreamFileResponseOptionsWithError {
    #[getter]
    #[setter]
    extern "js" onError: Option<Option<fn(ErrnoException) -> ()>>;
    #[getter]
    #[setter]
    extern "js" statCheck: Option<Option<fn(Stats, OutgoingHttpHeaders, StatOptions) -> ()>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
}

impl ServerStreamResponseOptions {
    #[getter]
    #[setter]
    extern "js" endStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
}

impl Session {
    extern "js" fn new_() -> Session;
    extern "js" fn connectToMainThread(self);
    extern "js" fn disconnect(self);
    extern "js" fn connect(self);
}

impl SessionOptions {
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl SessionState {
    #[getter]
    #[setter]
    extern "js" effectiveLocalWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" effectiveRecvDataLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" nextStreamID: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" localWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lastProcStreamID: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" remoteWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" outboundQueueSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" deflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" inflateDynamicTableSize: Option<Option<f64>>;
}

impl SetAsyncCallStackDepthParameterType {
    #[getter]
    #[setter]
    extern "js" maxDepth: f64;
}

impl SetAutoAttachParameterType {
    #[getter]
    #[setter]
    extern "js" autoAttach: bool;
    #[getter]
    #[setter]
    extern "js" waitForDebuggerOnStart: bool;
}

impl SetBlackboxPatternsParameterType {
    #[getter]
    #[setter]
    extern "js" patterns: JsArray<String>;
}

impl SetBlackboxedRangesParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" positions: JsArray<ScriptPosition>;
}

impl SetBreakpointByUrlParameterType {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" urlRegex: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" scriptHash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" condition: Option<Option<String>>;
}

impl SetBreakpointByUrlReturnType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" locations: JsArray<Location>;
}

impl SetBreakpointParameterType {
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" condition: Option<Option<String>>;
}

impl SetBreakpointReturnType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" actualLocation: Location;
}

impl SetBreakpointsActiveParameterType {
    #[getter]
    #[setter]
    extern "js" active: bool;
}

impl SetCustomObjectFormatterEnabledParameterType {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl SetPauseOnExceptionsParameterType {
    #[getter]
    #[setter]
    extern "js" state: String;
}

impl SetReturnValueParameterType {
    #[getter]
    #[setter]
    extern "js" newValue: CallArgument;
}

impl SetSamplingIntervalParameterType {
    #[getter]
    #[setter]
    extern "js" interval: f64;
}

impl SetScriptSourceParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" scriptSource: String;
    #[getter]
    #[setter]
    extern "js" dryRun: Option<Option<bool>>;
}

impl SetScriptSourceReturnType {
    #[getter]
    #[setter]
    extern "js" callFrames: Option<Option<JsArray<CallFrame>>>;
    #[getter]
    #[setter]
    extern "js" stackChanged: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl SetSkipAllPausesParameterType {
    #[getter]
    #[setter]
    extern "js" skip: bool;
}

impl SetSourceMapsSupportOptions {
    #[getter]
    #[setter]
    extern "js" nodeModules: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatedCode: Option<Option<bool>>;
}

impl SetVariableValueParameterType {
    #[getter]
    #[setter]
    extern "js" scopeNumber: f64;
    #[getter]
    #[setter]
    extern "js" variableName: String;
    #[getter]
    #[setter]
    extern "js" newValue: CallArgument;
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
}

impl Settings {
    #[getter]
    #[setter]
    extern "js" headerTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" enablePush: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" initialWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxFrameSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" enableConnectProtocol: Option<Option<bool>>;
}

impl Sign {
    extern "js" fn new_() -> Sign;
    // merged from 2 overloads
    extern "js" fn sign(self, privateKey: JsValue, outputFormat: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Sign;
}

impl SignJsonWebKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsonWebKey;
    #[getter]
    #[setter]
    extern "js" format: String;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl SignKeyObjectInput {
    #[getter]
    #[setter]
    extern "js" key: KeyObject;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl SignPrivateKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl SigningOptions {
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl Snapshot {
    #[getter]
    #[setter]
    extern "js" request: JsValue;
    #[getter]
    #[setter]
    extern "js" responses: JsArray<JsValue>;
    #[getter]
    #[setter]
    extern "js" callCount: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: String;
}

impl SnapshotAgent {
    extern "js" fn new_(options: Option<Options>) -> SnapshotAgent;
    extern "js" fn loadSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn clearSnapshots(self);
    extern "js" fn saveSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn resetCallCounts(self);
    extern "js" fn deleteSnapshot(self, requestOpts: JsValue) -> bool;
    extern "js" fn getRecorder(self) -> SnapshotRecorder;
    extern "js" fn getMode(self) -> String;
    extern "js" fn getSnapshotInfo(self, requestOpts: JsValue) -> Option<SnapshotInfo>;
    extern "js" fn replaceSnapshots(self, snapshotData: JsArray<SnapshotData>);
}

impl SnapshotData {
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" snapshot: Snapshot;
}

impl SnapshotInfo {
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" request: JsValue;
    #[getter]
    #[setter]
    extern "js" responseCount: f64;
    #[getter]
    #[setter]
    extern "js" callCount: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: String;
}

impl SnapshotRecorder {
    extern "js" fn destroy(self);
    extern "js" fn findSnapshot(self, requestOpts: JsValue) -> Option<Snapshot>;
    extern "js" fn getSnapshotInfo(self, requestOpts: JsValue) -> Option<SnapshotInfo>;
    extern "js" fn new_(options: Option<Options>) -> SnapshotRecorder;
    extern "js" fn record(self, requestOpts: JsValue, response: JsValue) -> JsPromise<()>;
    extern "js" fn getSnapshots(self) -> JsArray<Snapshot>;
    extern "js" fn loadSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn replaceSnapshots(self, snapshotData: JsArray<SnapshotData>);
    extern "js" fn clear(self);
    extern "js" fn resetCallCounts(self);
    extern "js" fn deleteSnapshot(self, requestOpts: JsValue) -> bool;
    extern "js" fn saveSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn size(self) -> f64;
}

impl SoaRecord {
    #[getter]
    #[setter]
    extern "js" nsname: String;
    #[getter]
    #[setter]
    extern "js" hostmaster: String;
    #[getter]
    #[setter]
    extern "js" serial: f64;
    #[getter]
    #[setter]
    extern "js" refresh: f64;
    #[getter]
    #[setter]
    extern "js" retry: f64;
    #[getter]
    #[setter]
    extern "js" expire: f64;
    #[getter]
    #[setter]
    extern "js" minttl: f64;
}

impl Socket {
    #[getter]
    #[setter]
    extern "js" isTTY: Option<Option<bool>>;
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" readable: bool;
    #[getter]
    #[setter]
    extern "js" writable: bool;

    extern "js" fn setSendBufferSize(self, size: f64);
    extern "js" fn setBroadcast(self, flag: bool);
    // merged from 2 overloads
    extern "js" fn connect(self, port: f64, address: Option<String>, callback: Option<fn() -> ()>);
    extern "js" fn setMulticastInterface(self, multicastInterface: String);
    extern "js" fn setRecvBufferSize(self, size: f64);
    extern "js" fn unref(self) -> Socket;
    // merged from 6 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn getSendQueueSize(self) -> f64;
    extern "js" fn addSourceSpecificMembership(self, sourceAddress: String, groupAddress: String, multicastInterface: Option<String>);
    extern "js" fn address(self) -> AddressInfo;
    extern "js" fn dropSourceSpecificMembership(self, sourceAddress: String, groupAddress: String, multicastInterface: Option<String>);
    extern "js" fn setMulticastLoopback(self, flag: bool) -> bool;
    extern "js" fn close(self, callback: Option<fn() -> ()>) -> Socket;
    extern "js" fn addMembership(self, multicastAddress: String, multicastInterface: Option<String>);
    // merged from 6 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    // merged from 6 overloads
    extern "js" fn send(self, msg: JsValue, offset: f64, length: Option<f64>, port: Option<f64>, address: Option<String>, callback: Option<fn(Option<JsValue>, f64) -> ()>);
    // merged from 4 overloads
    extern "js" fn bind(self, port: Option<f64>, address: Option<String>, callback: Option<fn() -> ()>) -> Socket;
    extern "js" fn getRecvBufferSize(self) -> f64;
    extern "js" fn ref_(self) -> Socket;
    extern "js" fn setTTL(self, ttl: f64) -> f64;
    extern "js" fn getSendBufferSize(self) -> f64;
    // merged from 6 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn disconnect(self);
    extern "js" fn dropMembership(self, multicastAddress: String, multicastInterface: Option<String>);
    extern "js" fn remoteAddress(self) -> AddressInfo;
    // merged from 6 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    // merged from 6 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn setMulticastTTL(self, ttl: f64) -> f64;
    // merged from 6 overloads
    extern "js" fn emit(self, event: String, msg: Option<Buffer<JsValue>>, rinfo: Option<RemoteInfo>) -> bool;
    extern "js" fn getSendQueueCount(self) -> f64;
    // inherited from ReadableStream
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<String>);
    // inherited from ReadableStream
    extern "js" fn isPaused(self) -> bool;
    // inherited from ReadableStream
    extern "js" fn resume(self) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn pipe(self, destination: JsValue, options: Option<JsValue>) -> JsValue;
    // inherited from ReadableStream
    extern "js" fn setEncoding(self, encoding: String) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    // inherited from ReadableStream
    extern "js" fn pause(self) -> ReadableStream;
    // inherited from ReadableStream
    extern "js" fn wrap(self, oldStream: ReadableStream) -> ReadableStream;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
    // inherited from WritableStream
    extern "js" fn write(self, str: String, encoding: Option<String>, cb: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // inherited from WritableStream
    extern "js" fn end(self, str: String, encoding: Option<String>, cb: Option<fn() -> ()>) -> WritableStream;
}

impl SocketAddress {
    // property (readonly)
    extern "js" fn port(self) -> f64;
    extern "js" fn parse(input: String) -> Option<SocketAddress>;
    // property (readonly)
    extern "js" fn family(self) -> String;
    extern "js" fn new_(options: SocketAddressInitOptions) -> SocketAddress;
    // property (readonly)
    extern "js" fn address(self) -> String;
    // property (readonly)
    extern "js" fn flowlabel(self) -> f64;
}

impl SocketAddressInitOptions {
    #[getter]
    #[setter]
    extern "js" address: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" flowlabel: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
}

impl SocketConstructorOpts {
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onread: Option<Option<OnReadOpts>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SocketError {
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn socket(self) -> Option<SocketInfo>;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_socket(self, value: Option<SocketInfo>);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl SocketInfo {
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesWritten: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesRead: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesWritten: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesRead: Option<f64>;
}

impl SocketOptions {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" reuseAddr: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" reusePort: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ipv6Only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recvBufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sendBufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOneOptions, fn(Option<ErrnoException>, String, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" receiveBlockList: Option<Option<BlockList>>;
    #[getter]
    #[setter]
    extern "js" sendBlockList: Option<Option<BlockList>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SourceMap {
    extern "js" fn findOrigin(self, lineNumber: f64, columnNumber: f64) -> JsValue;
    extern "js" fn new_(payload: SourceMapPayload, options: Option<SourceMapConstructorOptions>) -> SourceMap;
    // property (readonly)
    extern "js" fn payload(self) -> SourceMapPayload;
    extern "js" fn findEntry(self, lineOffset: f64, columnOffset: f64) -> JsValue;
}

impl SourceMapConstructorOptions {
    #[getter]
    #[setter]
    extern "js" lineLengths: Option<Option<JsArray<f64>>>;
}

impl SourceMapPayload {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" version: f64;
    #[getter]
    #[setter]
    extern "js" sources: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" sourcesContent: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" names: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" mappings: String;
    #[getter]
    #[setter]
    extern "js" sourceRoot: String;
}

impl SourceMapping {
    #[getter]
    #[setter]
    extern "js" generatedLine: f64;
    #[getter]
    #[setter]
    extern "js" generatedColumn: f64;
    #[getter]
    #[setter]
    extern "js" originalSource: String;
    #[getter]
    #[setter]
    extern "js" originalLine: f64;
    #[getter]
    #[setter]
    extern "js" originalColumn: f64;
}

impl SourceMapsSupport {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
    #[getter]
    #[setter]
    extern "js" nodeModules: bool;
    #[getter]
    #[setter]
    extern "js" generatedCode: bool;
}

impl SourceOrigin {
    #[getter]
    #[setter]
    extern "js" name: Option<String>;
    #[getter]
    #[setter]
    extern "js" fileName: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl SourceTextModule {
    extern "js" fn hasTopLevelAwait(self) -> bool;
    extern "js" fn linkRequests(self, modules: JsArray<Module>);
    // property (readonly)
    extern "js" fn moduleRequests(self) -> JsArray<ModuleRequest>;
    // property (readonly)
    extern "js" fn dependencySpecifiers(self) -> JsArray<String>;
    extern "js" fn instantiate(self);
    extern "js" fn new_(code: String, options: Option<SourceTextModuleOptions>) -> SourceTextModule;
    extern "js" fn hasAsyncGraph(self) -> bool;
}

impl SourceTextModuleOptions {
    #[getter]
    #[setter]
    extern "js" identifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<Context>>;
    #[getter]
    #[setter]
    extern "js" initializeImportMeta: Option<Option<fn(ImportMeta, SourceTextModule) -> ()>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<Option<fn(String, JsValue, ImportAttributes, JsValue) -> JsValue>>;
}

impl SpawnOptions {
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnOptionsWithStdioTuple {
    #[getter]
    #[setter]
    extern "js" stdio: (JsValue, JsValue, JsValue);
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnOptionsWithoutStdio {
    #[getter]
    #[setter]
    extern "js" stdio: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnSyncOptions {
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SpawnSyncReturns {
    #[getter]
    #[setter]
    extern "js" pid: f64;
    #[getter]
    #[setter]
    extern "js" output: JsArray<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" stdout: JsValue;
    #[getter]
    #[setter]
    extern "js" stderr: JsValue;
    #[getter]
    #[setter]
    extern "js" status: Option<f64>;
    #[getter]
    #[setter]
    extern "js" signal: Option<String>;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
}

impl SpecIterableIterator {
    // inherited from SpecIterator
    extern "js" fn next(self, args: JsValue) -> JsValue;
}

impl SpecIterator {
    extern "js" fn next(self, args: JsValue) -> JsValue;
}

impl SpecReporter {
    extern "js" fn new_() -> SpecReporter;
}

impl SqliteCacheStore {
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
    extern "js" fn new_(opts: Option<SqliteCacheStoreOpts>) -> SqliteCacheStore;
    extern "js" fn get(self, key: CacheKey) -> JsValue;
    extern "js" fn createWriteStream(self, key: CacheKey, value: CacheValue) -> Option<Writable>;
    extern "js" fn close(self);
}

impl SqliteCacheStoreOpts {
    #[getter]
    #[setter]
    extern "js" location: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxCount: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxEntrySize: Option<f64>;
}

impl SqliteErrorClass {
    // property setter
    extern "js" fn set_message(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    extern "js" fn new_(message: String, code: String) -> SqliteErrorClass;
    // property getter
    extern "js" fn message(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
}

impl SrvRecord {
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" weight: f64;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl StackTrace {
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" parent: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" parentId: Option<Option<StackTraceId>>;
}

impl StackTraceId {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" debuggerId: Option<Option<String>>;
}

impl StartParameterType {
    #[getter]
    #[setter]
    extern "js" traceConfig: TraceConfig;
}

impl StartPreciseCoverageParameterType {
    #[getter]
    #[setter]
    extern "js" callCount: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" detailed: Option<Option<bool>>;
}

impl StartSamplingParameterType {
    #[getter]
    #[setter]
    extern "js" samplingInterval: Option<Option<f64>>;
}

impl StartTrackingHeapObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" trackAllocations: Option<Option<bool>>;
}

impl StatFsOptions {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl StatOptions {
    #[getter]
    #[setter]
    extern "js" offset: f64;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl StatSyncOptions {
    #[getter]
    #[setter]
    extern "js" throwIfNoEntry: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" offset: f64;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl StatWatcher {
    extern "js" fn ref_(self) -> StatWatcher;
    extern "js" fn unref(self) -> StatWatcher;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl Statement {
    #[getter]
    #[setter]
    extern "js" database: Database;
    #[getter]
    #[setter]
    extern "js" source: String;
    #[getter]
    #[setter]
    extern "js" reader: bool;
    #[getter]
    #[setter]
    extern "js" readonly_: bool;
    #[getter]
    #[setter]
    extern "js" busy: bool;

    extern "js" fn all(self, params: JsValue) -> JsArray<JsValue>;
    extern "js" fn run(self, params: JsValue) -> RunResult;
    extern "js" fn bind(self, params: JsValue) -> Statement;
    extern "js" fn get(self, params: JsValue) -> Option<JsValue>;
    extern "js" fn safeIntegers(self, toggleState: Option<bool>) -> Statement;
    extern "js" fn columns(self) -> JsArray<ColumnDefinition>;
    extern "js" fn iterate(self, params: JsValue) -> JsValue;
    extern "js" fn raw(self, toggleState: Option<bool>) -> Statement;
    extern "js" fn pluck(self, toggleState: Option<bool>) -> Statement;
    extern "js" fn expand(self, toggleState: Option<bool>) -> Statement;
}

impl StatementColumnMetadata {
    #[getter]
    #[setter]
    extern "js" column: Option<String>;
    #[getter]
    #[setter]
    extern "js" database: Option<String>;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" table: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
}

impl StatementResultingChanges {
    #[getter]
    #[setter]
    extern "js" changes: JsValue;
    #[getter]
    #[setter]
    extern "js" lastInsertRowid: JsValue;
}

impl StatementSync {
    // merged from 2 overloads
    extern "js" fn all(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> JsArray<JsValue>;
    extern "js" fn new_() -> StatementSync;
    extern "js" fn setAllowUnknownNamedParameters(self, enabled: bool);
    extern "js" fn setReadBigInts(self, enabled: bool);
    extern "js" fn columns(self) -> JsArray<StatementColumnMetadata>;
    // property (readonly)
    extern "js" fn expandedSQL(self) -> String;
    // merged from 2 overloads
    extern "js" fn get(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> Option<JsValue>;
    // merged from 2 overloads
    extern "js" fn run(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> StatementResultingChanges;
    extern "js" fn setAllowBareNamedParameters(self, enabled: bool);
    extern "js" fn setReturnArrays(self, enabled: bool);
    // property (readonly)
    extern "js" fn sourceSQL(self) -> String;
    // merged from 2 overloads
    extern "js" fn iterate(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> Iterator<JsValue>;
}

impl StaticEventEmitterIteratorOptions {
    #[getter]
    #[setter]
    extern "js" close: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lowWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl StaticEventEmitterOptions {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl Stats {
    #[getter]
    #[setter]
    extern "js" dev: T;
    #[getter]
    #[setter]
    extern "js" ino: T;
    #[getter]
    #[setter]
    extern "js" mode: T;
    #[getter]
    #[setter]
    extern "js" nlink: T;
    #[getter]
    #[setter]
    extern "js" uid: T;
    #[getter]
    #[setter]
    extern "js" gid: T;
    #[getter]
    #[setter]
    extern "js" rdev: T;
    #[getter]
    #[setter]
    extern "js" size: T;
    #[getter]
    #[setter]
    extern "js" blksize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" atimeMs: T;
    #[getter]
    #[setter]
    extern "js" mtimeMs: T;
    #[getter]
    #[setter]
    extern "js" ctimeMs: T;
    #[getter]
    #[setter]
    extern "js" birthtimeMs: T;
    #[getter]
    #[setter]
    extern "js" atime: JsValue;
    #[getter]
    #[setter]
    extern "js" mtime: JsValue;
    #[getter]
    #[setter]
    extern "js" ctime: JsValue;
    #[getter]
    #[setter]
    extern "js" birthtime: JsValue;

    extern "js" fn new_() -> Stats;
    // inherited from StatsBase
    extern "js" fn isSymbolicLink(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isFIFO(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isSocket(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isBlockDevice(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isFile(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isDirectory(self) -> bool;
    // inherited from StatsBase
    extern "js" fn isCharacterDevice(self) -> bool;
}

impl StatsBase {
    #[getter]
    #[setter]
    extern "js" dev: JsValue;
    #[getter]
    #[setter]
    extern "js" ino: JsValue;
    #[getter]
    #[setter]
    extern "js" mode: JsValue;
    #[getter]
    #[setter]
    extern "js" nlink: JsValue;
    #[getter]
    #[setter]
    extern "js" uid: JsValue;
    #[getter]
    #[setter]
    extern "js" gid: JsValue;
    #[getter]
    #[setter]
    extern "js" rdev: JsValue;
    #[getter]
    #[setter]
    extern "js" size: JsValue;
    #[getter]
    #[setter]
    extern "js" blksize: JsValue;
    #[getter]
    #[setter]
    extern "js" blocks: JsValue;
    #[getter]
    #[setter]
    extern "js" atimeMs: JsValue;
    #[getter]
    #[setter]
    extern "js" mtimeMs: JsValue;
    #[getter]
    #[setter]
    extern "js" ctimeMs: JsValue;
    #[getter]
    #[setter]
    extern "js" birthtimeMs: JsValue;
    #[getter]
    #[setter]
    extern "js" atime: JsValue;
    #[getter]
    #[setter]
    extern "js" mtime: JsValue;
    #[getter]
    #[setter]
    extern "js" ctime: JsValue;
    #[getter]
    #[setter]
    extern "js" birthtime: JsValue;

    extern "js" fn isSymbolicLink(self) -> bool;
    extern "js" fn isFIFO(self) -> bool;
    extern "js" fn isSocket(self) -> bool;
    extern "js" fn isBlockDevice(self) -> bool;
    extern "js" fn isFile(self) -> bool;
    extern "js" fn isDirectory(self) -> bool;
    extern "js" fn isCharacterDevice(self) -> bool;
}

impl StatsFs {
    #[getter]
    #[setter]
    extern "js" type_: T;
    #[getter]
    #[setter]
    extern "js" bsize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" bfree: T;
    #[getter]
    #[setter]
    extern "js" bavail: T;
    #[getter]
    #[setter]
    extern "js" files: T;
    #[getter]
    #[setter]
    extern "js" ffree: T;
}

impl StatsFsBase {
    #[getter]
    #[setter]
    extern "js" type_: JsValue;
    #[getter]
    #[setter]
    extern "js" bsize: JsValue;
    #[getter]
    #[setter]
    extern "js" blocks: JsValue;
    #[getter]
    #[setter]
    extern "js" bfree: JsValue;
    #[getter]
    #[setter]
    extern "js" bavail: JsValue;
    #[getter]
    #[setter]
    extern "js" files: JsValue;
    #[getter]
    #[setter]
    extern "js" ffree: JsValue;
}

impl StepIntoParameterType {
    #[getter]
    #[setter]
    extern "js" breakOnAsyncCall: Option<Option<bool>>;
}

impl StopReturnType {
    #[getter]
    #[setter]
    extern "js" profile: Profile;
}

impl StopSamplingReturnType {
    #[getter]
    #[setter]
    extern "js" profile: SamplingHeapProfile;
}

impl StopTrackingHeapObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" reportProgress: Option<Option<bool>>;
}

impl Storage {
    #[getter]
    extern "js" length: f64;

    extern "js" fn clear(self);
    extern "js" fn removeItem(self, key: String);
    extern "js" fn setItem(self, key: String, value: String);
    extern "js" fn getItem(self, key: String) -> Option<String>;
    extern "js" fn key(self, index: f64) -> Option<String>;
}

impl Stream {
    extern "js" fn pipe(self, destination: T, options: Option<JsValue>) -> T;
    extern "js" fn compose(self, stream: JsValue, options: Option<JsValue>) -> T;
}

impl StreamData {
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
}

impl StreamFactoryData {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl StreamOptions {
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
}

impl StreamPipeOptions {
    #[getter]
    #[setter]
    extern "js" preventAbort: Option<bool>;
    #[getter]
    #[setter]
    extern "js" preventCancel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" preventClose: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
}

impl StreamResourceContentParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl StreamResourceContentReturnType {
    #[getter]
    #[setter]
    extern "js" bufferedData: String;
}

impl StreamState {
    #[getter]
    #[setter]
    extern "js" localWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" state: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" localClose: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" remoteClose: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sumDependencyWeight: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" weight: Option<Option<f64>>;
}

impl StringDecoder {
    extern "js" fn end(self, buffer: Option<JsValue>) -> String;
    extern "js" fn write(self, buffer: JsValue) -> String;
    extern "js" fn new_(encoding: Option<JsValue>) -> StringDecoder;
}

impl StringifyOptions {
    #[getter]
    #[setter]
    extern "js" encodeURIComponent: Option<Option<fn(String) -> String>>;
}

impl StripTypeScriptTypesOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sourceMap: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" sourceUrl: Option<Option<String>>;
}

impl StyleTextOptions {
    #[getter]
    #[setter]
    extern "js" validateStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stream: Option<Option<WritableStream>>;
}

impl SubtleCrypto {
    extern "js" fn encapsulateKey(self, encapsulationAlgorithm: JsValue, encapsulationKey: CryptoKey, sharedKeyAlgorithm: JsValue, extractable: bool, usages: JsArray<String>) -> JsPromise<EncapsulatedKey>;
    extern "js" fn sign(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    extern "js" fn decrypt(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    // merged from 2 overloads
    extern "js" fn importKey(self, format: String, keyData: JsonWebKey, algorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    extern "js" fn verify(self, algorithm: JsValue, key: CryptoKey, signature: JsValue, data: JsValue) -> JsPromise<bool>;
    extern "js" fn unwrapKey(self, format: String, wrappedKey: JsValue, unwrappingKey: CryptoKey, unwrapAlgorithm: JsValue, unwrappedKeyAlgorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    extern "js" fn wrapKey(self, format: String, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: JsValue) -> JsPromise<JsValue>;
    extern "js" fn decapsulateKey(self, decapsulationAlgorithm: JsValue, decapsulationKey: CryptoKey, ciphertext: JsValue, sharedKeyAlgorithm: JsValue, extractable: bool, usages: JsArray<String>) -> JsPromise<CryptoKey>;
    // merged from 2 overloads
    extern "js" fn deriveBits(self, algorithm: EcdhKeyDeriveParams, baseKey: CryptoKey, length: Option<Option<f64>>) -> JsPromise<JsValue>;
    extern "js" fn getPublicKey(self, key: CryptoKey, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    // merged from 3 overloads
    extern "js" fn generateKey(self, algorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKeyPair>;
    extern "js" fn encapsulateBits(self, encapsulationAlgorithm: JsValue, encapsulationKey: CryptoKey) -> JsPromise<EncapsulatedBits>;
    extern "js" fn decapsulateBits(self, decapsulationAlgorithm: JsValue, decapsulationKey: CryptoKey, ciphertext: JsValue) -> JsPromise<JsValue>;
    extern "js" fn deriveKey(self, algorithm: JsValue, baseKey: CryptoKey, derivedKeyAlgorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    // merged from 2 overloads
    extern "js" fn exportKey(self, format: String, key: CryptoKey) -> JsPromise<JsonWebKey>;
    extern "js" fn encrypt(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    extern "js" fn digest(self, algorithm: JsValue, data: JsValue) -> JsPromise<JsValue>;
}

impl SuiteContext {
    #[getter]
    extern "js" filePath: Option<String>;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" signal: JsValue;
}

impl SyntheticModule {
    extern "js" fn new_(exportNames: JsArray<String>, evaluateCallback: JsFn, options: Option<SyntheticModuleOptions>) -> SyntheticModule;
    extern "js" fn setExport(self, name: String, value: JsValue);
}

impl SyntheticModuleOptions {
    #[getter]
    #[setter]
    extern "js" identifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<Context>>;
}

impl TLSSocket {
    // property getter
    extern "js" fn authorizationError(self) -> JsValue;
    extern "js" fn renegotiate(self, options: JsValue, callback: fn(Option<JsValue>) -> ()) -> Option<bool>;
    // property getter
    extern "js" fn alpnProtocol(self) -> JsValue;
    extern "js" fn getProtocol(self) -> Option<String>;
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    extern "js" fn enableTrace(self);
    extern "js" fn getPeerX509Certificate(self) -> Option<X509Certificate>;
    extern "js" fn getX509Certificate(self) -> Option<X509Certificate>;
    extern "js" fn getPeerFinished(self) -> Option<Buffer<JsValue>>;
    extern "js" fn getTLSTicket(self) -> Option<Buffer<JsValue>>;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    extern "js" fn getCertificate(self) -> JsValue;
    extern "js" fn exportKeyingMaterial(self, length: f64, label: String, context: Buffer) -> Buffer<JsValue>;
    // property setter
    extern "js" fn set_authorized(self, value: bool);
    extern "js" fn getCipher(self) -> CipherNameAndProtocol;
    // property getter
    extern "js" fn encrypted(self) -> bool;
    // merged from 3 overloads
    extern "js" fn getPeerCertificate(self, detailed: bool) -> DetailedPeerCertificate;
    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // property getter
    extern "js" fn authorized(self) -> bool;
    extern "js" fn setMaxSendFragment(self, size: f64) -> bool;
    // merged from 5 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    extern "js" fn new_(socket: JsValue, options: Option<TLSSocketOptions>) -> TLSSocket;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // property setter
    extern "js" fn set_authorizationError(self, value: JsValue);
    // property setter
    extern "js" fn set_encrypted(self, value: bool);
    extern "js" fn getFinished(self) -> Option<Buffer<JsValue>>;
    extern "js" fn isSessionReused(self) -> bool;
    extern "js" fn getEphemeralKeyInfo(self) -> JsValue;
    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    extern "js" fn getSharedSigalgs(self) -> JsArray<String>;
    extern "js" fn getSession(self) -> Option<Buffer<JsValue>>;
    // property setter
    extern "js" fn set_alpnProtocol(self, value: JsValue);
    extern "js" fn disableRenegotiation(self);
    extern "js" fn setKeyCert(self, context: JsValue);
}

impl TLSSocketOptions {
    #[getter]
    #[setter]
    extern "js" isServer: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" server: Option<Option<Server>>;
    #[getter]
    #[setter]
    extern "js" session: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" requestOCSP: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNCallback: Option<Option<fn(JsValue) -> Option<String>>>;
    #[getter]
    #[setter]
    extern "js" allowPartialTrustChain: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ca: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cert: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sigalgs: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ciphers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" clientCertEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dhparam: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" ecdhCurve: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" honorCipherOrder: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" key: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" privateKeyEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" privateKeyIdentifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" maxVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" minVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pfx: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" secureOptions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureProtocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sessionIdContext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureContext: Option<Option<SecureContext>>;
    #[getter]
    #[setter]
    extern "js" enableTrace: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requestCert: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNProtocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" SNICallback: Option<Option<fn(String, fn(Option<JsValue>, SecureContext) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
}

impl TakeHeapSnapshotParameterType {
    #[getter]
    #[setter]
    extern "js" reportProgress: Option<Option<bool>>;
}

impl TakePreciseCoverageReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<ScriptCoverage>;
}

impl TargetCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" targetInfo: TargetInfo;
}

impl TargetInfo {
    #[getter]
    #[setter]
    extern "js" targetId: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" attached: bool;
    #[getter]
    #[setter]
    extern "js" canAccessOpener: bool;
}

impl TcpNetConnectOpts {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockList: Option<Option<BlockList>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onread: Option<Option<OnReadOpts>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl TcpSocketConnectOpts {
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockList: Option<Option<BlockList>>;
}

impl TestComplete {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestContext {
    #[getter]
    extern "js" assert: TestContextAssert;
    #[getter]
    extern "js" attempt: f64;
    #[getter]
    extern "js" filePath: Option<String>;
    #[getter]
    extern "js" fullName: String;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" signal: JsValue;
    #[getter]
    #[setter]
    extern "js" test: JsValue;
    #[getter]
    extern "js" mock: MockTracker;

    extern "js" fn runOnly(self, shouldRunOnlyTests: bool);
    extern "js" fn skip(self, message: Option<String>);
    extern "js" fn todo(self, message: Option<String>);
    extern "js" fn after(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn plan(self, count: f64, options: Option<TestContextPlanOptions>);
    extern "js" fn afterEach(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn before(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn diagnostic(self, message: String);
    extern "js" fn waitFor(self, condition: fn() -> JsValue, options: Option<TestContextWaitForOptions>) -> JsPromise<JsValue>;
    extern "js" fn beforeEach(self, fn_: Option<JsValue>, options: Option<HookOptions>);
}

impl TestContextAssert {
    extern "js" fn snapshot(self, value: JsValue, options: Option<AssertSnapshotOptions>);
    extern "js" fn fileSnapshot(self, value: JsValue, path: String, options: Option<AssertSnapshotOptions>);
}

impl TestContextPlanOptions {
    #[getter]
    #[setter]
    extern "js" wait: Option<JsValue>;
}

impl TestContextWaitForOptions {
    #[getter]
    #[setter]
    extern "js" interval: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl TestCoverage {
    #[getter]
    #[setter]
    extern "js" summary: JsValue;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
}

impl TestDequeue {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestDiagnostic {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" level: String;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestEnqueue {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestFail {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" plan: Option<Option<f64>>;
}

impl TestPass {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestPlan {
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" count: f64;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestShard {
    #[getter]
    #[setter]
    extern "js" index: f64;
    #[getter]
    #[setter]
    extern "js" total: f64;
}

impl TestStart {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl TestStderr {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl TestStdout {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl TestSummary {
    #[getter]
    #[setter]
    extern "js" counts: JsValue;
    #[getter]
    #[setter]
    extern "js" duration_ms: f64;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" success: bool;
}

impl TestsStream {
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn emit(self, event: String, data: Option<TestCoverage>) -> bool;
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // inherited from Readable
    extern "js" fn _read(self, size: f64);
    // inherited from Readable
    extern "js" fn isDisturbed(stream: JsValue) -> bool;
    // inherited from Readable
    extern "js" fn asIndexedPairs(self, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn take(self, limit: f64, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    // inherited from Readable
    extern "js" fn find(self, fn_: fn(JsValue, JsValue) -> bool, options: Option<ArrayOptions>) -> JsPromise<Option<T>>;
    // inherited from Readable
    extern "js" fn new_(opts: Option<ReadableOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn pause(self) -> Readable;
    // inherited from Readable
    extern "js" fn wrap(self, stream: ReadableStream) -> Readable;
    // inherited from Readable
    extern "js" fn readableObjectMode(self) -> bool;
    // inherited from Readable
    extern "js" fn map(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<JsValue>);
    // inherited from Readable
    extern "js" fn errored(self) -> Option<JsValue>;
    // inherited from Readable
    extern "js" fn every(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    // inherited from Readable
    extern "js" fn closed(self) -> bool;
    // inherited from Readable
    extern "js" fn readableEnded(self) -> bool;
    // inherited from Readable
    extern "js" fn destroyed(self) -> bool;
    // inherited from Readable
    extern "js" fn forEach(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<()>;
    // inherited from Readable
    extern "js" fn toArray(self, options: Option<JsValue>) -> JsPromise<JsArray<JsValue>>;
    // inherited from Readable
    extern "js" fn flatMap(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn drop(self, limit: f64, options: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Readable;
    // inherited from Readable
    extern "js" fn push(self, chunk: JsValue, encoding: Option<JsValue>) -> bool;
    // inherited from Readable
    extern "js" fn filter(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn iterator(self, options: Option<JsValue>) -> AsyncIterator<JsValue>;
    // inherited from Readable
    extern "js" fn toWeb(streamReadable: Readable, options: Option<JsValue>) -> ReadableStream;
    // inherited from Readable
    extern "js" fn readableAborted(self) -> bool;
    // inherited from Readable
    extern "js" fn reduce(self, fn_: fn(JsValue, JsValue, JsValue) -> T, initial: Option<()>, options: Option<JsValue>) -> JsPromise<T>;
    // inherited from Readable
    extern "js" fn from(iterable: JsValue, options: Option<ReadableOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn readableDidRead(self) -> bool;
    // inherited from Readable
    extern "js" fn isPaused(self) -> bool;
    // inherited from Readable
    extern "js" fn readable(self) -> bool;
    // inherited from Readable
    extern "js" fn resume(self) -> Readable;
    // inherited from Readable
    extern "js" fn some(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    // inherited from Readable
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> Readable;
    // inherited from Readable
    extern "js" fn readableLength(self) -> f64;
    // inherited from Readable
    extern "js" fn readableEncoding(self) -> Option<JsValue>;
    // inherited from Readable
    extern "js" fn readableFlowing(self) -> Option<bool>;
    // inherited from Readable
    extern "js" fn readableHighWaterMark(self) -> f64;
    // inherited from Readable
    extern "js" fn fromWeb(readableStream: ReadableStream, options: Option<ReadableOptions>) -> Readable;
    // inherited from Readable
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    // inherited from Readable
    extern "js" fn set_destroyed(self, value: bool);
    // inherited from Readable
    extern "js" fn set_readable(self, value: bool);
    // inherited from Readable
    extern "js" fn setEncoding(self, encoding: JsValue) -> Readable;
    // inherited from Readable
    extern "js" fn destroy(self, error: Option<JsValue>) -> Readable;
    // inherited from Readable
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
}

impl TextDecoder {
    // property (readonly)
    extern "js" fn ignoreBOM(self) -> bool;
    extern "js" fn new_(encoding: Option<String>, options: Option<JsValue>) -> TextDecoder;
    // property (readonly)
    extern "js" fn encoding(self) -> String;
    // property (readonly)
    extern "js" fn fatal(self) -> bool;
    extern "js" fn decode(self, input: Option<JsValue>, options: Option<JsValue>) -> String;
}

impl TextDecoderOptions {
    #[getter]
    #[setter]
    extern "js" fatal: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreBOM: Option<bool>;
}

impl TextDecoderStream {
    #[getter]
    extern "js" encoding: String;
    #[getter]
    extern "js" fatal: bool;
    #[getter]
    extern "js" ignoreBOM: bool;
    #[getter]
    extern "js" readable: ReadableStream<String>;
    #[getter]
    extern "js" writable: WritableStream<JsValue>;
}

impl TextEncoder {
    extern "js" fn encodeInto(self, src: String, dest: JsValue) -> EncodeIntoResult;
    // property (readonly)
    extern "js" fn encoding(self) -> String;
    extern "js" fn encode(self, input: Option<String>) -> JsValue;
}

impl TextEncoderStream {
    #[getter]
    extern "js" encoding: String;
    #[getter]
    extern "js" readable: ReadableStream<JsValue>;
    #[getter]
    extern "js" writable: WritableStream<String>;
}

impl Timeout {
    extern "js" fn close(self) -> Timeout;
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn ref_(self) -> Timeout;
    extern "js" fn _onTimeout(self, args: JsArray<JsValue>);
    extern "js" fn unref(self) -> Timeout;
    extern "js" fn refresh(self) -> Timeout;
}

impl Timer {
    extern "js" fn refresh(self) -> Timer;
    extern "js" fn hasRef(self) -> bool;
    // inherited from RefCounted
    extern "js" fn unref(self) -> RefCounted;
    // inherited from RefCounted
    extern "js" fn ref_(self) -> RefCounted;
}

impl TimerOptions {
    #[getter]
    #[setter]
    extern "js" ref_: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl TimerifyOptions {
    #[getter]
    #[setter]
    extern "js" histogram: Option<Option<RecordableHistogram>>;
}

impl TlsOptions {
    #[getter]
    #[setter]
    extern "js" handshakeTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" pskCallback: Option<Option<fn(TLSSocket, String) -> Option<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" pskIdentityHint: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ALPNCallback: Option<Option<fn(JsValue) -> Option<String>>>;
    #[getter]
    #[setter]
    extern "js" allowPartialTrustChain: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ca: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cert: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sigalgs: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ciphers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" clientCertEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dhparam: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" ecdhCurve: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" honorCipherOrder: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" key: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" privateKeyEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" privateKeyIdentifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" maxVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" minVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pfx: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" secureOptions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureProtocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sessionIdContext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" secureContext: Option<Option<SecureContext>>;
    #[getter]
    #[setter]
    extern "js" enableTrace: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requestCert: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNProtocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" SNICallback: Option<Option<fn(String, fn(Option<JsValue>, SecureContext) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
}

impl TlsaRecord {
    #[getter]
    #[setter]
    extern "js" certUsage: f64;
    #[getter]
    #[setter]
    extern "js" selector: f64;
    #[getter]
    #[setter]
    extern "js" match_: f64;
    #[getter]
    #[setter]
    extern "js" data: JsValue;
}

impl TraceConfig {
    #[getter]
    #[setter]
    extern "js" recordMode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includedCategories: JsArray<String>;
}

impl Tracing {
    #[getter]
    extern "js" categories: String;
    #[getter]
    extern "js" enabled: bool;

    extern "js" fn disable(self);
    extern "js" fn enable(self);
}

impl TracingChannel {
    // property setter
    extern "js" fn set_start(self, value: Channel<JsValue, JsValue>);
    // property getter
    extern "js" fn asyncStart(self) -> Channel<JsValue, JsValue>;
    // property getter
    extern "js" fn asyncEnd(self) -> Channel<JsValue, JsValue>;
    // property getter
    extern "js" fn start(self) -> Channel<JsValue, JsValue>;
    // property setter
    extern "js" fn set_end(self, value: Channel<JsValue, JsValue>);
    extern "js" fn traceCallback(self, fn_: JsFn, position: Option<f64>, context: Option<JsValue>, thisArg: Option<ThisArg>, args: Args) -> Result;
    // property getter
    extern "js" fn end(self) -> Channel<JsValue, JsValue>;
    extern "js" fn traceSync(self, fn_: JsFn, context: Option<JsValue>, thisArg: Option<ThisArg>, args: Args) -> Result;
    extern "js" fn unsubscribe(self, subscribers: TracingChannelSubscribers<JsValue>);
    // property setter
    extern "js" fn set_asyncStart(self, value: Channel<JsValue, JsValue>);
    // property setter
    extern "js" fn set_asyncEnd(self, value: Channel<JsValue, JsValue>);
    extern "js" fn subscribe(self, subscribers: TracingChannelSubscribers<JsValue>);
    // property getter
    extern "js" fn error(self) -> Channel<JsValue, JsValue>;
    // property setter
    extern "js" fn set_error(self, value: Channel<JsValue, JsValue>);
    // property (readonly)
    extern "js" fn hasSubscribers(self) -> bool;
    extern "js" fn tracePromise(self, fn_: JsFn, context: Option<JsValue>, thisArg: Option<ThisArg>, args: Args) -> JsPromise<Result>;
}

impl TracingChannelCollection {
    #[getter]
    #[setter]
    extern "js" start: Channel<JsValue, JsValue>;
    #[getter]
    #[setter]
    extern "js" end: Channel<JsValue, JsValue>;
    #[getter]
    #[setter]
    extern "js" asyncStart: Channel<JsValue, JsValue>;
    #[getter]
    #[setter]
    extern "js" asyncEnd: Channel<JsValue, JsValue>;
    #[getter]
    #[setter]
    extern "js" error: Channel<JsValue, JsValue>;
}

impl TracingChannelSubscribers {
    // function property
    extern "js" fn end(self) -> fn(JsValue) -> ();
    // function property
    extern "js" fn start(self) -> fn(JsValue) -> ();
    // function property
    extern "js" fn asyncStart(self) -> fn(JsValue) -> ();
    // function property
    extern "js" fn asyncEnd(self) -> fn(JsValue) -> ();
    // function property
    extern "js" fn error(self) -> fn(JsValue) -> ();
}

impl Transaction {
    extern "js" fn default_(self, params: JsValue) -> JsValue;
    extern "js" fn deferred(self, params: JsValue) -> JsValue;
    extern "js" fn immediate(self, params: JsValue) -> JsValue;
    extern "js" fn exclusive(self, params: JsValue) -> JsValue;
}

impl Transform {
    extern "js" fn new_(opts: Option<TransformOptions>) -> Transform;
    extern "js" fn _flush(self, callback: fn(Option<JsValue>, JsValue) -> ());
    extern "js" fn _transform(self, chunk: JsValue, encoding: JsValue, callback: fn(Option<JsValue>, JsValue) -> ());
}

impl TransformOptions {
    #[getter]
    #[setter]
    extern "js" transform: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableCorked: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" read: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" decodeStrings: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultEncoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" write: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" writev: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" final: Option<Option<JsFn>>;
}

impl TransformStream {
    #[getter]
    extern "js" readable: ReadableStream<JsValue>;
    #[getter]
    extern "js" writable: WritableStream<JsValue>;
}

impl TransformStreamDefaultController {
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn terminate(self);
    extern "js" fn enqueue(self, chunk: Option<JsValue>);
    extern "js" fn error(self, reason: Option<JsValue>);
}

impl Transformer {
    #[getter]
    #[setter]
    extern "js" flush: Option<TransformerFlushCallback<JsValue>>;
    #[getter]
    #[setter]
    extern "js" readableType: Option<()>;
    #[getter]
    #[setter]
    extern "js" start: Option<TransformerStartCallback<JsValue>>;
    #[getter]
    #[setter]
    extern "js" transform: Option<TransformerTransformCallback<JsValue, JsValue>>;
    #[getter]
    #[setter]
    extern "js" cancel: Option<TransformerCancelCallback>;
    #[getter]
    #[setter]
    extern "js" writableType: Option<()>;
}

impl URL {
    // property setter
    extern "js" fn set_href(self, value: String);
    // property setter
    extern "js" fn set_pathname(self, value: String);
    // property setter
    extern "js" fn set_hash(self, value: String);
    extern "js" fn canParse(input: String, base: Option<String>) -> bool;
    // property getter
    extern "js" fn href(self) -> String;
    // property setter
    extern "js" fn set_username(self, value: String);
    // property getter
    extern "js" fn host(self) -> String;
    // property setter
    extern "js" fn set_protocol(self, value: String);
    extern "js" fn toString(self) -> String;
    // property getter
    extern "js" fn port(self) -> String;
    // property getter
    extern "js" fn username(self) -> String;
    // property getter
    extern "js" fn search(self) -> String;
    // property setter
    extern "js" fn set_port(self, value: String);
    // property setter
    extern "js" fn set_hostname(self, value: String);
    // property setter
    extern "js" fn set_password(self, value: String);
    // property getter
    extern "js" fn protocol(self) -> String;
    // property (readonly)
    extern "js" fn origin(self) -> String;
    extern "js" fn revokeObjectURL(id: String);
    // property setter
    extern "js" fn set_host(self, value: String);
    // property getter
    extern "js" fn pathname(self) -> String;
    extern "js" fn new_(input: JsValue, base: Option<JsValue>) -> URL;
    // property getter
    extern "js" fn hash(self) -> String;
    // property getter
    extern "js" fn password(self) -> String;
    // property (readonly)
    extern "js" fn searchParams(self) -> URLSearchParams;
    // property setter
    extern "js" fn set_search(self, value: String);
    extern "js" fn createObjectURL(blob: JsValue) -> String;
    extern "js" fn parse(input: String, base: Option<String>) -> Option<URL>;
    // property getter
    extern "js" fn hostname(self) -> String;
    extern "js" fn toJSON(self) -> String;
}

impl URLFormatOptions {
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fragment: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" search: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" unicode: Option<Option<bool>>;
}

impl URLPattern {
    // merged from 2 overloads
    extern "js" fn new_(input: JsValue, baseURL: String, options: Option<URLPatternOptions>) -> URLPattern;
    extern "js" fn test(self, input: Option<JsValue>, baseURL: Option<String>) -> bool;
    extern "js" fn exec(self, input: Option<JsValue>, baseURL: Option<String>) -> Option<URLPatternResult>;
    // property (readonly)
    extern "js" fn hash(self) -> String;
    // property (readonly)
    extern "js" fn hostname(self) -> String;
    // property (readonly)
    extern "js" fn pathname(self) -> String;
    // property (readonly)
    extern "js" fn hasRegExpGroups(self) -> bool;
    // property (readonly)
    extern "js" fn password(self) -> String;
    // property (readonly)
    extern "js" fn port(self) -> String;
    // property (readonly)
    extern "js" fn protocol(self) -> String;
    // property (readonly)
    extern "js" fn search(self) -> String;
    // property (readonly)
    extern "js" fn username(self) -> String;
}

impl URLPatternComponentResult {
    #[getter]
    #[setter]
    extern "js" input: String;
    #[getter]
    #[setter]
    extern "js" groups: JsValue;
}

impl URLPatternInit {
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" username: Option<String>;
    #[getter]
    #[setter]
    extern "js" password: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" baseURL: Option<String>;
}

impl URLPatternOptions {
    #[getter]
    #[setter]
    extern "js" ignoreCase: Option<bool>;
}

impl URLPatternResult {
    #[getter]
    #[setter]
    extern "js" inputs: JsArray<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" username: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" password: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" hostname: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" port: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" pathname: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" search: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" hash: URLPatternComponentResult;
}

impl URLSearchParams {
    extern "js" fn keys(self) -> URLSearchParamsIterator<String>;
    // property (readonly)
    extern "js" fn size(self) -> f64;
    extern "js" fn entries(self) -> URLSearchParamsIterator<(String, String)>;
    extern "js" fn forEach(self, fn_: JsFn, thisArg: Option<TThis>);
    extern "js" fn sort(self);
    extern "js" fn has(self, name: String, value: Option<String>) -> bool;
    extern "js" fn toString(self) -> String;
    extern "js" fn values(self) -> URLSearchParamsIterator<String>;
    extern "js" fn delete(self, name: String, value: Option<String>);
    extern "js" fn append(self, name: String, value: String);
    extern "js" fn get(self, name: String) -> Option<String>;
    extern "js" fn set(self, name: String, value: String);
    extern "js" fn getAll(self, name: String) -> JsArray<String>;
    extern "js" fn new_(init: Option<JsValue>) -> URLSearchParams;
}

impl UVMetrics {
    #[getter]
    extern "js" loopCount: f64;
    #[getter]
    extern "js" events: f64;
    #[getter]
    extern "js" eventsWaiting: f64;
}

impl UnderlyingByteSource {
    #[getter]
    #[setter]
    extern "js" autoAllocateChunkSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" cancel: Option<ReadableStreamErrorCallback>;
    #[getter]
    #[setter]
    extern "js" pull: Option<ReadableByteStreamControllerCallback>;
    #[getter]
    #[setter]
    extern "js" start: Option<ReadableByteStreamControllerCallback>;
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl UnderlyingSink {
    #[getter]
    #[setter]
    extern "js" abort: Option<UnderlyingSinkAbortCallback>;
    #[getter]
    #[setter]
    extern "js" close: Option<UnderlyingSinkCloseCallback>;
    #[getter]
    #[setter]
    extern "js" start: Option<UnderlyingSinkStartCallback>;
    #[getter]
    #[setter]
    extern "js" type_: Option<()>;
    #[getter]
    #[setter]
    extern "js" write: Option<UnderlyingSinkWriteCallback<JsValue>>;
}

impl UnderlyingSource {
    #[getter]
    #[setter]
    extern "js" cancel: Option<UnderlyingSourceCancelCallback>;
    #[getter]
    #[setter]
    extern "js" pull: Option<UnderlyingSourcePullCallback<JsValue>>;
    #[getter]
    #[setter]
    extern "js" start: Option<UnderlyingSourceStartCallback<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<()>;
}

impl UndiciError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl Unzip {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl UpgradeData {
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: JsValue;
}

impl UpgradeOptions {
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
}

impl Url {
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" href: String;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<bool>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
    #[getter]
    #[setter]
    extern "js" query: JsValue;
}

impl UrlObject {
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" href: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" search: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
}

impl UrlWithParsedQuery {
    #[getter]
    #[setter]
    extern "js" query: ParsedUrlQuery;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" href: String;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<bool>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
}

impl UrlWithStringQuery {
    #[getter]
    #[setter]
    extern "js" query: Option<String>;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" href: String;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<bool>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
}

impl UserInfo {
    #[getter]
    #[setter]
    extern "js" username: JsValue;
    #[getter]
    #[setter]
    extern "js" uid: f64;
    #[getter]
    #[setter]
    extern "js" gid: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" homedir: JsValue;
}

impl UserInfoOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
}

impl UserInfoOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: String;
}

impl UserInfoOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl Utf8Stream {
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn writing(self) -> bool;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    extern "js" fn destroy(self);
    extern "js" fn reopen(self, file: JsValue);
    // property (readonly)
    extern "js" fn sync(self) -> bool;
    // property (readonly)
    extern "js" fn fd(self) -> f64;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn mode(self) -> JsValue;
    extern "js" fn end(self);
    // property (readonly)
    extern "js" fn file(self) -> String;
    // property (readonly)
    extern "js" fn maxLength(self) -> f64;
    extern "js" fn flush(self, callback: fn(Option<JsValue>) -> ());
    extern "js" fn flushSync(self);
    // property (readonly)
    extern "js" fn append(self) -> bool;
    extern "js" fn write(self, data: JsValue) -> bool;
    extern "js" fn new_(options: Utf8StreamOptions) -> Utf8Stream;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn mkdir(self) -> bool;
    // property (readonly)
    extern "js" fn contentMode(self) -> String;
    // property (readonly)
    extern "js" fn minLength(self) -> f64;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn fsync(self) -> bool;
    // property (readonly)
    extern "js" fn periodicFlush(self) -> f64;
}

impl Utf8StreamOptions {
    #[getter]
    #[setter]
    extern "js" append: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" contentMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dest: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fsync: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxWrite: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" minLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" mkdir: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" periodicFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" retryEAGAIN: Option<Option<fn(Option<JsValue>, f64, f64) -> bool>>;
    #[getter]
    #[setter]
    extern "js" sync: Option<Option<bool>>;
}

impl Verify {
    extern "js" fn new_() -> Verify;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Verify;
    // merged from 2 overloads
    extern "js" fn verify(self, object: JsValue, signature: String, signature_format: Option<String>) -> bool;
}

impl VerifyJsonWebKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsonWebKey;
    #[getter]
    #[setter]
    extern "js" format: String;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl VerifyKeyObjectInput {
    #[getter]
    #[setter]
    extern "js" key: KeyObject;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl VerifyPublicKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl VirtualTableOptions {
    #[getter]
    #[setter]
    extern "js" columns: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" parameters: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" safeIntegers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" directOnly: Option<Option<bool>>;

    // function property
    extern "js" fn rows(self) -> fn(JsArray<JsValue>) -> JsValue;
}

impl WASI {
    extern "js" fn getImportObject(self) -> JsValue;
    extern "js" fn start(self, instance: JsValue) -> f64;
    extern "js" fn initialize(self, instance: JsValue);
    extern "js" fn finalizeBindings(self, instance: JsValue, options: Option<FinalizeBindingsOptions>);
    // property (readonly)
    extern "js" fn wasiImport(self) -> Dict<JsValue>;
    extern "js" fn new_(options: Option<WASIOptions>) -> WASI;
}

impl WASIOptions {
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" preopens: Option<Option<Dict<String>>>;
    #[getter]
    #[setter]
    extern "js" returnOnExit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdin: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" version: String;
}

impl WatchFileOptions {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" interval: Option<Option<f64>>;
}

impl WatchOptions {
    #[getter]
    #[setter]
    extern "js" maxQueue: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" overflow: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl WatchOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: String;
    #[getter]
    #[setter]
    extern "js" encoding: String;
    #[getter]
    #[setter]
    extern "js" maxQueue: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" overflow: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl WatchOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxQueue: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" overflow: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl WebSocket {
    #[getter]
    #[setter]
    extern "js" binaryType: String;
    #[getter]
    extern "js" bufferedAmount: f64;
    #[getter]
    extern "js" extensions: String;
    #[getter]
    #[setter]
    extern "js" onclose: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onerror: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onmessage: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onopen: Option<JsFn>;
    #[getter]
    extern "js" protocol: String;
    #[getter]
    extern "js" readyState: f64;
    #[getter]
    extern "js" url: String;
    #[getter]
    extern "js" CLOSED: f64;
    #[getter]
    extern "js" CLOSING: f64;
    #[getter]
    extern "js" CONNECTING: f64;
    #[getter]
    extern "js" OPEN: f64;

    // merged from 2 overloads
    extern "js" fn addEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    extern "js" fn send(self, data: JsValue);
    extern "js" fn close(self, code: Option<f64>, reason: Option<String>);
    // merged from 2 overloads
    extern "js" fn removeEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    // inherited from EventTarget
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
}

impl WebSocketCloseInfo {
    #[getter]
    #[setter]
    extern "js" closeCode: f64;
    #[getter]
    #[setter]
    extern "js" reason: String;
}

impl WebSocketClosedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl WebSocketCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" initiator: Initiator;
}

impl WebSocketError {
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" closeCode: f64;
    #[getter]
    #[setter]
    extern "js" reason: String;

    // inherited from Event
    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    // inherited from Event
    extern "js" fn stopPropagation(self);
    // inherited from Event
    extern "js" fn composedPath(self) -> (EventTarget);
    // inherited from Event
    extern "js" fn stopImmediatePropagation(self);
    // inherited from Event
    extern "js" fn preventDefault(self);
}

impl WebSocketEventMap {
    #[getter]
    #[setter]
    extern "js" close: CloseEvent;
    #[getter]
    #[setter]
    extern "js" error: ErrorEvent;
    #[getter]
    #[setter]
    extern "js" message: MessageEvent;
    #[getter]
    #[setter]
    extern "js" open: Event;
}

impl WebSocketHandshakeResponseReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" response: WebSocketResponse;
}

impl WebSocketInit {
    #[getter]
    #[setter]
    extern "js" protocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl WebSocketResponse {
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
}

impl WebSocketStream {
    #[getter]
    #[setter]
    extern "js" closed: JsPromise<WebSocketCloseInfo>;
    #[getter]
    #[setter]
    extern "js" opened: JsPromise<JsValue>;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl WebSocketStreamOptions {
    #[getter]
    #[setter]
    extern "js" protocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
}

impl Worker {
    extern "js" fn kill(self, signal: Option<String>);
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    extern "js" fn isDead(self) -> bool;
    // property setter
    extern "js" fn set_exitedAfterDisconnect(self, value: bool);
    // property setter
    extern "js" fn set_id(self, value: f64);
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // merged from 3 overloads
    extern "js" fn send(self, message: JsValue, sendHandle: JsValue, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    extern "js" fn destroy(self, signal: Option<String>);
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // property getter
    extern "js" fn exitedAfterDisconnect(self) -> bool;
    extern "js" fn disconnect(self) -> Worker;
    extern "js" fn isConnected(self) -> bool;
    // property getter
    extern "js" fn id(self) -> f64;
    // property getter
    extern "js" fn process(self) -> ChildProcess;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // property setter
    extern "js" fn set_process(self, value: ChildProcess);
}

impl WorkerInfo {
    #[getter]
    #[setter]
    extern "js" workerId: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl WorkerOptions {
    #[getter]
    #[setter]
    extern "js" argv: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" env: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" eval: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" workerData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdin: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" resourceLimits: Option<Option<ResourceLimits>>;
    #[getter]
    #[setter]
    extern "js" transferList: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" trackUnmanagedFds: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl WorkerPerformance {
    #[getter]
    #[setter]
    extern "js" eventLoopUtilization: JsValue;
}

impl Writable {
    extern "js" fn fromWeb(writableStream: WritableStream, options: Option<WritableOptions>) -> Writable;
    // property (readonly)
    extern "js" fn writableFinished(self) -> bool;
    // property (readonly)
    extern "js" fn writableCorked(self) -> f64;
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    // property (readonly)
    extern "js" fn errored(self) -> Option<JsValue>;
    extern "js" fn cork(self);
    extern "js" fn toWeb(streamWritable: Writable) -> WritableStream;
    // property (readonly)
    extern "js" fn writable(self) -> bool;
    // property (readonly)
    extern "js" fn closed(self) -> bool;
    // property (readonly)
    extern "js" fn writableNeedDrain(self) -> bool;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 7 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 3 overloads
    extern "js" fn end(self, chunk: JsValue, encoding: Option<JsValue>, cb: Option<fn() -> ()>) -> Writable;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    extern "js" fn setDefaultEncoding(self, encoding: JsValue) -> Writable;
    extern "js" fn _final(self, callback: fn(Option<JsValue>) -> ());
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 2 overloads
    extern "js" fn write(self, chunk: JsValue, encoding: JsValue, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    extern "js" fn destroy(self, error: Option<JsValue>) -> Writable;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, err: Option<JsValue>) -> bool;
    // property (readonly)
    extern "js" fn writableLength(self) -> f64;
    // property (readonly)
    extern "js" fn writableEnded(self) -> bool;
    extern "js" fn new_(opts: Option<WritableOptions>) -> Writable;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Writable;
    extern "js" fn _writev(self, chunks: JsArray<JsValue>, callback: fn(Option<JsValue>) -> ());
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    extern "js" fn uncork(self);
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Writable;
    // property (readonly)
    extern "js" fn writableHighWaterMark(self) -> f64;
    // property (readonly)
    extern "js" fn writableAborted(self) -> bool;
    // property (readonly)
    extern "js" fn writableObjectMode(self) -> bool;
    extern "js" fn _write(self, chunk: JsValue, encoding: JsValue, callback: fn(Option<JsValue>) -> ());
}

impl WritableOptions {
    #[getter]
    #[setter]
    extern "js" decodeStrings: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultEncoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" write: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" writev: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" final: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl WritableStream {
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" writable: bool;

    // merged from 2 overloads
    extern "js" fn write(self, str: String, encoding: Option<String>, cb: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // merged from 3 overloads
    extern "js" fn end(self, str: String, encoding: Option<String>, cb: Option<fn() -> ()>) -> WritableStream;
    // inherited from EventEmitter
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    // inherited from EventEmitter
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn emit(self, eventName: JsValue, args: (JsArray<JsValue>)) -> bool;
    // inherited from EventEmitter
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
    // inherited from EventEmitter
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn getMaxListeners(self) -> f64;
    // inherited from EventEmitter
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    // inherited from EventEmitter
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
}

impl WritableStreamDefaultController {
    extern "js" fn error(self, e: Option<JsValue>);
}

impl WritableStreamDefaultWriter {
    #[getter]
    extern "js" closed: JsPromise<()>;
    #[getter]
    extern "js" desiredSize: Option<f64>;
    #[getter]
    extern "js" ready: JsPromise<()>;

    extern "js" fn abort(self, reason: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn releaseLock(self);
    extern "js" fn write(self, chunk: Option<JsValue>) -> JsPromise<()>;
}

impl WriteOptions {
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<f64>>;
}

impl WriteStream {
    // property getter
    extern "js" fn path(self) -> JsValue;
    // property getter
    extern "js" fn pending(self) -> bool;
    extern "js" fn addListener(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn once(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn prependListener(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn prependOnceListener(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn close(self, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // property getter
    extern "js" fn bytesWritten(self) -> f64;
    // property setter
    extern "js" fn set_path(self, value: JsValue);
    // property setter
    extern "js" fn set_bytesWritten(self, value: f64);
    // property setter
    extern "js" fn set_pending(self, value: bool);
    extern "js" fn on(self, event: K, listener: JsValue) -> WriteStream;
}

impl WriteStreamOptions {
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<CreateWriteStreamFSImplementation>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl WriteVResult {
    #[getter]
    #[setter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" buffers: JsValue;
}

impl X25519KeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl X448KeyPairOptions {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<JsValue>;
}

impl X509Certificate {
    extern "js" fn checkIP(self, ip: String) -> Option<String>;
    extern "js" fn toString(self) -> String;
    // property (readonly)
    extern "js" fn validFrom(self) -> String;
    extern "js" fn verify(self, publicKey: KeyObject) -> bool;
    // property (readonly)
    extern "js" fn ca(self) -> bool;
    // property (readonly)
    extern "js" fn fingerprint256(self) -> String;
    // property (readonly)
    extern "js" fn validFromDate(self) -> JsValue;
    // property (readonly)
    extern "js" fn publicKey(self) -> KeyObject;
    extern "js" fn checkPrivateKey(self, privateKey: KeyObject) -> bool;
    // property (readonly)
    extern "js" fn subject(self) -> String;
    extern "js" fn checkHost(self, name: String, options: Option<X509CheckOptions>) -> Option<String>;
    // property (readonly)
    extern "js" fn issuer(self) -> String;
    // property (readonly)
    extern "js" fn signatureAlgorithmOid(self) -> String;
    // property (readonly)
    extern "js" fn signatureAlgorithm(self) -> Option<String>;
    extern "js" fn new_(buffer: JsValue) -> X509Certificate;
    // property (readonly)
    extern "js" fn serialNumber(self) -> String;
    // property (readonly)
    extern "js" fn raw(self) -> JsValue;
    // property (readonly)
    extern "js" fn validTo(self) -> String;
    // property (readonly)
    extern "js" fn validToDate(self) -> JsValue;
    extern "js" fn toLegacyObject(self) -> PeerCertificate;
    extern "js" fn toJSON(self) -> String;
    // property (readonly)
    extern "js" fn subjectAltName(self) -> Option<String>;
    extern "js" fn checkEmail(self, email: String, options: Option<JsValue>) -> Option<String>;
    // property (readonly)
    extern "js" fn fingerprint512(self) -> String;
    extern "js" fn checkIssued(self, otherCert: X509Certificate) -> bool;
    // property (readonly)
    extern "js" fn fingerprint(self) -> String;
    // property (readonly)
    extern "js" fn infoAccess(self) -> Option<String>;
    // property (readonly)
    extern "js" fn keyUsage(self) -> JsArray<String>;
    // property (readonly)
    extern "js" fn issuerCertificate(self) -> Option<X509Certificate>;
}

impl X509CheckOptions {
    #[getter]
    #[setter]
    extern "js" subject: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" wildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" partialWildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" multiLabelWildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" singleLabelSubdomains: Option<Option<bool>>;
}

impl Zlib {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl ZlibOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowBits: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" level: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" memLevel: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dictionary: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
}

impl ZlibParams {
    extern "js" fn params(self, level: f64, strategy: f64, callback: fn() -> ());
}

impl ZlibReset {
    extern "js" fn reset(self);
}

impl ZstdCompress {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl ZstdDecompress {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // inherited from Zlib
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // inherited from Zlib
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
}

impl ZstdOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" params: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" dictionary: Option<Option<JsValue>>;
}

impl _GlobOptions {
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" withFileTypes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exclude: Option<JsValue>;
}

impl ucs2 {
    extern "js" fn encode(self, codePoints: JsArray<f64>) -> String;
    extern "js" fn decode(self, string: String) -> JsArray<f64>;
}