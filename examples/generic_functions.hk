// Generic functions in Husk - demonstration of parametric polymorphism

// Basic single-parameter generic function
fn identity<T>(x: T) -> T {
    x
}

// Generic higher-order function
fn apply<T, U>(x: T, f: fn(T) -> U) -> U {
    f(x)
}

// Generic function with two params of same type
fn first<T>(a: T, b: T) -> T {
    a
}

// Test basic type inference
fn test_basic_inference() -> i32 {
    let x = identity(42); // T inferred as i32
    x
}

// Test string inference
fn test_string_inference() -> String {
    let s = identity("hello"); // T inferred as String
    s
}

// Test higher-order with closure (explicit param types)
fn test_higher_order() -> i32 {
    let doubled = apply(21, |x: i32| x * 2); // T = i32, U = i32
    doubled
}

// Test chained generic calls
fn test_chained() -> i32 {
    let x = identity(identity(42)); // Nested identity calls
    x
}

// Test first function with same types
fn test_first() -> i32 {
    let x = first(1, 2); // Both args are i32, T = i32
    x
}

// Entry point
fn main() {
    test_basic_inference();
    test_string_inference();
    test_higher_order();
    test_chained();
    test_first();
}
