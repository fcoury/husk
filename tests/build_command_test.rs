use std::fs;
use std::path::Path;
use std::process::Command;
use tempfile::TempDir;

#[test]
fn test_build_command_basic() {
    // Create a temporary directory for the test
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");

    // Get the path to the husk binary
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project using 'husk new'
    let output = Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    assert!(output.status.success(), "husk new failed: {output:?}");

    // Verify project structure was created
    assert!(project_dir.join("husk.toml").exists());
    assert!(project_dir.join("src").exists());
    assert!(project_dir.join("src/main.husk").exists());

    // Run build command
    let output = Command::new(husk_binary)
        .arg("build")
        .current_dir(&project_dir)
        .output()
        .expect("Failed to execute husk build");

    assert!(output.status.success(), "husk build failed: {output:?}");

    // Verify output was created
    assert!(project_dir.join("dist").exists());
    assert!(project_dir.join("dist/main.js").exists());

    // Verify the generated JavaScript contains expected content
    let js_content = fs::read_to_string(project_dir.join("dist/main.js")).unwrap();
    assert!(js_content.contains("function println"));
    assert!(js_content.contains("Hello from Husk!"));

    // Verify package.json was generated by default
    assert!(project_dir.join("package.json").exists());
}

#[test]
fn test_build_command_skip_package_json() {
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project
    Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    // Run build with --skip-package-json
    let output = Command::new(husk_binary)
        .args(["build", "--skip-package-json"])
        .current_dir(&project_dir)
        .output()
        .expect("Failed to execute husk build");

    assert!(output.status.success());

    // Verify package.json was NOT created
    assert!(!project_dir.join("package.json").exists());
}

#[test]
fn test_build_command_generates_package_json_by_default() {
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project
    Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    // Run build without any flags
    let output = Command::new(husk_binary)
        .arg("build")
        .current_dir(&project_dir)
        .output()
        .expect("Failed to execute husk build");

    assert!(output.status.success());

    // Verify package.json was created by default
    assert!(project_dir.join("package.json").exists());

    // Verify package.json content
    let package_json = fs::read_to_string(project_dir.join("package.json")).unwrap();
    assert!(package_json.contains("\"name\": \"test-project\""));
    assert!(package_json.contains("\"version\": \"0.1.0\""));
    assert!(package_json.contains("\"type\": \"module\"")); // ESM by default
}

#[test]
fn test_build_command_with_target_flag() {
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project
    Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    // Test different target flags
    let targets = vec!["node-esm", "node-cjs", "browser"];

    for target in targets {
        // Clean dist directory if it exists
        let dist_dir = project_dir.join("dist");
        if dist_dir.exists() {
            fs::remove_dir_all(&dist_dir).unwrap();
        }

        // Run build with target
        let output = Command::new(husk_binary)
            .args(["build", "--target", target])
            .current_dir(&project_dir)
            .output()
            .expect("Failed to execute husk build");

        assert!(
            output.status.success(),
            "husk build --target {target} failed"
        );

        // Verify output mentions the target
        let stdout = String::from_utf8_lossy(&output.stdout);
        assert!(stdout.contains(&format!("Target: {target}")));

        // Verify JavaScript was generated
        assert!(project_dir.join("dist/main.js").exists());

        // TODO: When target support is implemented, verify target-specific output
        // For now, we just verify the command accepts the flag
    }
}

#[test]
fn test_build_command_custom_directories() {
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project
    Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    // Modify husk.toml to use custom directories
    let husk_toml = project_dir.join("husk.toml");
    let mut config = fs::read_to_string(&husk_toml).unwrap();
    config = config.replace("src = \"src\"", "src = \"custom_src\"");
    config = config.replace("out = \"dist\"", "out = \"custom_out\"");
    fs::write(&husk_toml, config).unwrap();

    // Create custom source directory and move the file
    fs::create_dir(project_dir.join("custom_src")).unwrap();
    fs::rename(
        project_dir.join("src/main.husk"),
        project_dir.join("custom_src/main.husk"),
    )
    .unwrap();
    fs::remove_dir(project_dir.join("src")).unwrap();

    // Run build
    let output = Command::new(husk_binary)
        .arg("build")
        .current_dir(&project_dir)
        .output()
        .expect("Failed to execute husk build");

    assert!(output.status.success());

    // Verify output in custom directory
    assert!(project_dir.join("custom_out").exists());
    assert!(project_dir.join("custom_out/main.js").exists());
}

#[test]
fn test_build_command_multiple_files() {
    let temp_dir = TempDir::new().unwrap();
    let project_dir = temp_dir.path().join("test-project");
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Create a new project
    Command::new(husk_binary)
        .args(["new", "test-project"])
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk new");

    // Create additional Husk files
    fs::write(
        project_dir.join("src/utils.husk"),
        "fn helper() {\n    println!(\"Helper function\");\n}\n",
    )
    .unwrap();

    fs::create_dir(project_dir.join("src/modules")).unwrap();
    fs::write(
        project_dir.join("src/modules/math.husk"),
        "fn pi() -> f64 {\n    return 3.14159;\n}\n",
    )
    .unwrap();

    // Run build
    let output = Command::new(husk_binary)
        .arg("build")
        .current_dir(&project_dir)
        .output()
        .expect("Failed to execute husk build");

    if !output.status.success() {
        eprintln!("Build failed!");
        eprintln!("stdout: {}", String::from_utf8_lossy(&output.stdout));
        eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
    }
    assert!(output.status.success());

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Found 3 Husk files to compile"));

    // Verify all files were compiled
    assert!(project_dir.join("dist/main.js").exists());
    assert!(project_dir.join("dist/utils.js").exists());
    assert!(project_dir.join("dist/modules/math.js").exists());
}

#[test]
fn test_build_command_no_husk_toml() {
    let temp_dir = TempDir::new().unwrap();
    let husk_binary = Path::new(env!("CARGO_BIN_EXE_husk"));

    // Try to build without husk.toml
    let output = Command::new(husk_binary)
        .arg("build")
        .current_dir(temp_dir.path())
        .output()
        .expect("Failed to execute husk build");

    assert!(!output.status.success());

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Could not find husk.toml"));
}
