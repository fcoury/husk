// Auto-generated from .d.ts file
// Some types may be simplified - see warnings below

extern "js" {
    mod express;

    struct AbortController;
    struct AbortSignal;
    struct Abortable;
    struct AddEventListenerOptions;
    struct AddHeapSnapshotChunkEventDataType;
    struct AddInspectedHeapObjectParameterType;
    struct Address;
    struct AddressInfo;
    struct AeadParams;
    struct AesCbcParams;
    struct AesCtrParams;
    struct AesDerivedKeyParams;
    struct AesGcmParams;
    struct AesKeyAlgorithm;
    struct AesKeyGenParams;
    struct After;
    struct Agent;
    struct AgentOptions;
    struct AggregateOptions<T>;
    struct Algorithm;
    struct AlternativeServiceOptions;
    struct AnyARecord;
    struct AnyAaaaRecord;
    struct AnyCaaRecord;
    struct AnyCnameRecord;
    struct AnyMxRecord;
    struct AnyNaptrRecord;
    struct AnyNsRecord;
    struct AnyPtrRecord;
    struct AnySoaRecord;
    struct AnySrvRecord;
    struct AnyTlsaRecord;
    struct AnyTxtRecord;
    struct Application<LocalsObj>;
    struct ApplyChangesetOptions;
    struct Argon2Parameters;
    struct Argon2Params;
    struct ArrayOptions;
    struct Assert;
    struct AssertOptions;
    struct AssertSnapshotOptions;
    struct AssertStrict;
    struct AssertionError;
    struct AssertionErrorOptions;
    struct AsymmetricKeyDetails;
    struct AsyncHook;
    struct AsyncIterator<T, TReturn, TNext>;
    struct AsyncIteratorObject<T, TReturn, TNext>;
    struct AsyncLocalStorage<T>;
    struct AsyncLocalStorageOptions;
    struct AsyncResource;
    struct AsyncResourceOptions;
    struct AttachedToTargetEventDataType;
    struct AttachedToWorkerEventDataType;
    struct AwaitPromiseParameterType;
    struct AwaitPromiseReturnType;
    struct BackupOptions;
    struct BackupProgressInfo;
    struct BalancedPool;
    struct BalancedPoolMissingUpstreamError;
    struct BaseOptions;
    struct BasePrivateKeyEncodingOptions<T>;
    struct Before;
    struct BigIntOptions;
    struct BigIntStats;
    struct BigIntStatsFs;
    struct BindOptions;
    struct Blob;
    struct BlobOptions;
    struct BlockList;
    struct BodyMixin;
    struct BodyReadable;
    struct BodyTimeoutError;
    struct BreakLocation;
    struct BreakpointResolvedEventDataType;
    struct BroadcastChannel;
    struct BrotliCompress;
    struct BrotliDecompress;
    struct BrotliOptions;
    struct Buffer<TArrayBuffer>;
    struct BufferConstructor;
    struct BuiltInModule;
    struct ByteLengthQueuingStrategy;
    struct ByteRange;
    struct CPUProfileHandle;
    struct CShakeParams;
    struct CaaRecord;
    struct Cache;
    struct CacheControlDirectives;
    struct CacheHandlerOptions;
    struct CacheKey;
    struct CacheOptions;
    struct CacheQueryOptions;
    struct CacheStorage;
    struct CacheStore;
    struct CacheValue;
    struct CallArgument;
    struct CallFrame;
    struct CallFunctionOnParameterType;
    struct CallFunctionOnReturnType;
    struct CallSite;
    struct CallSiteObject;
    struct CallTracker;
    struct CallTrackerCall;
    struct CallTrackerReportInformation;
    struct Certificate;
    struct Channel<StoreType, ContextType>;
    struct CheckPrimeOptions;
    struct ChildProcess;
    struct ChildProcessByStdio<I, O, E>;
    struct ChildProcessWithoutNullStreams;
    struct CipherCCM;
    struct CipherCCMOptions;
    struct CipherChaCha20Poly1305;
    struct CipherChaCha20Poly1305Options;
    struct CipherGCM;
    struct CipherGCMOptions;
    struct CipherInfo;
    struct CipherInfoOptions;
    struct CipherNameAndProtocol;
    struct CipherOCB;
    struct CipherOCBOptions;
    struct Cipheriv;
    struct Client;
    struct ClientBeforeConnectMessage;
    struct ClientClosedError;
    struct ClientConnectErrorMessage;
    struct ClientConnectedMessage;
    struct ClientDestroyedError;
    struct ClientHttp2Session;
    struct ClientHttp2Stream;
    struct ClientRequest;
    struct ClientRequestArgs;
    struct ClientSendHeadersMessage;
    struct ClientSessionOptions;
    struct ClientSessionRequestOptions;
    struct ClientStats;
    struct CloseEvent;
    struct CloseEventInit;
    struct CloseParameterType;
    struct Cluster;
    struct ClusterSettings;
    struct CommonConnectionOptions;
    struct CommonExecOptions;
    struct CommonOptions;
    struct CommonSpawnOptions;
    struct CompileFunctionOptions;
    struct CompileScriptParameterType;
    struct CompileScriptReturnType;
    struct ComposedDispatcher;
    struct CompressionStream;
    struct ConnectData<TOpaque>;
    struct ConnectOptions<TOpaque>;
    struct ConnectParams;
    struct ConnectTimeoutError;
    struct ConnectionOptions;
    struct Console;
    struct ConsoleAPICalledEventDataType;
    struct ConsoleConstructor;
    struct ConsoleConstructorOptions;
    struct ConsoleMessage;
    struct ConsoleProfileFinishedEventDataType;
    struct ConsoleProfileStartedEventDataType;
    struct Context;
    struct ContextParams;
    struct ContinueToLocationParameterType;
    struct Control;
    struct Cookie;
    struct CookieOptions;
    struct CopyOptions;
    struct CopyOptionsBase;
    struct CopySyncOptions;
    struct CountQueuingStrategy;
    struct CoverageRange;
    struct CpuInfo;
    struct CpuUsage;
    struct CreateContextOptions;
    struct CreateHistogramOptions;
    struct CreateReadStreamFSImplementation;
    struct CreateReadStreamOptions;
    struct CreateSessionOptions;
    struct CreateTracingOptions;
    struct CreateWriteStreamFSImplementation;
    struct CreateWriteStreamOptions;
    struct Crypto;
    struct CryptoKey;
    struct CryptoKeyPair;
    struct CursorPos;
    struct CustomEvent<T>;
    struct CustomEventInit<T>;
    struct CustomPreview;
    struct CustomPromisifyLegacy<TCustom>;
    struct CustomPromisifySymbol<TCustom>;
    struct DOMException;
    struct DSAKeyPairKeyObjectOptions;
    struct DSAKeyPairOptions<PubF, PrivF>;
    struct DataCollectedEventDataType;
    struct DataReceivedEventDataType;
    struct DatabaseSync;
    struct DatabaseSyncOptions;
    struct DebugLogger;
    struct DecipherCCM;
    struct DecipherChaCha20Poly1305;
    struct DecipherGCM;
    struct DecipherOCB;
    struct Decipheriv;
    struct DecompressionStream;
    struct DecoratorHandler;
    struct DefaultDeserializer;
    struct DefaultSerializer;
    struct Deflate;
    struct DeflateRaw;
    struct DeleteByUri;
    struct Deserializer;
    struct DetachParameterType;
    struct DetachedFromWorkerEventDataType;
    struct DetailedPeerCertificate;
    struct Dict<T>;
    struct Dictionary<T>;
    struct DiffieHellman;
    struct DiffieHellmanGroupConstructor;
    struct Dir;
    struct Dirent<Name>;
    struct DispatchController;
    struct DispatchHandler;
    struct DispatchInterceptor;
    struct DispatchOptions;
    struct Dispatcher;
    struct DisposableTempDir;
    struct Domain;
    struct DownloadOptions;
    struct DropArgument;
    struct Duplex;
    struct DuplexOptions<T>;
    struct ECDH;
    struct ECKeyPairKeyObjectOptions;
    struct ECKeyPairOptions<PubF, PrivF>;
    struct ED25519KeyPairKeyObjectOptions;
    struct ED25519KeyPairOptions<PubF, PrivF>;
    struct ED448KeyPairKeyObjectOptions;
    struct ED448KeyPairOptions<PubF, PrivF>;
    struct EcKeyAlgorithm;
    struct EcKeyGenParams;
    struct EcKeyImportParams;
    struct EcdhKeyDeriveParams;
    struct EcdsaParams;
    struct EmitWarningOptions;
    struct EnableCompileCacheResult;
    struct EnableParameterType;
    struct EnableReturnType;
    struct EncapsulatedBits;
    struct EncapsulatedKey;
    struct EncodeIntoResult;
    struct EntryPreview;
    struct EnvHttpProxyAgent;
    struct EphemeralKeyInfo;
    struct Errback;
    struct ErrnoException;
    struct Error;
    struct ErrorConstructor;
    struct ErrorEvent;
    struct ErrorEventInit;
    struct ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>;
    struct EvaluateOnCallFrameParameterType;
    struct EvaluateOnCallFrameReturnType;
    struct EvaluateParameterType;
    struct EvaluateReturnType;
    struct Event;
    struct EventEmitter<T>;
    struct EventEmitterAsyncResource;
    struct EventEmitterAsyncResourceOptions;
    struct EventEmitterOptions;
    struct EventEmitterReferencingAsyncResource;
    struct EventInit;
    struct EventListener;
    struct EventListenerObject;
    struct EventListenerOptions;
    struct EventLoopMonitorOptions;
    struct EventLoopUtilization;
    struct EventSource;
    struct EventSourceEventMap;
    struct EventSourceInit;
    struct EventTarget;
    struct ExceptionDetails;
    struct ExceptionRevokedEventDataType;
    struct ExceptionThrownEventDataType;
    struct ExecException;
    struct ExecFileOptions;
    struct ExecFileOptionsWithBufferEncoding;
    struct ExecFileOptionsWithOtherEncoding;
    struct ExecFileOptionsWithStringEncoding;
    struct ExecFileSyncOptions;
    struct ExecFileSyncOptionsWithBufferEncoding;
    struct ExecFileSyncOptionsWithStringEncoding;
    struct ExecOptions;
    struct ExecOptionsWithBufferEncoding;
    struct ExecOptionsWithStringEncoding;
    struct ExecSyncOptions;
    struct ExecSyncOptionsWithBufferEncoding;
    struct ExecSyncOptionsWithStringEncoding;
    struct ExecutionContextCreatedEventDataType;
    struct ExecutionContextDescription;
    struct ExecutionContextDestroyedEventDataType;
    struct Express;
    struct FSImplementation;
    struct FSWatcher;
    struct File;
    struct FileChangeInfo<T>;
    struct FileHandle;
    struct FileOptions;
    struct FileReadOptions<T>;
    struct FileReadResult<T>;
    struct FileUrlToPathOptions;
    struct FilterCallsObjectCriteria;
    struct FilterCallsOptions;
    struct FinalizeBindingsOptions;
    struct FinishedOptions;
    struct FlagAndOpenMode;
    struct ForkOptions;
    struct FormData;
    struct FormatInputPathObject;
    struct FunctionCoverage;
    struct FunctionOptions;
    struct GCFunction;
    struct GCOptions;
    struct GCProfiler;
    struct GCProfilerResult;
    struct GeneratePrimeOptions;
    struct GeneratePrimeOptionsArrayBuffer;
    struct GeneratePrimeOptionsBigInt;
    struct GetBestEffortCoverageReturnType;
    struct GetCallSitesOptions;
    struct GetCategoriesReturnType;
    struct GetDomainsReturnType;
    struct GetHeapObjectIdParameterType;
    struct GetHeapObjectIdReturnType;
    struct GetObjectByHeapObjectIdParameterType;
    struct GetObjectByHeapObjectIdReturnType;
    struct GetPossibleBreakpointsParameterType;
    struct GetPossibleBreakpointsReturnType;
    struct GetPropertiesParameterType;
    struct GetPropertiesReturnType;
    struct GetRequestPostDataParameterType;
    struct GetRequestPostDataReturnType;
    struct GetResponseBodyParameterType;
    struct GetResponseBodyReturnType;
    struct GetSamplingProfileReturnType;
    struct GetScriptSourceParameterType;
    struct GetScriptSourceReturnType;
    struct GetStackTraceParameterType;
    struct GetStackTraceReturnType;
    struct GlobOptions;
    struct GlobOptionsWithFileTypes;
    struct GlobOptionsWithoutFileTypes;
    struct GlobalLexicalScopeNamesParameterType;
    struct GlobalLexicalScopeNamesReturnType;
    struct Gunzip;
    struct Gzip;
    struct H2CClient;
    struct HRTime;
    struct HTTP2ServerCommon;
    struct HTTPParserError;
    struct Handler;
    struct Hash;
    struct HashOptions;
    struct Headers;
    struct HeadersOverflowError;
    struct HeadersTimeoutError;
    struct HeapCodeStatistics;
    struct HeapInfo;
    struct HeapProfileHandle;
    struct HeapSnapshotOptions;
    struct HeapSpaceInfo;
    struct HeapSpaceStatistics;
    struct HeapStatistics;
    struct HeapStatsUpdateEventDataType;
    struct Histogram;
    struct HkdfParams;
    struct Hmac;
    struct HmacImportParams;
    struct HmacKeyAlgorithm;
    struct HmacKeyGenParams;
    struct HookCallbacks;
    struct HookOptions;
    struct Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct Http2ServerRequest;
    struct Http2ServerResponse<Request>;
    struct Http2Session;
    struct Http2Stream;
    struct ILayer;
    struct IRoute<Route>;
    struct IRouter;
    struct IRouterHandler<T, Route>;
    struct IRouterMatcher<T, Method>;
    struct Immediate;
    struct ImportAttributes;
    struct ImportMeta;
    struct IncomingHttpHeaders;
    struct IncomingHttpStatusHeader;
    struct IncomingMessage;
    struct Inflate;
    struct InflateRaw;
    struct InformationEvent;
    struct InformationalError;
    struct Init;
    struct Initiator;
    struct InspectOptions;
    struct InspectOptionsStylized;
    struct InspectRequestedEventDataType;
    struct InspectorConsole;
    struct InspectorNotification<T>;
    struct Interceptable;
    struct Interface;
    struct InternalPropertyDescriptor;
    struct IntervalHistogram;
    struct InvalidArgumentError;
    struct InvalidReturnValueError;
    struct IpcNetConnectOpts;
    struct IpcSocketConnectOpts;
    struct IsDeepStrictEqualOptions;
    struct Iterator<T, TReturn, TNext>;
    struct IteratorObject<T, TReturn, TNext>;
    struct JsonWebKey;
    struct JsonWebKeyInput;
    struct JwkKeyExportOptions;
    struct Key;
    struct KeyAlgorithm;
    struct KeyExportOptions<T>;
    struct KeyObject;
    struct KeyPairKeyObjectResult;
    struct KeyPairSyncResult<T1, T2>;
    struct KmacImportParams;
    struct KmacKeyAlgorithm;
    struct KmacKeyGenParams;
    struct KmacParams;
    struct LastSeenObjectIdEventDataType;
    struct LcovReporter;
    struct ListenOptions;
    struct LoadFnOutput;
    struct LoadHookContext;
    struct LoadNetworkResourcePageResult;
    struct LoadNetworkResourceParameterType;
    struct LoadNetworkResourceReturnType;
    struct LoadingFailedEventDataType;
    struct LoadingFinishedEventDataType;
    struct Locals;
    struct Location;
    struct LocationInfo;
    struct Lock;
    struct LockGrantedCallback<T>;
    struct LockInfo;
    struct LockManager;
    struct LockManagerSnapshot;
    struct LockOptions;
    struct LookupAddress;
    struct LookupAllOptions;
    struct LookupOneOptions;
    struct LookupOptions;
    struct MIMEParams;
    struct MIMEType;
    struct MLDSAKeyPairKeyObjectOptions;
    struct MLDSAKeyPairOptions<PubF, PrivF>;
    struct MLKEMKeyPairKeyObjectOptions;
    struct MLKEMKeyPairOptions<PubF, PrivF>;
    struct MakeDirectoryOptions;
    struct MarkOptions;
    struct MaxOriginsReachedError;
    struct MeasureMemoryOptions;
    struct MeasureOptions;
    struct MediaType;
    struct MemoryCacheStore;
    struct MemoryCacheStoreOpts;
    struct MemoryMeasurement;
    struct MemoryUsage;
    struct MemoryUsageFn;
    struct MessageAddedEventDataType;
    struct MessageChannel;
    struct MessageEvent<T>;
    struct MessageEventInit<T>;
    struct MessageOptions;
    struct MessagePort;
    struct MessagingOptions;
    struct MockAgent<TMockAgentOptions>;
    struct MockCallHistory;
    struct MockCallHistoryLog;
    struct MockClient;
    struct MockDispatch<TData, TError>;
    struct MockDispatchData<TData, TError>;
    struct MockFunctionCall<F, ReturnType, Args>;
    struct MockFunctionContext<F>;
    struct MockFunctionOptions;
    struct MockInterceptor;
    struct MockMethodOptions;
    struct MockModuleContext;
    struct MockModuleOptions;
    struct MockNotMatchedError;
    struct MockPool;
    struct MockPropertyContext<PropertyType>;
    struct MockResponseCallbackOptions;
    struct MockResponseOptions;
    struct MockScope<TData>;
    struct MockTimers;
    struct MockTimersOptions;
    struct MockTracker;
    struct Module;
    struct ModuleEvaluateOptions;
    struct ModuleHooks;
    struct ModuleRequest;
    struct MultiCacheQueryOptions;
    struct MxRecord;
    struct NaptrRecord;
    struct Navigator;
    struct NetworkInterfaceBase;
    struct NetworkInterfaceInfoIPv4;
    struct NetworkInterfaceInfoIPv6;
    struct NextFunction;
    struct NodeEventTarget;
    struct NodeGCPerformanceDetail;
    struct NodeModule;
    struct NodeRequire;
    struct NotSupportedError;
    struct NotifyWhenWaitingForDisconnectParameterType;
    struct ObjectEncodingOptions;
    struct ObjectPreview;
    struct OnReadOpts;
    struct OneShotDigestOptions;
    struct OneShotDigestOptionsWithBufferEncoding;
    struct OneShotDigestOptionsWithStringEncoding;
    struct OpenAsBlobOptions;
    struct OpenDirOptions;
    struct Options;
    struct OptionsInterceptors;
    struct OutgoingHttpHeaders;
    struct OutgoingMessage<Request>;
    struct PSKCallbackNegotation;
    struct ParamsDictionary;
    struct ParseArgsConfig;
    struct ParseArgsOptionDescriptor;
    struct ParseArgsOptionsConfig;
    struct ParseOptions;
    struct ParsedPath;
    struct ParsedUrlQuery;
    struct ParsedUrlQueryInput;
    struct PassThrough;
    struct PathToFileUrlOptions;
    struct PauseOnAsyncCallParameterType;
    struct PausedEventDataType;
    struct Pbkdf2Params;
    struct PeerCertificate;
    struct PendingInterceptor;
    struct PendingInterceptorsFormatter;
    struct Performance;
    struct PerformanceEntry;
    struct PerformanceMark;
    struct PerformanceMeasure;
    struct PerformanceNodeTiming;
    struct PerformanceObserver;
    struct PerformanceObserverEntryList;
    struct PerformanceResourceTiming;
    struct Pipe;
    struct PipelineHandlerData<TOpaque>;
    struct PipelineOptions<TOpaque>;
    struct PlatformPath;
    struct Pool;
    struct PoolStats;
    struct PositionTickInfo;
    struct PrivateKeyInput;
    struct Process;
    struct ProcessConfig;
    struct ProcessEnv;
    struct ProcessEnvOptions;
    struct ProcessFeatures;
    struct ProcessPermission;
    struct ProcessRelease;
    struct ProcessReport;
    struct ProcessVersions;
    struct Profile;
    struct ProfileNode;
    struct PromiseHooks;
    struct PromiseWithChild<T>;
    struct PropertyDescriptor;
    struct PropertyPreview;
    struct ProxyAgent;
    struct ProxyEnv;
    struct PublicKeyInput;
    struct PxfObject;
    struct QueryObjectsParameterType;
    struct QueryObjectsReturnType;
    struct QueuingStrategy<T>;
    struct QueuingStrategyInit;
    struct QueuingStrategySize<T>;
    struct REPLCommand;
    struct REPLServer;
    struct REPLServerSetupHistoryOptions;
    struct RSAKeyPairKeyObjectOptions;
    struct RSAKeyPairOptions<PubF, PrivF>;
    struct RSAPSSKeyPairKeyObjectOptions;
    struct RSAPSSKeyPairOptions<PubF, PrivF>;
    struct RandomUUIDOptions;
    struct ReadAsyncOptions<T>;
    struct ReadLineOptions;
    struct ReadOnlyDict<T>;
    struct ReadOptions;
    struct ReadOptionsWithBuffer<T>;
    struct ReadParameterType;
    struct ReadReturnType;
    struct ReadStream;
    struct ReadStreamOptions;
    struct ReadSyncOptions;
    struct ReadVResult<T>;
    struct ReadWriteStream;
    struct Readable;
    struct ReadableByteStreamController;
    struct ReadableByteStreamControllerCallback;
    struct ReadableOptions<T>;
    struct ReadableStream;
    struct ReadableStreamAsyncIterator<T>;
    struct ReadableStreamBYOBReader;
    struct ReadableStreamBYOBRequest;
    struct ReadableStreamDefaultController<R>;
    struct ReadableStreamDefaultReader<R>;
    struct ReadableStreamErrorCallback;
    struct ReadableStreamGenericReader;
    struct ReadableStreamGetReaderOptions;
    struct ReadableStreamReadDoneResult<T>;
    struct ReadableStreamReadValueResult<T>;
    struct ReadableWebStreamOptions;
    struct ReadableWritablePair<R, W>;
    struct Readline;
    struct ReceivedMessageFromWorkerEventDataType;
    struct RecordWithTtl;
    struct RecordableHistogram;
    struct Recoverable;
    struct RedirectHandler;
    struct RefCounted;
    struct RegisterHooksOptions;
    struct RegisterOptions<Data>;
    struct ReleaseObjectGroupParameterType;
    struct ReleaseObjectParameterType;
    struct RemoteInfo;
    struct RemoteObject;
    struct RemoveBreakpointParameterType;
    struct ReplOptions;
    struct ReportHeapSnapshotProgressEventDataType;
    struct ReporterConstructorWrapper<T>;
    struct Request;
    struct RequestAbortedError;
    struct RequestBodyChunkReceivedMessage;
    struct RequestBodyChunkSentMessage;
    struct RequestBodySentMessage;
    struct RequestContentLengthMismatchError;
    struct RequestCreateMessage;
    struct RequestErrorMessage;
    struct RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>;
    struct RequestHandlerConstructor<R>;
    struct RequestHeadersMessage;
    struct RequestInit;
    struct RequestOptions<TOpaque>;
    struct RequestParamHandler;
    struct RequestRanges;
    struct RequestRetryError;
    struct RequestTrailersMessage;
    struct RequestWillBeSentEventDataType;
    struct Require;
    struct RequireExtensions;
    struct RequireResolve;
    struct RequireResolveOptions;
    struct ResolveFnOutput;
    struct ResolveHookContext;
    struct ResolveOptions;
    struct ResolveWithTtlOptions;
    struct Resolver;
    struct ResolverOptions;
    struct ResourceLimits;
    struct ResourceUsage;
    struct Response;
    struct ResponseContentLengthMismatchError;
    struct ResponseData<TOpaque>;
    struct ResponseError;
    struct ResponseExceededMaxSizeError;
    struct ResponseInit;
    struct ResponseReceivedEventDataType;
    struct RestartFrameParameterType;
    struct RestartFrameReturnType;
    struct RetryAgent;
    struct RetryHandler;
    struct RetryHandlers;
    struct RetryOptions;
    struct RmDirOptions;
    struct RmOptions;
    struct Router;
    struct RouterOptions;
    struct RsaHashedImportParams;
    struct RsaHashedKeyAlgorithm;
    struct RsaHashedKeyGenParams;
    struct RsaKeyAlgorithm;
    struct RsaKeyGenParams;
    struct RsaOaepParams;
    struct RsaOtherPrimesInfo;
    struct RsaPrivateKey;
    struct RsaPssParams;
    struct RsaPublicKey;
    struct RunOptions;
    struct RunScriptParameterType;
    struct RunScriptReturnType;
    struct RunningCodeInNewContextOptions;
    struct RunningCodeOptions;
    struct RunningScriptInNewContextOptions;
    struct RunningScriptOptions;
    struct SLHDSAKeyPairKeyObjectOptions;
    struct SLHDSAKeyPairOptions<PubF, PrivF>;
    struct SQLTagStore;
    struct SamplingHeapProfile;
    struct SamplingHeapProfileNode;
    struct Scheduler;
    struct Scope;
    struct Script;
    struct ScriptCoverage;
    struct ScriptFailedToParseEventDataType;
    struct ScriptOptions;
    struct ScriptParsedEventDataType;
    struct ScriptPosition;
    struct ScryptOptions;
    struct SearchInContentParameterType;
    struct SearchInContentReturnType;
    struct SearchMatch;
    struct SecureClientSessionOptions;
    struct SecureContext;
    struct SecureContextOptions;
    struct SecureHeapUsage;
    struct SecureProxyConnectionError;
    struct SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct Send;
    struct SendFileOptions;
    struct SendMessageToWorkerParameterType;
    struct Serializer;
    struct ServeStaticOptions<R>;
    struct Server<Request, Response>;
    struct ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct ServerHttp2Stream;
    struct ServerOptions<Request, Response>;
    struct ServerOpts;
    struct ServerResponse<Request>;
    struct ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>;
    struct ServerStreamFileResponseOptions;
    struct ServerStreamFileResponseOptionsWithError;
    struct ServerStreamResponseOptions;
    struct Session;
    struct SessionOptions;
    struct SessionState;
    struct SetAsyncCallStackDepthParameterType;
    struct SetAutoAttachParameterType;
    struct SetBlackboxPatternsParameterType;
    struct SetBlackboxedRangesParameterType;
    struct SetBreakpointByUrlParameterType;
    struct SetBreakpointByUrlReturnType;
    struct SetBreakpointParameterType;
    struct SetBreakpointReturnType;
    struct SetBreakpointsActiveParameterType;
    struct SetCustomObjectFormatterEnabledParameterType;
    struct SetPauseOnExceptionsParameterType;
    struct SetReturnValueParameterType;
    struct SetSamplingIntervalParameterType;
    struct SetScriptSourceParameterType;
    struct SetScriptSourceReturnType;
    struct SetSkipAllPausesParameterType;
    struct SetSourceMapsSupportOptions;
    struct SetVariableValueParameterType;
    struct Settings;
    struct Settled;
    struct Sign;
    struct SignJsonWebKeyInput;
    struct SignKeyObjectInput;
    struct SignPrivateKeyInput;
    struct SigningOptions;
    struct Snapshot;
    struct SnapshotAgent;
    struct SnapshotData;
    struct SnapshotInfo;
    struct SnapshotRecorder;
    struct SoaRecord;
    struct Socket;
    struct SocketAddress;
    struct SocketAddressInitOptions;
    struct SocketConstructorOpts;
    struct SocketError;
    struct SocketInfo;
    struct SocketOptions;
    struct SourceMap;
    struct SourceMapConstructorOptions;
    struct SourceMapPayload;
    struct SourceMapping;
    struct SourceMapsSupport;
    struct SourceOrigin;
    struct SourceTextModule;
    struct SourceTextModuleOptions;
    struct SpawnOptions;
    struct SpawnOptionsWithStdioTuple<Stdin, Stdout, Stderr>;
    struct SpawnOptionsWithoutStdio;
    struct SpawnSyncOptions;
    struct SpawnSyncOptionsWithBufferEncoding;
    struct SpawnSyncOptionsWithStringEncoding;
    struct SpawnSyncReturns<T>;
    struct SpecIterable<T>;
    struct SpecIterableIterator<T>;
    struct SpecIterator<T, TReturn, TNext>;
    struct SpecReporter;
    struct SqliteCacheStore;
    struct SqliteCacheStoreOpts;
    struct SrvRecord;
    struct StackTrace;
    struct StackTraceId;
    struct StartParameterType;
    struct StartPreciseCoverageParameterType;
    struct StartSamplingParameterType;
    struct StartTrackingHeapObjectsParameterType;
    struct StatFsOptions;
    struct StatOptions;
    struct StatSyncFn;
    struct StatSyncOptions;
    struct StatWatcher;
    struct StatementColumnMetadata;
    struct StatementResultingChanges;
    struct StatementSync;
    struct StaticEventEmitterIteratorOptions;
    struct StaticEventEmitterOptions;
    struct Stats;
    struct StatsBase<T>;
    struct StatsFs;
    struct StatsFsBase<T>;
    struct StepIntoParameterType;
    struct StopReturnType;
    struct StopSamplingReturnType;
    struct StopTrackingHeapObjectsParameterType;
    struct Storage;
    struct Stream;
    struct StreamData<TOpaque>;
    struct StreamFactoryData<TOpaque>;
    struct StreamOptions;
    struct StreamPipeOptions;
    struct StreamResourceContentParameterType;
    struct StreamResourceContentReturnType;
    struct StreamState;
    struct StringDecoder;
    struct StringifyOptions;
    struct StripTypeScriptTypesOptions;
    struct StyleTextOptions;
    struct SubtleCrypto;
    struct SuiteContext;
    struct SyntheticModule;
    struct SyntheticModuleOptions;
    struct TLSSocket;
    struct TLSSocketOptions;
    struct TakeHeapSnapshotParameterType;
    struct TakePreciseCoverageReturnType;
    struct TargetCreatedEventDataType;
    struct TargetInfo;
    struct TcpNetConnectOpts;
    struct TcpSocketConnectOpts;
    struct TestComplete;
    struct TestContext;
    struct TestContextAssert;
    struct TestContextPlanOptions;
    struct TestContextWaitForOptions;
    struct TestCoverage;
    struct TestDequeue;
    struct TestDiagnostic;
    struct TestEnqueue;
    struct TestFail;
    struct TestOptions;
    struct TestPass;
    struct TestPlan;
    struct TestShard;
    struct TestStart;
    struct TestStderr;
    struct TestStdout;
    struct TestSummary;
    struct TestsStream;
    struct TextDecoder;
    struct TextDecoderOptions;
    struct TextDecoderStream;
    struct TextEncoder;
    struct TextEncoderStream;
    struct Timeout;
    struct Timer;
    struct TimerOptions;
    struct TimerifyOptions;
    struct TlsOptions;
    struct TlsaRecord;
    struct TraceConfig;
    struct Tracing;
    struct TracingChannel<StoreType, ContextType>;
    struct TracingChannelCollection<StoreType, ContextType>;
    struct TracingChannelSubscribers<ContextType>;
    struct Transform;
    struct TransformOptions<T>;
    struct TransformStream<I, O>;
    struct TransformStreamDefaultController<O>;
    struct Transformer<I, O>;
    struct TransformerCancelCallback;
    struct TransformerFlushCallback<O>;
    struct TransformerStartCallback<O>;
    struct TransformerTransformCallback<I, O>;
    struct URL;
    struct URLFormatOptions;
    struct URLPattern;
    struct URLPatternComponentResult;
    struct URLPatternInit;
    struct URLPatternOptions;
    struct URLPatternResult;
    struct URLSearchParams;
    struct URLSearchParamsIterator<T>;
    struct UVMetrics;
    struct UnderlyingByteSource;
    struct UnderlyingSink<W>;
    struct UnderlyingSinkAbortCallback;
    struct UnderlyingSinkCloseCallback;
    struct UnderlyingSinkStartCallback;
    struct UnderlyingSinkWriteCallback<W>;
    struct UnderlyingSource<R>;
    struct UnderlyingSourceCancelCallback;
    struct UnderlyingSourcePullCallback<R>;
    struct UnderlyingSourceStartCallback<R>;
    struct UndiciError;
    struct Unzip;
    struct UpgradeData<TOpaque>;
    struct UpgradeOptions;
    struct Url;
    struct UrlObject;
    struct UrlWithParsedQuery;
    struct UrlWithStringQuery;
    struct UserInfo<T>;
    struct UserInfoOptions;
    struct UserInfoOptionsWithBufferEncoding;
    struct UserInfoOptionsWithStringEncoding;
    struct Utf8Stream;
    struct Utf8StreamOptions;
    struct Verify;
    struct VerifyJsonWebKeyInput;
    struct VerifyKeyObjectInput;
    struct VerifyPublicKeyInput;
    struct WASI;
    struct WASIOptions;
    struct WatchFileOptions;
    struct WatchOptions;
    struct WatchOptionsWithBufferEncoding;
    struct WatchOptionsWithStringEncoding;
    struct WebSocket;
    struct WebSocketCloseInfo;
    struct WebSocketClosedEventDataType;
    struct WebSocketCreatedEventDataType;
    struct WebSocketError;
    struct WebSocketEventMap;
    struct WebSocketHandshakeResponseReceivedEventDataType;
    struct WebSocketInit;
    struct WebSocketResponse;
    struct WebSocketStream;
    struct WebSocketStreamOptions;
    struct Worker;
    struct WorkerInfo;
    struct WorkerOptions;
    struct WorkerPerformance;
    struct Writable;
    struct WritableOptions<T>;
    struct WritableStream;
    struct WritableStreamDefaultController;
    struct WritableStreamDefaultWriter<W>;
    struct WriteOptions;
    struct WriteStream;
    struct WriteStreamOptions;
    struct WriteVResult<T>;
    struct X25519KeyPairKeyObjectOptions;
    struct X25519KeyPairOptions<PubF, PrivF>;
    struct X448KeyPairKeyObjectOptions;
    struct X448KeyPairOptions<PubF, PrivF>;
    struct X509Certificate;
    struct X509CheckOptions;
    struct Zlib;
    struct ZlibOptions;
    struct ZlibParams;
    struct ZlibReset;
    struct ZstdCompress;
    struct ZstdDecompress;
    struct ZstdOptions;
    struct _GlobOptions<T>;
    struct connector;
    struct ucs2;

    // constant
    fn URL() -> JsValue;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS() -> String;
    fn measureMemory(options: Option<MeasureMemoryOptions>) -> JsPromise<MemoryMeasurement>;
    // constant
    fn SQLITE_CREATE_INDEX() -> f64;
    // constant
    fn HTTP2_HEADER_EXPECT() -> String;
    // constant
    fn HTTP2_METHOD_SEARCH() -> String;
    // constant
    fn S_IFLNK() -> f64;
    // merged from 2 overloads
    fn getDefaultResultOrder() -> String;
    fn pbkdf2Sync(password: JsValue, salt: JsValue, iterations: f64, keylen: f64, digest: String) -> JsValue;
    // constant
    fn MessagePort() -> JsValue;
    // constant
    fn O_WRONLY() -> f64;
    // merged from 7 overloads
    fn native(path: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    // constant
    fn HTTPINCOMINGMESSAGE() -> f64;
    // constant
    fn WSAENETDOWN() -> f64;
    // constant
    fn HTTP2_HEADER_CONTENT_LOCATION() -> String;
    fn symlinkSync(target: JsValue, path: JsValue, type_: Option<Option<String>>);
    // constant
    fn ZSTD_error_tableLog_tooLarge() -> f64;
    // merged from 10 overloads
    fn lookup(hostname: String, family: Option<f64>, callback: Option<fn(Option<ErrnoException>, String, f64) -> ()>);
    // constant
    fn WORKERHEAPSNAPSHOT() -> f64;
    fn closeSync(fd: f64);
    // constant
    fn PROCESSWRAP() -> f64;
    // constant
    fn SQLITE_DROP_VIEW() -> f64;
    fn runInContext(code: String, contextifiedObject: Context, options: Option<JsValue>) -> JsValue;
    // constant
    fn HTTP2_HEADER_CONTENT_MD5() -> String;
    fn isIP(input: String) -> f64;
    // merged from 2 overloads
    fn FILE() -> String;
    // constant
    fn EPERM() -> f64;
    // constant
    fn SSL_OP_CISCO_ANYCONNECT() -> f64;
    // constant
    fn BROTLI_PARAM_NDIRECT() -> f64;
    // constant
    fn ZSTD_c_targetLength() -> f64;
    fn clearInterval(timeout: JsValue);
    // constant
    fn HTTP_STATUS_INSUFFICIENT_STORAGE() -> f64;
    // constant
    fn WSAETIMEDOUT() -> f64;
    // constant
    fn Buffer() -> BufferConstructor;
    // constant
    fn SSL_OP_NO_ENCRYPT_THEN_MAC() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS() -> f64;
    fn setDefaultCACertificates(certs: JsArray<JsValue>);
    // constant
    fn BROTLI_OPERATION_FLUSH() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_FORCED() -> f64;
    // constant
    fn WSAEOPNOTSUPP() -> f64;
    // constant
    fn HTTP_STATUS_EXPECTATION_FAILED() -> f64;
    // constant
    fn Z_DEFAULT_LEVEL() -> f64;
    // constant
    fn NGHTTP2_FLAG_ACK() -> f64;
    // constant
    fn HTTP_STATUS_TEMPORARY_REDIRECT() -> f64;
    // merged from 2 overloads
    fn resolveTxt(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<JsArray<String>>) -> ()>);
    fn executionAsyncResource() -> JsValue;
    // merged from 2 overloads
    fn fail(actual: JsValue, expected: Option<JsValue>, message: Option<JsValue>, operator: Option<String>, stackStartFn: Option<JsFn>);
    fn getSetCookies(headers: Headers) -> JsArray<Cookie>;
    // constant
    fn ZSTD_error_noForwardProgress_destFull() -> f64;
    fn isTypedArray(object: JsValue) -> bool;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE() -> f64;
    // constant
    fn HTTP_STATUS_METHOD_NOT_ALLOWED() -> f64;
    // constant
    fn HTTP2_METHOD_MKCALENDAR() -> String;
    // merged from 7 overloads
    fn lstat(path: JsValue, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // constant
    fn EINTR() -> f64;
    fn linkSync(existingPath: JsValue, newPath: JsValue);
    fn getFips() -> f64;
    // constant
    fn PerformanceMark() -> JsValue;
    // merged from 8 overloads
    fn spawnSync(command: String, args: Option<JsArray<String>>, options: Option<SpawnSyncOptionsWithStringEncoding>) -> SpawnSyncReturns<String>;
    // constant
    fn HTTP_STATUS_IM_USED() -> f64;
    // merged from 184 overloads
    fn __promisify__<A, T1, T2, T3, T4, B>(source: A, transform1: Option<T1>, transform2: Option<T2>, transform3: Option<T3>, transform4: Option<T4>, destination: Option<B>, options: Option<PipelineOptions>) -> JsValue;
    // merged from 23 overloads
    fn resolve(hostname: String, rrtype: Option<String>, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    // merged from 2 overloads
    fn checkPrime(value: JsValue, options: CheckPrimeOptions, callback: Option<fn(Option<JsValue>, bool) -> ()>);
    // merged from 4 overloads
    fn test(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    fn NGHTTP2_FLAG_PRIORITY() -> f64;
    // constant
    fn TCPSERVERWRAP() -> f64;
    // constant
    fn SQLITE_DROP_TEMP_VIEW() -> f64;
    fn cpus() -> JsArray<CpuInfo>;
    fn isAscii(input: JsValue) -> bool;
    // constant
    fn HTTP2_HEADER_IF_MODIFIED_SINCE() -> String;
    fn isContext(sandbox: Context) -> bool;
    // constant
    fn cacheStores() -> JsValue;
    fn isBoxedPrimitive(object: JsValue) -> bool;
    // constant
    fn ZSTD_COMPRESS() -> f64;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS() -> String;
    // constant
    fn S_IFREG() -> f64;
    // constant
    fn BROTLI_OPERATION_FINISH() -> f64;
    // merged from 2 overloads
    fn NOTFOUND() -> String;
    fn triggerAsyncId() -> f64;
    // constant
    fn ZSTD_c_checksumFlag() -> f64;
    fn getHeapCodeStatistics() -> HeapCodeStatistics;
    fn createBrotliDecompress(options: Option<BrotliOptions>) -> BrotliDecompress;
    // constant
    fn SQLITE_REINDEX() -> f64;
    // constant
    fn ZSTD_error_no_error() -> f64;
    // merged from 2 overloads
    fn resolveMx(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<MxRecord>) -> ()>);
    fn retry(opts: Option<RetryOptions>) -> fn(JsValue) -> JsValue;
    // constant
    fn BROTLI_MODE_TEXT() -> f64;
    // constant
    fn WSAENOTEMPTY() -> f64;
    // constant
    fn HTTP_STATUS_FORBIDDEN() -> f64;
    // constant
    fn COPYFILE_EXCL() -> f64;
    // constant
    fn BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION() -> f64;
    // constant
    fn WSAELOOP() -> f64;
    fn isStringObject(object: JsValue) -> bool;
    // constant
    fn WSAEISCONN() -> f64;
    // constant
    fn HTTP2_HEADER_PROXY_AUTHORIZATION() -> String;
    fn renameSync(oldPath: JsValue, newPath: JsValue);
    fn setEngine(engine: String, flags: Option<f64>);
    // constant
    fn ENOENT() -> f64;
    // constant
    fn SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION() -> f64;
    // constant
    fn HTTP2_METHOD_CHECKOUT() -> String;
    // constant
    fn SQLITE_DETACH() -> f64;
    // merged from 3 overloads
    fn constants() -> JsValue;
    // constant
    fn global() -> JsValue;
    // constant
    fn POINT_CONVERSION_HYBRID() -> f64;
    // merged from 2 overloads
    fn json(stream: Option<JsValue>) -> JsPromise<JsValue>;
    fn findPackageJSON(specifier: JsValue, base: Option<JsValue>) -> Option<String>;
    fn networkInterfaces() -> Dict<JsArray<JsValue>>;
    // constant
    fn MIN_MAX_FRAME_SIZE() -> f64;
    // constant
    fn ENOLCK() -> f64;
    // constant
    fn ZSTD_error_dictionary_corrupted() -> f64;
    // constant
    fn NGHTTP2_SETTINGS_HEADER_TABLE_SIZE() -> f64;
    // constant
    fn HTTP2_METHOD_UNLINK() -> String;
    // constant
    fn S_IXGRP() -> f64;
    // constant
    fn NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE() -> f64;
    // constant
    fn Z_ASCII() -> f64;
    // constant
    fn BalancedPool() -> JsValue;
    fn cache(opts: Option<CacheOptions>) -> fn(JsValue) -> JsValue;
    // merged from 2 overloads
    fn resolveNaptr(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<NaptrRecord>) -> ()>);
    // NOTE: constraint on `T` not enforced
    fn getRandomValues<T>(typedArray: T) -> T;
    // NOTE: constraint on `T` not enforced
    fn addAbortSignal<T>(signal: JsValue, stream: T) -> T;
    // constant
    fn ECONNRESET() -> f64;
    // constant
    fn replDefaults() -> InspectOptions;
    // constant
    fn HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE() -> f64;
    fn cpSync(source: JsValue, destination: JsValue, opts: Option<CopySyncOptions>);
    // constant
    fn GETADDRINFOREQWRAP() -> f64;
    // constant
    fn WSAENAMETOOLONG() -> f64;
    // constant
    fn MAX_MAX_FRAME_SIZE() -> f64;
    // constant
    fn ENODATA() -> f64;
    // constant
    fn NGHTTP2_STREAM_CLOSED() -> f64;
    fn channel(name: JsValue) -> Channel;
    fn getAssetAsBlob(key: String, options: Option<JsValue>) -> Blob;
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES() -> f64;
    // constant
    fn EILSEQ() -> f64;
    // merged from 3 overloads
    fn CloseEvent() -> JsValue;
    // merged from 2 overloads
    fn TextEncoderStream() -> JsValue;
    // constant
    fn SQLITE_CREATE_TRIGGER() -> f64;
    // constant
    fn HTTP2SETTINGS() -> f64;
    // constant
    fn EAGAIN() -> f64;
    fn existsSync(path: JsValue) -> bool;
    // constant
    fn sessionStorage() -> Storage;
    // merged from 3 overloads
    fn mkdtempSync(prefix: String, options: Option<JsValue>) -> String;
    // constant
    fn ZSTD_btultra2() -> f64;
    // constant
    fn ENOMSG() -> f64;
    // constant
    fn NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL() -> f64;
    fn takeCoverage();
    // constant
    fn SCRYPTREQUEST() -> f64;
    // constant
    fn SQLITE_OK() -> f64;
    // constant
    fn DEFAULT_SETTINGS_ENABLE_PUSH() -> f64;
    fn deleteCookie(headers: Headers, name: String, attributes: Option<JsValue>);
    fn getGlobalOrigin() -> Option<URL>;
    // constant
    fn BROTLI_DECODER_RESULT_SUCCESS() -> f64;
    // constant
    fn WSAESOCKTNOSUPPORT() -> f64;
    // constant
    fn RSA_PSS_SALTLEN_AUTO() -> f64;
    // merged from 2 overloads
    fn postMessageToThread(threadId: f64, value: JsValue, transferList: JsArray<JsValue>, timeout: Option<f64>) -> JsPromise<()>;
    // constant
    fn HTTP2_METHOD_LOCK() -> String;
    // constant
    fn WSA_E_CANCELLED() -> f64;
    // constant
    fn BROTLI_MODE_GENERIC() -> f64;
    // constant
    fn HTTP2_METHOD_OPTIONS() -> String;
    fn homedir() -> String;
    // constant
    fn interceptors() -> JsValue;
    // constant
    fn PRIORITY_HIGH() -> f64;
    // merged from 2 overloads
    fn writeSync(fd: f64, buffer: JsValue, offset: Option<Option<f64>>, length: Option<Option<f64>>, position: Option<Option<f64>>) -> f64;
    // constant
    fn ECANCELED() -> f64;
    // merged from 2 overloads
    fn getServers() -> JsArray<String>;
    // constant
    fn WSAENETRESET() -> f64;
    fn createGzip(options: Option<ZlibOptions>) -> Gzip;
    // merged from 2 overloads
    fn custom() -> JsValue;
    // constant
    fn SQLITE_CHANGESET_FOREIGN_KEY() -> f64;
    // constant
    fn SSL_OP_ALLOW_NO_DHE_KEX() -> f64;
    // constant
    fn exports() -> JsValue;
    // constant
    fn EPIPE() -> f64;
    // constant
    fn HASHREQUEST() -> f64;
    // merged from 3 overloads
    fn setInterval<T>(delay: Option<f64>, value: Option<T>, options: Option<TimerOptions>) -> AsyncIterator<T>;
    // constant
    fn Z_DEFLATED() -> f64;
    // merged from 2 overloads
    fn setServers(servers: JsArray<String>);
    // constant
    fn S_IRUSR() -> f64;
    // constant
    fn Z_DEFAULT_CHUNK() -> f64;
    fn gunzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // merged from 20 overloads
    fn spawn(command: String, args: Option<JsArray<String>>, options: Option<SpawnOptionsWithoutStdio>) -> ChildProcessWithoutNullStreams;
    // constant
    fn WSAEREMOTE() -> f64;
    // constant
    fn cluster() -> Cluster;
    fn publicDecrypt(key: JsValue, buffer: JsValue) -> JsValue;
    // constant
    fn NGHTTP2_ENHANCE_YOUR_CALM() -> f64;
    // constant
    fn NGHTTP2_FLAG_PADDED() -> f64;
    // constant
    fn HTTP2_METHOD_PRI() -> String;
    // constant
    fn SQLITE_CHANGESET_OMIT() -> f64;
    // merged from 2 overloads
    fn readSync(fd: f64, buffer: JsValue, offset: f64, length: Option<f64>, position: Option<JsValue>) -> f64;
    // constant
    fn HTTP_STATUS_CONFLICT() -> f64;
    // constant
    fn parentPort() -> Option<MessagePort>;
    // constant
    fn PIPEWRAP() -> f64;
    // constant
    fn HTTP_STATUS_LOCKED() -> f64;
    // constant
    fn HTTP2_HEADER_STRICT_TRANSPORT_SECURITY() -> String;
    fn notStrictEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // constant
    fn WSAEPROTOTYPE() -> f64;
    fn isPromise(object: JsValue) -> bool;
    // constant
    fn UNZIP() -> f64;
    // merged from 2 overloads
    fn CountQueuingStrategy() -> JsValue;
    // constant
    fn SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION() -> f64;
    fn unzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    fn WSAENOMORE() -> f64;
    // constant
    fn HTTP2_METHOD_UPDATEREDIRECTREF() -> String;
    fn createContext(contextObject: Option<JsValue>, options: Option<CreateContextOptions>) -> Context;
    fn getPriority(pid: Option<f64>) -> f64;
    // constant
    fn ZSTD_c_enableLongDistanceMatching() -> f64;
    // constant
    fn CLIENT_RENEG_WINDOW() -> f64;
    // constant
    fn ping() -> fn(WebSocket, Buffer) -> ();
    // constant
    fn HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED() -> f64;
    // constant
    fn SSL_OP_NO_COMPRESSION() -> f64;
    // merged from 2 overloads
    fn resolveNs(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    fn brotliDecompressSync(buf: JsValue, options: Option<BrotliOptions>) -> JsValue;
    // constant
    fn S_IRWXG() -> f64;
    // merged from 2 overloads
    fn Z_DEFAULT_STRATEGY() -> f64;
    // constant
    fn ZSTD_fast() -> f64;
    // constant
    fn WSAENOPROTOOPT() -> f64;
    // constant
    fn METHODS() -> JsArray<String>;
    // constant
    fn NGHTTP2_FLAG_NONE() -> f64;
    // NOTE: constraint on `R` not enforced
    fn serveStatic<R>(root: String, options: Option<ServeStaticOptions<R>>) -> RequestHandler<R>;
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2() -> f64;
    fn setDefaultSnapshotSerializers(serializers: JsArray<fn(JsValue) -> JsValue>);
    // constant
    fn WSAEHOSTUNREACH() -> f64;
    fn getDefaultAutoSelectFamilyAttemptTimeout() -> f64;
    fn createZstdCompress(options: Option<ZstdOptions>) -> ZstdCompress;
    // merged from 3 overloads
    fn queryObjects(ctor: JsFn, options: Option<JsValue>) -> f64;
    // constant
    fn NGHTTP2_STREAM_STATE_RESERVED_REMOTE() -> f64;
    fn scryptSync(password: JsValue, salt: JsValue, keylen: f64, options: Option<ScryptOptions>) -> JsValue;
    // constant
    fn WSAEBADF() -> f64;
    fn createDiffieHellmanGroup(name: String) -> JsValue;
    // constant
    fn BROTLI_MIN_INPUT_BLOCK_BITS() -> f64;
    // constant
    fn RANDOMPRIMEREQUEST() -> f64;
    // constant
    fn EMSGSIZE() -> f64;
    // constant
    fn HTTP2_HEADER_CONTENT_ENCODING() -> String;
    // constant
    fn urlencoded() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE() -> f64;
    // constant
    fn ZSTD_error_workSpace_tooSmall() -> f64;
    // constant
    fn E2BIG() -> f64;
    // constant
    fn HTTP2_HEADER_CONTENT_LENGTH() -> String;
    // constant
    fn NODE_PERFORMANCE_GC_WEAKCB() -> f64;
    // constant
    fn ENOTSOCK() -> f64;
    fn mkdtempDisposable(prefix: JsValue, options: Option<JsValue>) -> JsPromise<DisposableTempDir>;
    // constant
    fn MockCallHistoryLog() -> JsValue;
    fn registerHooks(options: RegisterHooksOptions) -> ModuleHooks;
    // constant
    fn SSL_OP_NO_SSLv3() -> f64;
    // constant
    fn WSAEACCES() -> f64;
    // constant
    fn ENOBUFS() -> f64;
    // constant
    fn HTTP2_METHOD_UNBIND() -> String;
    // constant
    fn ENGINE_METHOD_ALL() -> f64;
    // merged from 2 overloads
    fn scrypt(password: JsValue, salt: JsValue, keylen: f64, options: ScryptOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn maxHeaderSize() -> f64;
    // constant
    fn UDPSENDWRAP() -> f64;
    // constant
    fn localStorage() -> Storage;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD() -> String;
    fn openSync(path: JsValue, flags: JsValue, mode: Option<Option<JsValue>>) -> f64;
    // constant
    fn WebSocketStream() -> JsValue;
    // constant
    fn AbortSignal() -> JsValue;
    fn notEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // merged from 2 overloads
    fn TextDecoderStream() -> JsValue;
    // constant
    fn FSREQPROMISE() -> f64;
    // constant
    fn ZSTD_dfast() -> f64;
    fn validateHeaderName(name: String);
    // constant
    fn HTTP_STATUS_NOT_ACCEPTABLE() -> f64;
    // constant
    fn HTTP_STATUS_ALREADY_REPORTED() -> f64;
    // merged from 2 overloads
    fn TIMEOUT() -> String;
    // constant
    fn ENOSYS() -> f64;
    // constant
    fn HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION() -> f64;
    // constant
    fn CLIENT_RENEG_LIMIT() -> f64;
    // constant
    fn path() -> PlatformPath;
    // constant
    fn ZSTD_error_noForwardProgress_inputEmpty() -> f64;
    // constant
    fn WSAEHOSTDOWN() -> f64;
    fn rmdirSync(path: JsValue, options: Option<RmDirOptions>);
    // constant
    fn NGHTTP2_DEFAULT_WEIGHT() -> f64;
    // merged from 2 overloads
    fn FORMERR() -> String;
    fn webSocketHandshakeResponseReceived(params: WebSocketHandshakeResponseReceivedEventDataType);
    // constant
    fn CHECKPRIMEREQUEST() -> f64;
    fn zstdDecompressSync(buf: JsValue, options: Option<ZstdOptions>) -> JsValue;
    // constant
    fn EDQUOT() -> f64;
    fn hasSubscribers(name: JsValue) -> bool;
    // constant
    fn BROTLI_OPERATION_PROCESS() -> f64;
    // merged from 2 overloads
    fn Z_STREAM_END() -> f64;
    // merged from 2 overloads
    fn ReadableStreamBYOBReader() -> JsValue;
    // constant
    fn Z_DEFAULT_WINDOWBITS() -> f64;
    fn isSetIterator(object: JsValue) -> bool;
    // merged from 2 overloads
    fn getAsset(key: String, encoding: Option<String>) -> String;
    // constant
    fn WSAEPROTONOSUPPORT() -> f64;
    fn isUint8ClampedArray(object: JsValue) -> bool;
    // merged from 2 overloads
    fn chmod(path: JsValue, mode: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn HTTP2_HEADER_COOKIE() -> String;
    fn fsync(fd: f64, callback: fn(Option<ErrnoException>) -> ());
    // constant
    fn RTLD_LAZY() -> f64;
    // constant
    fn ZSTD_e_flush() -> f64;
    fn setFlagsFromString(flags: String);
    // merged from 14 overloads
    fn callbackify(fn_: fn() -> JsPromise<()>) -> fn(fn(ErrnoException) -> ()) -> ();
    // constant
    fn ENABLED() -> f64;
    fn createHmac(algorithm: String, key: JsValue, options: Option<TransformOptions>) -> Hmac;
    // constant
    fn HTTP2_METHOD_MOVE() -> String;
    // constant
    fn HTTP_STATUS_PRECONDITION_REQUIRED() -> f64;
    fn openAsBlob(path: JsValue, options: Option<OpenAsBlobOptions>) -> JsPromise<Blob>;
    // merged from 3 overloads
    fn randomFill<T>(buffer: T, offset: f64, size: Option<f64>, callback: Option<fn(Option<JsValue>, T) -> ()>);
    // constant
    fn File() -> JsValue;
    // merged from 2 overloads
    fn fork(modulePath: JsValue, args: Option<JsArray<String>>, options: Option<ForkOptions>) -> ChildProcess;
    // constant
    fn HTTP_STATUS_NOT_MODIFIED() -> f64;
    // constant
    fn ECHILD() -> f64;
    // constant
    fn WSASYSCALLFAILURE() -> f64;
    // constant
    fn O_EXCL() -> f64;
    // constant
    fn HTTP2_HEADER_STATUS() -> String;
    // constant
    fn navigator() -> JsValue;
    // merged from 2 overloads
    fn ByteLengthQueuingStrategy() -> JsValue;
    // constant
    fn HTTP2_HEADER_SCHEME() -> String;
    // constant
    fn promiseHooks() -> PromiseHooks;
    fn domainToASCII(domain: String) -> String;
    // constant
    fn threadName() -> Option<String>;
    // constant
    fn WSAEADDRNOTAVAIL() -> f64;
    // constant
    fn HTTP2_METHOD_LABEL() -> String;
    // constant
    fn SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS() -> f64;
    // constant
    fn DH_UNABLE_TO_CHECK_GENERATOR() -> f64;
    // constant
    fn MESSAGEPORT() -> f64;
    // merged from 14 overloads
    fn promisify<TCustom>(fn_: JsValue) -> TCustom;
    fn markAsUncloneable(object: JsValue);
    fn isArgumentsObject(object: JsValue) -> bool;
    // constant
    fn EPROTO() -> f64;
    fn crc32(data: JsValue, value: Option<f64>) -> f64;
    fn getSystemErrorMap() -> JsValue;
    fn fsyncSync(fd: f64);
    // constant
    fn SQLITE_DENY() -> f64;
    // constant
    fn WSAESHUTDOWN() -> f64;
    // merged from 2 overloads
    fn lookupService(address: String, port: f64, callback: Option<fn(Option<ErrnoException>, String, String) -> ()>);
    // constant
    fn Z_MAX_LEVEL() -> f64;
    // constant
    fn BROTLI_DECODER_SUCCESS() -> f64;
    // merged from 7 overloads
    fn realpath(path: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    // merged from 8 overloads
    fn write<TBuffer>(fd: f64, buffer: TBuffer, offset: Option<f64>, length: Option<f64>, position: Option<f64>, callback: Option<fn(Option<ErrnoException>, f64, TBuffer) -> ()>);
    // constant
    fn O_SYNC() -> f64;
    // merged from 3 overloads
    fn rmdir(path: JsValue, options: RmDirOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn enableCompileCache(cacheDir: Option<String>) -> EnableCompileCacheResult;
    fn parseCookie(cookie: String) -> Option<Cookie>;
    // constant
    fn ENOTDIR() -> f64;
    // constant
    fn SQLITE_COPY() -> f64;
    fn futimesSync(fd: f64, atime: JsValue, mtime: JsValue);
    // constant
    fn EDESTADDRREQ() -> f64;
    // constant
    fn styles() -> JsValue;
    fn getSystemErrorMessage(err: f64) -> String;
    // merged from 2 overloads
    fn setPriority(pid: f64, priority: Option<f64>);
    fn globalThisInstall();
    fn setDefaultAutoSelectFamilyAttemptTimeout(value: f64);
    // constant
    fn Z_MAX_MEMLEVEL() -> f64;
    fn accessSync(path: JsValue, mode: Option<f64>);
    // constant
    fn NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS() -> f64;
    // merged from 2 overloads
    fn resolveSoa(hostname: String, callback: Option<fn(Option<ErrnoException>, SoaRecord) -> ()>);
    // constant
    fn HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED() -> f64;
    fn publicEncrypt(key: JsValue, buffer: JsValue) -> JsValue;
    // constant
    fn HTTP_STATUS_RESET_CONTENT() -> f64;
    // constant
    fn HTTP2_HEADER_SERVER() -> String;
    // constant
    fn HTTP2_METHOD_MKACTIVITY() -> String;
    // merged from 2 overloads
    fn resolveSrv(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<SrvRecord>) -> ()>);
    // merged from 2 overloads
    fn REFUSED() -> String;
    // merged from 3 overloads
    fn fstatSync(fd: f64, options: Option<StatOptions>) -> Stats;
    fn isStringOneByteRepresentation(content: String) -> bool;
    // constant
    fn HTTP_STATUS_LENGTH_REQUIRED() -> f64;
    // constant
    fn FSREQCALLBACK() -> f64;
    // constant
    fn Z_MIN_MEMLEVEL() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_TRANSFORM() -> f64;
    fn checkServerIdentity(hostname: String, cert: PeerCertificate) -> Option<JsValue>;
    // constant
    fn RSA_PKCS1_PSS_PADDING() -> f64;
    // merged from 2 overloads
    fn Z_FIXED() -> f64;
    // constant
    fn EIO() -> f64;
    // constant
    fn SIGINTWATCHDOG() -> f64;
    // constant
    fn MockClient() -> JsValue;
    // merged from 2 overloads
    fn caches() -> JsValue;
    // constant
    fn HTTP2_HEADER_DATE() -> String;
    fn createInflate(options: Option<ZlibOptions>) -> Inflate;
    // merged from 2 overloads
    fn CANCELLED() -> String;
    // constant
    fn WSAEWOULDBLOCK() -> f64;
    // constant
    fn CryptoKey() -> JsValue;
    fn getCACertificates(type_: Option<String>) -> JsArray<String>;
    // merged from 2 overloads
    fn WritableStream() -> JsValue;
    // merged from 3 overloads
    fn setImmediate<T>(value: Option<T>, options: Option<TimerOptions>) -> JsPromise<T>;
    // constant
    fn HTTP2_HEADER_RANGE() -> String;
    // constant
    fn HTTP_STATUS_URI_TOO_LONG() -> f64;
    fn isIPv4(input: String) -> bool;
    // merged from 4 overloads
    fn parse(str: String, sep: Option<String>, eq: Option<String>, options: Option<ParseOptions>) -> ParsedUrlQuery;
    // merged from 3 overloads
    fn writeFile(file: JsValue, data: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn after(fn_: Option<JsValue>, options: Option<HookOptions>);
    // merged from 2 overloads
    fn writev<TBuffers>(fd: f64, buffers: TBuffers, position: Option<f64>, cb: Option<fn(Option<ErrnoException>, f64, TBuffers) -> ()>);
    // constant
    fn ZSTD_error_init_missing() -> f64;
    // merged from 2 overloads
    fn resolveCname(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    // constant
    fn HTTP2_HEADER_VARY() -> String;
    // constant
    fn sensitiveHeaders() -> JsValue;
    // merged from 3 overloads
    fn symlink(target: JsValue, path: JsValue, type_: Option<JsValue>, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 2 overloads
    fn LOADIPHLPAPI() -> String;
    // merged from 8 overloads
    fn todo(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    fn WRITEWRAP() -> f64;
    // merged from 2 overloads
    fn lchown(path: JsValue, uid: f64, gid: f64, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 2 overloads
    fn zstdDecompress(buf: JsValue, options: ZstdOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // merged from 2 overloads
    fn NOTIMP() -> String;
    // constant
    fn RSA_NO_PADDING() -> f64;
    // merged from 2 overloads
    fn stream<TOpaque>(url: Option<JsValue>, options: Option<JsValue>, factory: Option<fn(StreamFactoryData<TOpaque>) -> Writable>) -> JsPromise<StreamData<TOpaque>>;
    // constant
    fn gc() -> Option<GCFunction>;
    // constant
    fn ZSTD_error_parameter_unsupported() -> f64;
    // constant
    fn NGHTTP2_INTERNAL_ERROR() -> f64;
    // constant
    fn Z_MAX_WINDOWBITS() -> f64;
    // constant
    fn ENGINE_METHOD_DIGESTS() -> f64;
    // constant
    fn NGHTTP2_COMPRESSION_ERROR() -> f64;
    // constant
    fn EventTarget() -> JsValue;
    // constant
    fn QUERYWRAP() -> f64;
    fn create() -> Domain;
    // constant
    fn HTTP2_HEADER_TE() -> String;
    // constant
    fn defaultCipherList() -> String;
    fn notDeepStrictEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // constant
    fn SQLITE_CHANGESET_NOTFOUND() -> f64;
    // merged from 3 overloads
    fn MessageEvent() -> JsValue;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY() -> f64;
    // constant
    fn WSAEDISCON() -> f64;
    // constant
    fn O_NONBLOCK() -> f64;
    // constant
    fn HTTP_STATUS_GATEWAY_TIMEOUT() -> f64;
    // merged from 3 overloads
    fn appendFile(path: JsValue, data: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn TextEncoder() -> JsValue;
    // merged from 2 overloads
    fn SERVFAIL() -> String;
    // constant
    fn BROTLI_MAX_WINDOW_BITS() -> f64;
    // merged from 2 overloads
    fn WritableStreamDefaultWriter() -> JsValue;
    // constant
    fn HTTP2_METHOD_BIND() -> String;
    // constant
    fn F_OK() -> f64;
    // constant
    fn SnapshotAgent() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_PADDING_2() -> f64;
    fn setCookie(headers: Headers, cookie: Cookie);
    // merged from 2 overloads
    fn lchmod(path: JsValue, mode: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn opendirSync(path: JsValue, options: Option<OpenDirOptions>) -> Dir;
    // constant
    fn SSL_OP_CIPHER_SERVER_PREFERENCE() -> f64;
    // constant
    fn NGHTTP2_FRAME_SIZE_ERROR() -> f64;
    // constant
    fn HTTP2_METHOD_LINK() -> String;
    fn tap(source: JsValue) -> JsValue;
    // constant
    fn USE_MAIN_CONTEXT_DEFAULT_LOADER() -> f64;
    // constant
    fn WSAEINPROGRESS() -> f64;
    // constant
    fn HTTP2_METHOD_PROPFIND() -> String;
    fn chmodSync(path: JsValue, mode: JsValue);
    // constant
    fn POINT_CONVERSION_COMPRESSED() -> f64;
    // constant
    fn PBKDF2REQUEST() -> f64;
    // constant
    fn ZSTD_c_strategy() -> f64;
    // merged from 2 overloads
    fn Z_FINISH() -> f64;
    fn junit(source: JsValue) -> JsValue;
    // constant
    fn ZSTD_e_continue() -> f64;
    // constant
    fn BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT() -> f64;
    // merged from 2 overloads
    fn Z_BEST_SPEED() -> f64;
    fn timingSafeEqual(a: JsValue, b: JsValue) -> bool;
    // constant
    fn SSL_OP_NO_TLSv1_1() -> f64;
    fn secureHeapUsed() -> SecureHeapUsage;
    // constant
    fn BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT() -> f64;
    // constant
    fn ENOSPC() -> f64;
    // constant
    fn STATUS_CODES() -> JsValue;
    // merged from 2 overloads
    fn BADQUERY() -> String;
    // constant
    fn HTTP_STATUS_PAYLOAD_TOO_LARGE() -> f64;
    // constant
    fn WSAEINTR() -> f64;
    // constant
    fn mock() -> MockTracker;
    fn stringify(obj: Option<ParsedUrlQueryInput>, sep: Option<String>, eq: Option<String>, options: Option<StringifyOptions>) -> String;
    fn subscribe(name: JsValue, onMessage: fn(JsValue, JsValue) -> ());
    // constant
    fn HTTP2_METHOD_BASELINE_CONTROL() -> String;
    // constant
    fn SQLITE_SAVEPOINT() -> f64;
    fn isUtf8(input: JsValue) -> bool;
    // merged from 3 overloads
    fn readFileSync(path: JsValue, options: Option<Option<JsValue>>) -> JsValue;
    // constant
    fn HTTP_STATUS_PRECONDITION_FAILED() -> f64;
    // constant
    fn ZSTD_CLEVEL_DEFAULT() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME() -> f64;
    fn toASCII(domain: String) -> String;
    // merged from 2 overloads
    fn version() -> String;
    fn platform() -> String;
    // constant
    fn ZSTD_lazy2() -> f64;
    fn tmpdir() -> String;
    // constant
    fn SHUTDOWNWRAP() -> f64;
    // merged from 10 overloads
    fn createServer(options: TlsOptions, secureConnectionListener: Option<fn(TLSSocket) -> ()>) -> Server;
    // merged from 2 overloads
    fn Headers() -> JsValue;
    // constant
    fn ENGINE_METHOD_DSA() -> f64;
    // constant
    fn HTTP2_METHOD_PROPPATCH() -> String;
    // constant
    fn errors() -> JsValue;
    // NOTE: constraint on `T` not enforced
    fn parseArgs<T>(config: Option<T>) -> JsValue;
    // constant
    fn ZSTD_btlazy2() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_MINOR() -> f64;
    // merged from 3 overloads
    fn console() -> InspectorConsole;
    // constant
    fn HTTP2_METHOD_COPY() -> String;
    // constant
    fn WSAEPROVIDERFAILEDINIT() -> f64;
    fn generateKey(type_: String, options: JsValue, callback: fn(Option<JsValue>, KeyObject) -> ());
    // merged from 2 overloads
    fn getCiphers() -> JsArray<String>;
    // constant
    fn SIGNALWRAP() -> f64;
    // constant
    fn Z_DEFAULT_MEMLEVEL() -> f64;
    // constant
    fn TextDecoder() -> JsValue;
    // merged from 2 overloads
    fn deflateRaw(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn H2CClient() -> JsValue;
    fn getEnvironmentData(key: JsValue) -> JsValue;
    fn isSharedArrayBuffer(object: JsValue) -> bool;
    // constant
    fn ESPIPE() -> f64;
    // constant
    fn SSL_OP_NO_SSLv2() -> f64;
    // constant
    fn ENETDOWN() -> f64;
    // merged from 2 overloads
    fn Request() -> JsValue;
    // constant
    fn workerData() -> JsValue;
    // constant
    fn HTTP2_HEADER_SET_COOKIE() -> String;
    // merged from 3 overloads
    fn rm(path: JsValue, options: RmOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn toUnicode(domain: String) -> String;
    // constant
    fn HTTP_STATUS_NOT_FOUND() -> f64;
    // constant
    fn EDEADLK() -> f64;
    // constant
    fn S_IRWXU() -> f64;
    // merged from 2 overloads
    fn CONNREFUSED() -> String;
    // constant
    fn FAILED() -> f64;
    // constant
    fn SSL_OP_NO_RENEGOTIATION() -> f64;
    // constant
    fn spec() -> ReporterConstructorWrapper<JsValue>;
    // constant
    fn HTTP2_HEADER_LAST_MODIFIED() -> String;
    // constant
    fn WSAEDQUOT() -> f64;
    // constant
    fn HTTP_STATUS_UPGRADE_REQUIRED() -> f64;
    fn isInt16Array(object: JsValue) -> bool;
    // merged from 3 overloads
    fn register<Data>(specifier: JsValue, parentURL: Option<JsValue>, options: Option<RegisterOptions<Data>>);
    // constant
    fn SQLITE_CREATE_TEMP_INDEX() -> f64;
    // constant
    fn HTTP_STATUS_SEE_OTHER() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_INVALID_ARGUMENTS() -> f64;
    // constant
    fn HTTP_STATUS_PERMANENT_REDIRECT() -> f64;
    // merged from 2 overloads
    fn lutimes(path: JsValue, atime: JsValue, mtime: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn lutimesSync(path: JsValue, atime: JsValue, mtime: JsValue);
    // constant
    fn O_TRUNC() -> f64;
    // constant
    fn O_DIRECTORY() -> f64;
    // constant
    fn S_IRWXO() -> f64;
    // merged from 2 overloads
    fn DESTRUCTION() -> String;
    fn atob(data: String) -> String;
    fn dump(opts: Option<JsValue>) -> fn(JsValue) -> JsValue;
    // constant
    fn DOMException() -> JsValue;
    // constant
    fn BROTLI_MIN_WINDOW_BITS() -> f64;
    fn parseMIMEType(input: String) -> JsValue;
    // constant
    fn NGHTTP2_FLOW_CONTROL_ERROR() -> f64;
    // merged from 2 overloads
    fn Z_DEFAULT_COMPRESSION() -> f64;
    // constant
    fn HTTP2_HEADER_EXPIRES() -> String;
    fn fchmod(fd: f64, mode: JsValue, callback: fn(Option<ErrnoException>) -> ());
    fn resolveObjectURL(id: String) -> Option<Blob>;
    // constant
    fn TLSWRAP() -> f64;
    fn isGeneratorFunction(object: JsValue) -> bool;
    fn getHeapStatistics() -> HeapInfo;
    fn isModuleNamespaceObject(value: JsValue) -> bool;
    // merged from 3 overloads
    fn access(path: JsValue, mode: Option<f64>, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 2 overloads
    fn brotliCompress(buf: JsValue, options: BrotliOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn Z_BINARY() -> f64;
    // merged from 11 overloads
    fn readdir(path: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    fn partialDeepStrictEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // constant
    fn Storage() -> JsValue;
    // merged from 5 overloads
    fn readdirSync(path: JsValue, options: Option<JsValue>) -> JsArray<String>;
    fn isNativeError(object: JsValue) -> bool;
    // merged from 2 overloads
    fn inspect(object: JsValue, showHidden: Option<bool>, depth: Option<Option<f64>>, color: Option<bool>) -> String;
    // NOTE: constraint on `ContextType` not enforced
    fn tracingChannel<StoreType, ContextType>(nameOrChannels: JsValue) -> TracingChannel<StoreType, ContextType>;
    fn notDeepEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // constant
    fn HTTP_STATUS_SERVICE_UNAVAILABLE() -> f64;
    // constant
    fn HTTP2_METHOD_HEAD() -> String;
    fn isBigInt64Array(value: JsValue) -> bool;
    // merged from 2 overloads
    fn createSecureServer<Http1Request, Http1Response, Http2Request, Http2Response>(options: SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>, onRequestHandler: Option<fn(JsValue, JsValue) -> ()>) -> Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
    // merged from 2 overloads
    fn Z_NO_FLUSH() -> f64;
    fn getHashes() -> JsArray<String>;
    // merged from 3 overloads
    fn truncate(path: JsValue, len: Option<f64>, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn SQLITE_RECURSIVE() -> f64;
    // merged from 2 overloads
    fn ReadableStreamBYOBRequest() -> JsValue;
    // constant
    fn ENOTCONN() -> f64;
    // constant
    fn HTTP2_METHOD_GET() -> String;
    // merged from 2 overloads
    fn randomBytes(size: f64, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP() -> f64;
    // constant
    fn BROTLI_OPERATION_EMIT_METADATA() -> f64;
    // constant
    fn EAFNOSUPPORT() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING() -> f64;
    fn deflateRawSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // merged from 2 overloads
    fn Z_MEM_ERROR() -> f64;
    // merged from 2 overloads
    fn performance() -> Performance;
    // constant
    fn INSPECT_MAX_BYTES() -> f64;
    // constant
    fn WSAEINVALIDPROCTABLE() -> f64;
    // constant
    fn WSAEDESTADDRREQ() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE() -> f64;
    fn setMaxIdleHTTPParsers(max: f64);
    fn strict(value: JsValue, message: Option<JsValue>) -> bool;
    // constant
    fn colors() -> Dict<(f64, f64)>;
    // constant
    fn V4MAPPED() -> f64;
    fn isRegExp(object: JsValue) -> bool;
    // constant
    fn BROTLI_PARAM_QUALITY() -> f64;
    fn afterEach(fn_: Option<JsValue>, options: Option<HookOptions>);
    fn isErrored(stream: JsValue) -> bool;
    // constant
    fn STREAMPIPE() -> f64;
    // merged from 2 overloads
    fn setDefaultResultOrder(order: String);
    fn equal(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    // merged from 7 overloads
    fn readlink(path: JsValue, options: JsValue, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    // constant
    fn HTTP2_METHOD_ORDERPATCH() -> String;
    // merged from 55 overloads
    fn generateKeyPairSync(type_: String, options: RSAKeyPairOptions<String, String>) -> KeyPairSyncResult<String, String>;
    // constant
    fn WSAESTALE() -> f64;
    // constant
    fn DEFAULT_CIPHERS() -> String;
    // constant
    fn __dirname() -> String;
    fn serializeAMimeType(mimeType: MIMEType) -> String;
    fn moveCursor(stream: WritableStream, dx: f64, dy: f64, callback: Option<fn() -> ()>) -> bool;
    // constant
    fn HTTP2_HEADER_IF_UNMODIFIED_SINCE() -> String;
    fn strictEqual<T>(actual: JsValue, expected: T, message: Option<JsValue>) -> bool;
    // merged from 16 overloads
    fn pipeline<A, T1, T2, T3, T4, B>(source: Option<A>, transform1: Option<T1>, transform2: Option<T2>, transform3: Option<T3>, transform4: Option<T4>, destination: Option<B>, options: Option<PipelineOptions>) -> JsValue;
    // constant
    fn NGHTTP2_NO_ERROR() -> f64;
    // merged from 2 overloads
    fn ftruncate(fd: f64, len: Option<f64>, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn WSA_E_NO_MORE() -> f64;
    // constant
    fn S_IXUSR() -> f64;
    fn createHash(algorithm: String, options: Option<HashOptions>) -> Hash;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN() -> String;
    // NOTE: constraint on `T` not enforced
    fn randomFillSync<T>(buffer: T, offset: Option<f64>, size: Option<f64>) -> T;
    fn inflateSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    fn HTTP2_HEADER_CONTENT_TYPE() -> String;
    // constant
    fn ZSTD_error_maxSymbolValue_tooLarge() -> f64;
    // constant
    fn ZLIB_VERNUM() -> f64;
    // constant
    fn EOPNOTSUPP() -> f64;
    // constant
    fn BROTLI_DECODER_RESULT_ERROR() -> f64;
    // constant
    fn HTTP_STATUS_PAYMENT_REQUIRED() -> f64;
    // constant
    fn KEYPAIRGENREQUEST() -> f64;
    fn clearScreenDown(stream: WritableStream, callback: Option<fn() -> ()>) -> bool;
    // constant
    fn PRIORITY_BELOW_NORMAL() -> f64;
    fn duplexPair(options: Option<DuplexOptions>) -> (Duplex, Duplex);
    // constant
    fn O_SYMLINK() -> f64;
    // constant
    fn Z_UNKNOWN() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_PADDING_1() -> f64;
    // merged from 2 overloads
    fn Z_FULL_FLUSH() -> f64;
    // constant
    fn NGHTTP2_SESSION_SERVER() -> f64;
    fn query(options: JsValue) -> Handler;
    // constant
    fn EWOULDBLOCK() -> f64;
    // constant
    fn WSANOTINITIALISED() -> f64;
    // constant
    fn resourceLimits() -> ResourceLimits;
    // merged from 8 overloads
    fn execFileSync(file: String, args: Option<JsArray<String>>, options: Option<ExecFileSyncOptionsWithStringEncoding>) -> String;
    // merged from 2 overloads
    fn diffieHellman(options: JsValue, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    fn headerNameToString(value: JsValue) -> String;
    // merged from 2 overloads
    fn createSecretKey(key: String, encoding: Option<JsValue>) -> KeyObject;
    // constant
    fn ZSTD_error_version_unsupported() -> f64;
    // constant
    fn ZSTD_error_checksum_wrong() -> f64;
    fn createRequire(path: JsValue) -> Require;
    fn url() -> Option<String>;
    // constant
    fn HTTP_STATUS_UNAUTHORIZED() -> f64;
    // constant
    fn S_IWGRP() -> f64;
    // constant
    fn PADDING_STRATEGY_MAX() -> f64;
    // merged from 2 overloads
    fn BADSTR() -> String;
    // constant
    fn FILEHANDLECLOSEREQ() -> f64;
    // constant
    fn S_IROTH() -> f64;
    fn findSourceMap(path: String) -> Option<SourceMap>;
    // merged from 55 overloads
    fn generateKeyPair(type_: String, options: RSAKeyPairOptions<String, String>, callback: fn(Option<JsValue>, String, String) -> ());
    // constant
    fn WebSocketError() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET() -> f64;
    // constant
    fn SQLITE_CREATE_TEMP_TRIGGER() -> f64;
    // constant
    fn BROTLI_DECODER_NO_ERROR() -> f64;
    // merged from 2 overloads
    fn globalAgent() -> Agent;
    // constant
    fn HTTP2_METHOD_ACL() -> String;
    // constant
    fn ALREADY_ENABLED() -> f64;
    // constant
    fn NGHTTP2_ERR_FRAME_SIZE_ERROR() -> f64;
    fn createPublicKey(key: JsValue) -> KeyObject;
    // merged from 2 overloads
    fn NODATA() -> String;
    // constant
    fn mime() -> JsValue;
    // constant
    fn HTTP2_HEADER_WWW_AUTHENTICATE() -> String;
    fn domainToUnicode(domain: String) -> String;
    fn markAsUntransferable(object: JsValue);
    // constant
    fn ZSTD_error_maxSymbolValue_tooSmall() -> f64;
    // constant
    fn PADDING_STRATEGY_CALLBACK() -> f64;
    fn isExternal(object: JsValue) -> bool;
    fn gzipSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    fn isGeneratorObject(object: JsValue) -> bool;
    fn responseError(opts: Option<JsValue>) -> fn(JsValue) -> JsValue;
    // constant
    fn S_IFIFO() -> f64;
    fn flushCompileCache();
    fn debuglog(section: String, callback: Option<fn(fn(String, JsArray<JsValue>) -> ()) -> ()>) -> DebugLogger;
    fn getUnpackedSettings(buf: JsValue) -> Settings;
    fn privateEncrypt(privateKey: JsValue, buffer: JsValue) -> JsValue;
    fn btoa(data: String) -> String;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS() -> String;
    fn isatty(fd: f64) -> bool;
    // constant
    fn NGHTTP2_STREAM_STATE_CLOSED() -> f64;
    // constant
    fn HTTP_STATUS_MULTIPLE_CHOICES() -> f64;
    // constant
    fn FSEVENTWRAP() -> f64;
    fn isAnyArrayBuffer(object: JsValue) -> bool;
    fn escape(str: String) -> String;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_CL_SPACE() -> f64;
    fn isFloat64Array(object: JsValue) -> bool;
    fn isMap<T>(object: JsValue) -> bool;
    // constant
    fn SQLITE_READ() -> f64;
    // constant
    fn BROTLI_LARGE_MAX_WINDOW_BITS() -> f64;
    // constant
    fn WSAEPROCLIM() -> f64;
    // constant
    fn static_() -> RequestHandlerConstructor<Response>;
    // constant
    fn ZSTD_c_ldmMinMatch() -> f64;
    fn isMapIterator(object: JsValue) -> bool;
    // constant
    fn SQLITE_PRAGMA() -> f64;
    // constant
    fn HTTP_STATUS_NOT_EXTENDED() -> f64;
    // constant
    fn ZSTD_c_ldmBucketSizeLog() -> f64;
    // constant
    fn BROTLI_DECODER_NEEDS_MORE_INPUT() -> f64;
    fn runInThisContext(code: String, options: Option<JsValue>) -> JsValue;
    // constant
    fn ENOMEM() -> f64;
    fn isBooleanObject(object: JsValue) -> bool;
    // constant
    fn ZSTD_error_GENERIC() -> f64;
    // constant
    fn HTTP2_HEADER_CONTENT_LANGUAGE() -> String;
    fn addSerializeCallback(callback: fn(JsValue) -> JsValue, data: Option<JsValue>);
    // constant
    fn HTTP2_METHOD_POST() -> String;
    // constant
    fn O_RDONLY() -> f64;
    // constant
    fn FIXEDSIZEBLOBCOPY() -> f64;
    // constant
    fn locks() -> LockManager;
    // constant
    fn kStringMaxLength() -> f64;
    fn stripVTControlCharacters(str: String) -> String;
    // constant
    fn ECONNABORTED() -> f64;
    // constant
    fn ZSTD_c_ldmHashRateLog() -> f64;
    // constant
    fn statSync() -> StatSyncFn;
    // constant
    fn WSAETOOMANYREFS() -> f64;
    // constant
    fn HTTP2_METHOD_TRACE() -> String;
    // constant
    fn HTTP2_HEADER_ACCEPT() -> String;
    // merged from 7 overloads
    fn mkdir(path: JsValue, options: MakeDirectoryOptions, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    // constant
    fn RSA_PSS_SALTLEN_DIGEST() -> f64;
    fn isMarkedAsUntransferable(object: JsValue) -> bool;
    // merged from 2 overloads
    fn rename(oldPath: JsValue, newPath: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn ENAMETOOLONG() -> f64;
    fn formatWithOptions(inspectOptions: InspectOptions, format: Option<JsValue>, param: JsArray<JsValue>) -> String;
    // merged from 2 overloads
    fn inflateRaw(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn BROTLI_DEFAULT_WINDOW() -> f64;
    fn setTraceSigInt(enable: bool);
    // constant
    fn ZSTD_c_nbWorkers() -> f64;
    // constant
    fn Z_MAX_CHUNK() -> f64;
    // merged from 8 overloads
    fn only(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    fn TCPWRAP() -> f64;
    // constant
    fn ZLIB() -> f64;
    // constant
    fn KEYGENREQUEST() -> f64;
    fn getCookies(headers: Headers) -> JsValue;
    // constant
    fn Navigator() -> JsValue;
    fn brotliCompressSync(buf: JsValue, options: Option<BrotliOptions>) -> JsValue;
    // merged from 2 overloads
    fn Z_HUFFMAN_ONLY() -> f64;
    // constant
    fn NGHTTP2_CONNECT_ERROR() -> f64;
    fn fdatasync(fd: f64, callback: fn(Option<ErrnoException>) -> ());
    fn hkdf(digest: String, irm: JsValue, salt: JsValue, info: JsValue, keylen: f64, callback: fn(Option<JsValue>, JsValue) -> ());
    // constant
    fn HTTP2_METHOD_MKREDIRECTREF() -> String;
    // merged from 2 overloads
    fn BADFAMILY() -> String;
    // constant
    fn DERIVEBITSREQUEST() -> f64;
    // merged from 2 overloads
    fn inflate(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn ELOOP() -> f64;
    // constant
    fn HTTP_STATUS_USE_PROXY() -> f64;
    // constant
    fn HTTP2_METHOD_CHECKIN() -> String;
    fn createHook(callbacks: HookCallbacks) -> AsyncHook;
    // constant
    fn BROTLI_PARAM_SIZE_HINT() -> f64;
    fn compileFunction(code: String, params: Option<JsArray<String>>, options: Option<CompileFunctionOptions>) -> JsFn;
    fn truncateSync(path: JsValue, len: Option<f64>);
    fn dataSent(params: JsValue);
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS() -> String;
    // constant
    fn HTTP2_HEADER_ACCEPT_RANGES() -> String;
    fn transferableAbortSignal(signal: JsValue) -> JsValue;
    // constant
    fn NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE() -> f64;
    // constant
    fn EEXIST() -> f64;
    // constant
    fn WSAENOTCONN() -> f64;
    // constant
    fn BROTLI_PARAM_LGWIN() -> f64;
    // constant
    fn DEFAULT_MIN_VERSION() -> String;
    // constant
    fn S_IFCHR() -> f64;
    // merged from 2 overloads
    fn Z_SYNC_FLUSH() -> f64;
    // merged from 3 overloads
    fn format(format: Option<JsValue>, param: Option<JsArray<JsValue>>) -> String;
    // constant
    fn defaultCoreCipherList() -> String;
    // constant
    fn MockPool() -> JsValue;
    // constant
    fn EMLINK() -> f64;
    // constant
    fn mockErrors() -> JsValue;
    // constant
    fn WSAENOTSOCK() -> f64;
    // constant
    fn WSAEAFNOSUPPORT() -> f64;
    // constant
    fn EOL() -> String;
    // merged from 2 overloads
    fn decapsulate(key: JsValue, ciphertext: JsValue, callback: Option<fn(JsValue, JsValue) -> ()>);
    fn hkdfSync(digest: String, ikm: JsValue, salt: JsValue, info: JsValue, keylen: f64) -> JsValue;
    // constant
    fn NGHTTP2_STREAM_STATE_RESERVED_LOCAL() -> f64;
    // merged from 2 overloads
    fn close(fd: Option<f64>, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 7 overloads
    fn statfs(path: JsValue, options: Option<StatFsOptions>, callback: Option<fn(Option<ErrnoException>, StatsFs) -> ()>);
    // merged from 4 overloads
    fn fetch(input: Option<JsValue>, init: Option<RequestInit>) -> JsPromise<Response>;
    // merged from 2 overloads
    fn zstdCompress(buf: JsValue, options: ZstdOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn EBADMSG() -> f64;
    fn machine() -> String;
    fn type_() -> String;
    fn webSocketCreated(params: WebSocketCreatedEventDataType);
    // constant
    fn HTTP2_HEADER_MAX_FORWARDS() -> String;
    // constant
    fn O_CREAT() -> f64;
    // merged from 2 overloads
    fn verify(algorithm: Option<String>, data: JsValue, key: JsValue, signature: JsValue, callback: Option<fn(Option<JsValue>, bool) -> ()>);
    // constant
    fn EMULTIHOP() -> f64;
    // constant
    fn RTLD_DEEPBIND() -> f64;
    // constant
    fn HTTP_STATUS_RANGE_NOT_SATISFIABLE() -> f64;
    // constant
    fn RANDOMBYTESREQUEST() -> f64;
    // constant
    fn WSAEINVAL() -> f64;
    fn setEnvironmentData(key: JsValue, value: Option<JsValue>);
    // constant
    fn ENOPROTOOPT() -> f64;
    // merged from 2 overloads
    fn TransformStreamDefaultController() -> JsValue;
    // constant
    fn ENOTTY() -> f64;
    fn isDeepStrictEqual(val1: JsValue, val2: JsValue, options: Option<IsDeepStrictEqualOptions>) -> bool;
    // constant
    fn HTTP2_HEADER_HOST() -> String;
    // merged from 2 overloads
    fn pseudoRandomBytes(size: f64, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn ETXTBSY() -> f64;
    fn writeHeapSnapshot(filename: Option<String>, options: Option<HeapSnapshotOptions>) -> String;
    fn isFloat16Array(object: JsValue) -> bool;
    // merged from 2 overloads
    fn throws(block: fn() -> JsValue, error: JsValue, message: Option<JsValue>);
    // constant
    fn ZSTD_c_jobSize() -> f64;
    fn emitKeypressEvents(stream: ReadableStream, readlineInterface: Option<Interface>);
    fn isReadable(stream: JsValue) -> Option<bool>;
    // constant
    fn HTTP2_HEADER_ACCEPT_CHARSET() -> String;
    // merged from 2 overloads
    fn doesNotThrow(block: fn() -> JsValue, error: JsValue, message: Option<JsValue>);
    // merged from 2 overloads
    fn ReadableStreamDefaultReader() -> JsValue;
    // constant
    fn BROTLI_DECODE() -> f64;
    // constant
    fn X_OK() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1() -> f64;
    fn availableParallelism() -> f64;
    fn responseReceived(params: ResponseReceivedEventDataType);
    // merged from 3 overloads
    fn WebSocket() -> JsValue;
    // constant
    fn S_IFBLK() -> f64;
    // constant
    fn DH_NOT_SUITABLE_GENERATOR() -> f64;
    // constant
    fn HTTP2PING() -> f64;
    fn clearTimeout(timeout: JsValue);
    // constant
    fn PerformanceEntry() -> JsValue;
    // constant
    fn PerformanceResourceTiming() -> JsValue;
    fn lchownSync(path: JsValue, uid: f64, gid: f64);
    fn isUint32Array(object: JsValue) -> bool;
    // constant
    fn EADDRNOTAVAIL() -> f64;
    // constant
    fn SSL_OP_LEGACY_SERVER_CONNECT() -> f64;
    // constant
    fn MockCallHistory() -> JsValue;
    // constant
    fn BROTLI_DEFAULT_QUALITY() -> f64;
    // constant
    fn EMFILE() -> f64;
    // constant
    fn ECONNREFUSED() -> f64;
    // constant
    fn builtinModules() -> JsArray<String>;
    // constant
    fn NGHTTP2_INADEQUATE_SECURITY() -> f64;
    // constant
    fn WSATYPE_NOT_FOUND() -> f64;
    // constant
    fn DEFLATE() -> f64;
    fn getAssetKeys() -> JsArray<String>;
    // constant
    fn WSAENOBUFS() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_MAJOR() -> f64;
    // constant
    fn NGHTTP2_REFUSED_STREAM() -> f64;
    // merged from 8 overloads
    fn glob(pattern: JsValue, options: Option<GlobOptionsWithFileTypes>, callback: Option<fn(Option<ErrnoException>, JsArray<Dirent>) -> ()>);
    fn setFips(bool: bool);
    // constant
    fn WSAVERNOTSUPPORTED() -> f64;
    fn ifError(value: JsValue) -> bool;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_DICTIONARY() -> f64;
    // merged from 2 overloads
    fn resolvePtr(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    // constant
    fn ZSTD_c_chainLog() -> f64;
    // merged from 2 overloads
    fn ReadableStream() -> JsValue;
    // constant
    fn HTTP_STATUS_NOT_IMPLEMENTED() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_NO() -> f64;
    // merged from 2 overloads
    fn createSocket(type_: String, callback: Option<fn(JsValue, RemoteInfo) -> ()>) -> Socket;
    // constant
    fn ENGINE_METHOD_CIPHERS() -> f64;
    // constant
    fn DNSCHANNEL() -> f64;
    // constant
    fn URLSearchParams() -> JsValue;
    // constant
    fn HTTP_STATUS_PROCESSING() -> f64;
    // constant
    fn REPL_MODE_SLOPPY() -> JsValue;
    // constant
    fn POINT_CONVERSION_UNCOMPRESSED() -> f64;
    // constant
    fn WSASERVICE_NOT_FOUND() -> f64;
    fn wrap(script: String) -> String;
    fn ftruncateSync(fd: f64, len: Option<f64>);
    // constant
    fn ENGINE_METHOD_PKEY_ASN1_METHS() -> f64;
    // constant
    fn ZSTD_e_end() -> f64;
    // constant
    fn PRIORITY_NORMAL() -> f64;
    // merged from 3 overloads
    fn watchFile(filename: JsValue, options: Option<WatchFileOptions>, listener: Option<JsValue>) -> StatWatcher;
    // constant
    fn ErrorEvent() -> JsValue;
    // constant
    fn HTTP2_HEADER_LINK() -> String;
    // constant
    fn HTTP2_METHOD_MKCOL() -> String;
    fn e() -> Express;
    // constant
    fn module() -> Module;
    // merged from 5 overloads
    fn open(path: JsValue, flags: Option<JsValue>, mode: Option<JsValue>, callback: Option<fn(Option<ErrnoException>, f64) -> ()>);
    // constant
    fn EISCONN() -> f64;
    // constant
    fn ENETRESET() -> f64;
    // constant
    fn WSASYSNOTREADY() -> f64;
    // constant
    fn PADDING_STRATEGY_NONE() -> f64;
    // merged from 2 overloads
    fn utimes(path: JsValue, atime: JsValue, mtime: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    fn getRawAsset(key: String) -> JsValue;
    // constant
    fn EHOSTUNREACH() -> f64;
    // constant
    fn HTTP2_HEADER_HTTP2_SETTINGS() -> String;
    // constant
    fn lcov() -> ReporterConstructorWrapper<JsValue>;
    // constant
    fn HTTP2_HEADER_TRANSFER_ENCODING() -> String;
    // constant
    fn DONT_CONTEXTIFY() -> f64;
    fn isCryptoKey(object: JsValue) -> bool;
    // constant
    fn ENXIO() -> f64;
    // constant
    fn UDPWRAP() -> f64;
    fn createDeflateRaw(options: Option<ZlibOptions>) -> DeflateRaw;
    // constant
    fn O_NOCTTY() -> f64;
    // constant
    fn S_IXOTH() -> f64;
    // constant
    fn ZSTD_c_windowLog() -> f64;
    fn serialize(value: JsValue) -> JsValue;
    // constant
    fn EINPROGRESS() -> f64;
    // constant
    fn HTTP2_HEADER_AUTHORITY() -> String;
    // constant
    fn HTTP2_HEADER_RETRY_AFTER() -> String;
    // constant
    fn HTTP2_METHOD_DELETE() -> String;
    // constant
    fn HTTP_STATUS_LOOP_DETECTED() -> f64;
    // constant
    fn HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED() -> f64;
    fn setSourceMapsSupport(enabled: bool, options: Option<SetSourceMapsSupportOptions>);
    // constant
    fn HTTP_STATUS_TOO_MANY_REQUESTS() -> f64;
    // merged from 4 overloads
    fn fstat(fd: f64, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // merged from 2 overloads
    fn ReadableStreamDefaultController() -> JsValue;
    // constant
    fn ESRCH() -> f64;
    // constant
    fn HTTP2_HEADER_IF_RANGE() -> String;
    // constant
    fn HTTP_STATUS_NO_CONTENT() -> f64;
    fn rmSync(path: JsValue, options: Option<RmOptions>);
    // constant
    fn HTTP2_HEADER_USER_AGENT() -> String;
    fn isDate(object: JsValue) -> bool;
    fn utimesSync(path: JsValue, atime: JsValue, mtime: JsValue);
    // constant
    fn RSA_X931_PADDING() -> f64;
    fn argon2(algorithm: String, parameters: Argon2Parameters, callback: fn(Option<JsValue>, JsValue) -> ());
    fn isAsyncFunction(object: JsValue) -> bool;
    fn deserialize(buffer: JsValue) -> JsValue;
    // constant
    fn WSAEADDRINUSE() -> f64;
    // constant
    fn EPROTOTYPE() -> f64;
    // constant
    fn HTTP2STREAM() -> f64;
    // constant
    fn DecompressionStream() -> JsValue;
    // merged from 2 overloads
    fn buildConnector(options: Option<JsValue>) -> connector;
    // constant
    fn install() -> JsValue;
    // constant
    fn Z_MIN_CHUNK() -> f64;
    // constant
    fn ALL() -> f64;
    // constant
    fn SSL_OP_NO_QUERY_MTU() -> f64;
    // constant
    fn SQLITE_FUNCTION() -> f64;
    // merged from 7 overloads
    fn request(url: Option<JsValue>, options: Option<RequestOptions>, callback: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // merged from 2 overloads
    fn FormData() -> JsValue;
    fn isWeakSet(object: JsValue) -> bool;
    // merged from 2 overloads
    fn setGlobalDispatcher<DispatcherImplementation>(dispatcher: Option<DispatcherImplementation>);
    // constant
    fn HTTP2_HEADER_METHOD() -> String;
    // merged from 2 overloads
    fn getGlobalDispatcher() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_RESERVED() -> f64;
    fn deepEqual(actual: JsValue, expected: JsValue, message: Option<JsValue>);
    fn exists(path: JsValue, callback: fn(bool) -> ());
    fn checkPrimeSync(candidate: JsValue, options: Option<CheckPrimeOptions>) -> bool;
    // constant
    fn ZSTD_DECOMPRESS() -> f64;
    // merged from 3 overloads
    fn statfsSync(path: JsValue, options: Option<StatFsOptions>) -> StatsFs;
    // constant
    fn ENOEXEC() -> f64;
    // constant
    fn Agent() -> JsValue;
    // constant
    fn GETNAMEINFOREQWRAP() -> f64;
    // constant
    fn BroadcastChannel() -> JsValue;
    // constant
    fn BROTLI_PARAM_NPOSTFIX() -> f64;
    // constant
    fn scheduler() -> Scheduler;
    fn endianness() -> String;
    fn dataReceived(params: DataReceivedEventDataType);
    // constant
    fn NGHTTP2_SETTINGS_MAX_FRAME_SIZE() -> f64;
    // constant
    fn SQLITE_DROP_TEMP_TABLE() -> f64;
    // NOTE: constraint on `Http2Response` not enforced
    fn performServerHandshake<Http1Request, Http1Response, Http2Request, Http2Response>(socket: Duplex, options: Option<ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>>) -> ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
    // constant
    fn TCPCONNECTWRAP() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET() -> f64;
    // constant
    fn SQLITE_CHANGESET_DATA() -> f64;
    fn isSet<T>(object: JsValue) -> bool;
    // constant
    fn SQLITE_DROP_TEMP_TRIGGER() -> f64;
    fn stripTypeScriptTypes(code: String, options: Option<StripTypeScriptTypesOptions>) -> String;
    // merged from 7 overloads
    fn stat(path: JsValue, options: Option<StatOptions>, callback: Option<fn(Option<ErrnoException>, Stats) -> ()>);
    // constant
    fn HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE() -> f64;
    // constant
    fn WSAEUSERS() -> f64;
    // constant
    fn RTLD_LOCAL() -> f64;
    // constant
    fn HTTP2_HEADER_PROXY_AUTHENTICATE() -> String;
    fn futimes(fd: f64, atime: JsValue, mtime: JsValue, callback: fn(Option<ErrnoException>) -> ());
    // constant
    fn INFLATERAW() -> f64;
    fn getSystemErrorName(err: f64) -> String;
    // constant
    fn SQLITE_CREATE_TEMP_VIEW() -> f64;
    // merged from 2 overloads
    fn encode(string: Option<String>) -> String;
    // constant
    fn EFBIG() -> f64;
    // constant
    fn HTTP2_METHOD_REBIND() -> String;
    // merged from 2 overloads
    fn Z_NEED_DICT() -> f64;
    // merged from 2 overloads
    fn rejects(block: JsValue, error: JsValue, message: Option<JsValue>) -> JsPromise<()>;
    fn freemem() -> f64;
    // constant
    fn CustomEvent() -> JsValue;
    // constant
    fn crypto() -> JsValue;
    // constant
    fn SlowBuffer() -> JsValue;
    // constant
    fn PerformanceObserverEntryList() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_UNREACHABLE() -> f64;
    fn structuredClone<T>(value: T, options: Option<JsValue>) -> T;
    // constant
    fn HTTP_STATUS_VARIANT_ALSO_NEGOTIATES() -> f64;
    fn getEnabledCategories() -> Option<String>;
    fn run(options: Option<RunOptions>) -> TestsStream;
    // merged from 3 overloads
    fn finished(stream: JsValue, options: FinishedOptions, callback: Option<fn(Option<ErrnoException>) -> ()>) -> fn() -> ();
    // merged from 2 overloads
    fn decode(string: Option<String>) -> String;
    fn urlToHttpOptions(url: URL) -> ClientRequestArgs;
    // constant
    fn ZSTD_c_dictIDFlag() -> f64;
    // constant
    fn PRIORITY_LOW() -> f64;
    // constant
    fn HTTP2_METHOD_UNCHECKOUT() -> String;
    // constant
    fn WSAEMSGSIZE() -> f64;
    fn generateKeySync(type_: String, options: JsValue) -> KeyObject;
    // constant
    fn DIRHANDLE() -> f64;
    // constant
    fn BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING() -> f64;
    // constant
    fn Assert() -> JsValue;
    // constant
    fn MAX_INITIAL_WINDOW_SIZE() -> f64;
    // constant
    fn NGHTTP2_STREAM_STATE_IDLE() -> f64;
    // constant
    fn SQLITE_DELETE() -> f64;
    // constant
    fn HTTP2_HEADER_VIA() -> String;
    // constant
    fn Blob() -> JsValue;
    fn parseHeaders(headers: JsArray<JsValue>, obj: Option<JsValue>) -> JsValue;
    // merged from 5 overloads
    fn createDecipheriv(algorithm: String, key: JsValue, iv: JsValue, options: CipherCCMOptions) -> DecipherCCM;
    // constant
    fn HTTP2_HEADER_ALLOW() -> String;
    // constant
    fn HTTP2_HEADER_KEEP_ALIVE() -> String;
    // merged from 6 overloads
    fn resolve6(hostname: String, options: Option<ResolveWithTtlOptions>, callback: Option<fn(Option<ErrnoException>, JsArray<RecordWithTtl>) -> ()>);
    // merged from 3 overloads
    fn userInfo(options: Option<UserInfoOptionsWithStringEncoding>) -> UserInfo<String>;
    // constant
    fn RSA_PKCS1_PADDING() -> f64;
    fn readvSync(fd: f64, buffers: JsArray<JsValue>, position: Option<f64>) -> f64;
    // constant
    fn HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS() -> f64;
    // constant
    fn DH_CHECK_P_NOT_PRIME() -> f64;
    fn zstdCompressSync(buf: JsValue, options: Option<ZstdOptions>) -> JsValue;
    fn setGlobalOrigin(origin: JsValue);
    // merged from 6 overloads
    fn resolve4(hostname: String, options: Option<ResolveWithTtlOptions>, callback: Option<fn(Option<ErrnoException>, JsArray<RecordWithTtl>) -> ()>);
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED() -> f64;
    // constant
    fn ETIMEDOUT() -> f64;
    // constant
    fn SSL_OP_NO_TLSv1_2() -> f64;
    // constant
    fn STATWATCHER() -> f64;
    // constant
    fn PROMISE() -> f64;
    fn isBuildingSnapshot() -> bool;
    // constant
    fn AbortController() -> JsValue;
    fn getDiffieHellman(groupName: String) -> JsValue;
    // constant
    fn SIGNREQUEST() -> f64;
    // constant
    fn HTTP2_HEADER_ACCEPT_ENCODING() -> String;
    // merged from 2 overloads
    fn NOMEM() -> String;
    fn isSymbolObject(object: JsValue) -> bool;
    fn appendFileSync(path: JsValue, data: JsValue, options: Option<JsValue>);
    // constant
    fn UV_UDP_REUSEADDR() -> f64;
    // constant
    fn isMainThread() -> bool;
    fn setDefaultHighWaterMark(objectMode: bool, value: f64);
    fn createBrotliCompress(options: Option<BrotliOptions>) -> BrotliCompress;
    fn setHeapSnapshotNearHeapLimit(limit: f64);
    // constant
    fn NGHTTP2_HTTP_1_1_REQUIRED() -> f64;
    // constant
    fn HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED() -> f64;
    // constant
    fn HTTP_STATUS_MULTI_STATUS() -> f64;
    // constant
    fn PerformanceMeasure() -> JsValue;
    // constant
    fn SSL_OP_NO_TLSv1_3() -> f64;
    fn clearImmediate(immediate: Option<Immediate>);
    fn executionAsyncId() -> f64;
    // constant
    fn RetryHandler() -> JsValue;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_DISTANCE() -> f64;
    // constant
    fn DEFAULT_MAX_VERSION() -> String;
    fn inflateRawSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // merged from 2 overloads
    fn getCallSites(frameCount: Option<f64>, options: Option<GetCallSitesOptions>) -> JsArray<CallSiteObject>;
    fn lchmodSync(path: JsValue, mode: JsValue);
    // constant
    fn HTTP_STATUS_UNPROCESSABLE_ENTITY() -> f64;
    fn getCurves() -> JsArray<String>;
    // constant
    fn HTTPCLIENTREQUEST() -> f64;
    // constant
    fn SQLITE_IGNORE() -> f64;
    // constant
    fn response() -> Response;
    // constant
    fn SQLITE_SELECT() -> f64;
    // constant
    fn S_IWUSR() -> f64;
    // merged from 2 overloads
    fn NONAME() -> String;
    // constant
    fn SSL_OP_CRYPTOPRO_TLSEXT_BUG() -> f64;
    // merged from 2 overloads
    fn Z_BEST_COMPRESSION() -> f64;
    // constant
    fn DH_CHECK_P_NOT_SAFE_PRIME() -> f64;
    // merged from 5 overloads
    fn createCipheriv(algorithm: String, key: JsValue, iv: JsValue, options: CipherCCMOptions) -> CipherCCM;
    // constant
    fn MessageChannel() -> JsValue;
    // merged from 4 overloads
    fn randomInt(min: f64, max: Option<f64>, callback: Option<fn(Option<JsValue>, f64) -> ()>);
    fn arrayBuffer(stream: JsValue) -> JsPromise<JsValue>;
    // merged from 2 overloads
    fn sign(algorithm: Option<String>, data: JsValue, key: JsValue, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    fn webSocketClosed(params: WebSocketClosedEventDataType);
    // constant
    fn DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE() -> f64;
    // constant
    fn COPYFILE_FICLONE_FORCE() -> f64;
    // merged from 2 overloads
    fn TransformStream() -> JsValue;
    // constant
    fn HTTP2_METHOD_VERSION_CONTROL() -> String;
    fn createWriteStream(path: JsValue, options: Option<JsValue>) -> WriteStream;
    fn receiveMessageOnPort(port: MessagePort) -> Option<JsValue>;
    // constant
    fn BROTLI_PARAM_LGBLOCK() -> f64;
    // constant
    fn BROTLI_MAX_QUALITY() -> f64;
    // constant
    fn CIPHERREQUEST() -> f64;
    // constant
    fn ENOLINK() -> f64;
    fn isSea() -> bool;
    // constant
    fn SSL_OP_NO_TLSv1() -> f64;
    fn getCipherInfo(nameOrNid: JsValue, options: Option<CipherInfoOptions>) -> Option<CipherInfo>;
    fn isProxy(object: JsValue) -> bool;
    // constant
    fn S_IFDIR() -> f64;
    fn privateDecrypt(privateKey: JsValue, buffer: JsValue) -> JsValue;
    // constant
    fn BROTLI_DECODER_PARAM_LARGE_WINDOW() -> f64;
    fn loadavg() -> JsArray<f64>;
    // constant
    fn HTTP2_HEADER_ETAG() -> String;
    // constant
    fn RedirectHandler() -> JsValue;
    // constant
    fn DEFAULT_ECDH_CURVE() -> String;
    // merged from 2 overloads
    fn NOTINITIALIZED() -> String;
    // constant
    fn SSL_OP_COOKIE_EXCHANGE() -> f64;
    // constant
    fn HTTP2_HEADER_LOCATION() -> String;
    // constant
    fn O_NOATIME() -> f64;
    // constant
    fn ZSTD_error_dictionaryCreation_failed() -> f64;
    fn diff(actual: JsValue, expected: JsValue) -> JsArray<(JsValue, String)>;
    // constant
    fn EOVERFLOW() -> f64;
    fn fdatasyncSync(fd: f64);
    fn getDefaultHighWaterMark(objectMode: bool) -> f64;
    fn before(fn_: Option<JsValue>, options: Option<HookOptions>);
    // constant
    fn REPL_MODE_STRICT() -> JsValue;
    // constant
    fn EXDEV() -> f64;
    // constant
    fn EINVAL() -> f64;
    // constant
    fn HTTP_STATUS_REQUEST_TIMEOUT() -> f64;
    // constant
    fn HTTP2_METHOD_CONNECT() -> String;
    fn pbkdf2(password: JsValue, salt: JsValue, iterations: f64, keylen: f64, digest: String, callback: fn(Option<JsValue>, JsValue) -> ());
    // constant
    fn PRIORITY_ABOVE_NORMAL() -> f64;
    // merged from 4 overloads
    fn exec(command: String, options: ExecOptionsWithBufferEncoding, callback: Option<fn(Option<ExecException>, JsValue, JsValue) -> ()>) -> ChildProcess;
    // constant
    fn RSA_PKCS1_OAEP_PADDING() -> f64;
    // constant
    fn FILEHANDLE() -> f64;
    // constant
    fn S_IWOTH() -> f64;
    // constant
    fn SQLITE_CREATE_VIEW() -> f64;
    // constant
    fn BROTLI_PARAM_MODE() -> f64;
    // constant
    fn NGHTTP2_SETTINGS_TIMEOUT() -> f64;
    // constant
    fn HTTP2SESSION() -> f64;
    // constant
    fn defaultOptions() -> InspectOptions;
    // merged from 2 overloads
    fn WritableStreamDefaultController() -> JsValue;
    fn randomUUID(options: Option<RandomUUIDOptions>) -> String;
    fn isWeakMap(object: JsValue) -> bool;
    // constant
    fn COPYFILE_FICLONE() -> f64;
    // constant
    fn ZSTD_error_stage_wrong() -> f64;
    // merged from 2 overloads
    fn Z_PARTIAL_FLUSH() -> f64;
    // constant
    fn ZSTD_c_searchLog() -> f64;
    // constant
    fn DiffieHellmanGroup() -> DiffieHellmanGroupConstructor;
    fn isArrayBuffer(object: JsValue) -> bool;
    fn transferableAbortController() -> AbortController;
    // constant
    fn ZSTD_error_parameter_combination_unsupported() -> f64;
    // constant
    fn SQLITE_CHANGESET_ABORT() -> f64;
    // constant
    fn webcrypto() -> Crypto;
    fn match_(value: String, regExp: JsValue, message: Option<JsValue>);
    fn buffer(stream: JsValue) -> JsPromise<JsValue>;
    // merged from 3 overloads
    fn copyFile(src: JsValue, dest: JsValue, mode: f64, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn ZSTD_error_dstBuffer_null() -> f64;
    // merged from 2 overloads
    fn Z_DATA_ERROR() -> f64;
    // constant
    fn ENGINE_METHOD_RAND() -> f64;
    // merged from 2 overloads
    fn BADFLAGS() -> String;
    fn clearLine(stream: WritableStream, dir: JsValue, callback: Option<fn() -> ()>) -> bool;
    // constant
    fn HTTP2_HEADER_PATH() -> String;
    // constant
    fn HTTP_STATUS_OK() -> f64;
    fn deflateSync(buf: JsValue, options: Option<ZlibOptions>) -> JsValue;
    // constant
    fn HTTP_STATUS_CREATED() -> f64;
    // merged from 2 overloads
    fn doesNotReject(block: JsValue, error: JsValue, message: Option<JsValue>) -> JsPromise<()>;
    // constant
    fn GUNZIP() -> f64;
    // constant
    fn SQLITE_DROP_TEMP_INDEX() -> f64;
    // constant
    fn ZSTD_c_ldmHashLog() -> f64;
    // constant
    fn HTTP2_METHOD_PATCH() -> String;
    // constant
    fn ENGINE_METHOD_PKEY_METHS() -> f64;
    // constant
    fn NONE() -> f64;
    // merged from 2 overloads
    fn text(stream: Option<JsValue>) -> JsPromise<String>;
    fn createGunzip(options: Option<ZlibOptions>) -> Gunzip;
    // merged from 2 overloads
    fn unlink(path: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // merged from 2 overloads
    fn ADDRGETNETWORKPARAMS() -> String;
    fn isInt32Array(object: JsValue) -> bool;
    // constant
    fn ENOSR() -> f64;
    fn isUint8Array(object: JsValue) -> bool;
    // constant
    fn HTTP2_HEADER_REFERER() -> String;
    // merged from 8 overloads
    fn execFile(file: String, args: Option<JsArray<String>>, options: Option<ExecFileOptionsWithBufferEncoding>, callback: Option<fn(Option<JsValue>, JsValue, JsValue) -> ()>) -> ChildProcess;
    fn dns(opts: Option<JsValue>) -> fn(JsValue) -> JsValue;
    fn cachedDataVersionTag() -> f64;
    // constant
    fn GZIP() -> f64;
    fn createInflateRaw(options: Option<ZlibOptions>) -> InflateRaw;
    // constant
    fn PerformanceObserver() -> JsValue;
    // merged from 2 overloads
    fn Z_BUF_ERROR() -> f64;
    // merged from 2 overloads
    fn Z_OK() -> f64;
    // constant
    fn SQLITE_CREATE_VTABLE() -> f64;
    // constant
    fn ZSTD_c_minMatch() -> f64;
    // constant
    fn HTTP2_METHOD_MKWORKSPACE() -> String;
    // constant
    fn ZSTD_c_overlapLog() -> f64;
    fn fchown(fd: f64, uid: f64, gid: f64, callback: fn(Option<ErrnoException>) -> ());
    fn chownSync(path: JsValue, uid: f64, gid: f64);
    // constant
    fn lstatSync() -> StatSyncFn;
    // merged from 5 overloads
    fn read<TBuffer>(fd: f64, buffer: TBuffer, offset: Option<f64>, length: Option<f64>, position: Option<JsValue>, callback: Option<fn(Option<ErrnoException>, f64, TBuffer) -> ()>);
    // constant
    fn W_OK() -> f64;
    fn loadingFinished(params: LoadingFinishedEventDataType);
    // merged from 4 overloads
    fn globSync(pattern: JsValue, options: Option<GlobOptionsWithFileTypes>) -> JsArray<Dirent>;
    fn uptime() -> f64;
    // merged from 2 overloads
    fn resolveAny(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<JsValue>) -> ()>);
    // constant
    fn SSL_OP_NO_TICKET() -> f64;
    // constant
    fn HTTP2_HEADER_PROXY_CONNECTION() -> String;
    fn isBigUint64Array(value: JsValue) -> bool;
    fn isArrayBufferView(object: JsValue) -> bool;
    fn argon2Sync(algorithm: String, parameters: Argon2Parameters) -> JsValue;
    fn fileURLToPathBuffer(url: JsValue, options: Option<FileUrlToPathOptions>) -> JsValue;
    fn createTracing(options: CreateTracingOptions) -> Tracing;
    // merged from 3 overloads
    fn readlinkSync(path: JsValue, options: Option<JsValue>) -> String;
    // constant
    fn HTTP2_HEADER_UPGRADE() -> String;
    // constant
    fn HTTP_STATUS_CONTINUE() -> f64;
    // constant
    fn ZSTD_btultra() -> f64;
    fn setDeserializeMainFunction(callback: fn(JsValue) -> JsValue, data: Option<JsValue>);
    fn fchmodSync(fd: f64, mode: JsValue);
    // merged from 2 overloads
    fn Z_NO_COMPRESSION() -> f64;
    fn syncBuiltinESMExports();
    // constant
    fn WSAENETUNREACH() -> f64;
    // constant
    fn ENODEV() -> f64;
    // constant
    fn WSAECONNRESET() -> f64;
    // constant
    fn EBADF() -> f64;
    fn unlinkSync(path: JsValue);
    fn getCppHeapStatistics(detailLevel: Option<String>) -> JsValue;
    // merged from 8 overloads
    fn skip(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // merged from 2 overloads
    fn reverse(ip: String, callback: Option<fn(Option<ErrnoException>, JsArray<String>) -> ()>);
    // constant
    fn ENGINE_METHOD_EC() -> f64;
    // constant
    fn ZSTD_error_stabilityCondition_notRespected() -> f64;
    // constant
    fn PIPECONNECTWRAP() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES() -> f64;
    // constant
    fn devNull() -> String;
    // constant
    fn HTTP_STATUS_INTERNAL_SERVER_ERROR() -> f64;
    fn getDefaultAutoSelectFamily() -> bool;
    fn fileURLToPath(url: JsValue, options: Option<FileUrlToPathOptions>) -> String;
    // constant
    fn MockAgent() -> JsValue;
    // constant
    fn WSAECONNABORTED() -> f64;
    // constant
    fn JSUDPWRAP() -> f64;
    fn createReadStream(path: JsValue, options: Option<JsValue>) -> ReadStream;
    // constant
    fn Crypto() -> JsValue;
    fn createZstdDecompress(options: Option<ZstdOptions>) -> ZstdDecompress;
    // constant
    fn HTTP_STATUS_PARTIAL_CONTENT() -> f64;
    // constant
    fn EADDRINUSE() -> f64;
    // constant
    fn isInternalThread() -> bool;
    // merged from 2 overloads
    fn Z_BLOCK() -> f64;
    fn requestWillBeSent(params: RequestWillBeSentEventDataType);
    fn getDefaultSettings() -> Settings;
    // constant
    fn SQLITE_DROP_TRIGGER() -> f64;
    // constant
    fn require() -> Require;
    // constant
    fn HTTP2_HEADER_ACCEPT_LANGUAGE() -> String;
    fn aborted(signal: JsValue, resource: JsValue) -> JsPromise<()>;
    // constant
    fn BROTLI_DECODER_NEEDS_MORE_OUTPUT() -> f64;
    fn hostname() -> String;
    // constant
    fn O_NOFOLLOW() -> f64;
    fn writevSync(fd: f64, buffers: JsArray<JsValue>, position: Option<f64>) -> f64;
    // constant
    fn WSAEPFNOSUPPORT() -> f64;
    // merged from 2 overloads
    fn deflate(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn RTLD_NOW() -> f64;
    fn monitorEventLoopDelay(options: Option<EventLoopMonitorOptions>) -> IntervalHistogram;
    // constant
    fn ENFILE() -> f64;
    // constant
    fn PIPESERVERWRAP() -> f64;
    // merged from 2 overloads
    fn Z_VERSION_ERROR() -> f64;
    fn setResolveSnapshotPath(fn_: fn(Option<String>) -> String);
    // constant
    fn HTTP_STATUS_BAD_GATEWAY() -> f64;
    // merged from 4 overloads
    fn execSync(command: String, options: Option<ExecSyncOptionsWithStringEncoding>) -> String;
    fn assert(value: JsValue, message: Option<JsValue>) -> bool;
    fn isInt8Array(object: JsValue) -> bool;
    // constant
    fn WSAEINVALIDPROVIDER() -> f64;
    // constant
    fn SQLITE_INSERT() -> f64;
    // merged from 7 overloads
    fn readFile(path: JsValue, options: Option<Abortable>, callback: Option<fn(Option<ErrnoException>, JsValue) -> ()>);
    // constant
    fn UV_FS_O_FILEMAP() -> f64;
    // constant
    fn HTTP2_HEADER_IF_MATCH() -> String;
    // merged from 7 overloads
    fn watch(filename: JsValue, options: Option<JsValue>, listener: Option<fn(String, Option<JsValue>) -> ()>) -> FSWatcher;
    // constant
    fn ZSTD_c_compressionLevel() -> f64;
    // constant
    fn SQLITE_CHANGESET_CONFLICT() -> f64;
    // constant
    fn HTTP_STATUS_SWITCHING_PROTOCOLS() -> f64;
    // constant
    fn ELDHISTOGRAM() -> f64;
    // merged from 2 overloads
    fn brotliDecompress(buf: JsValue, options: BrotliOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn HTTP2_HEADER_CONTENT_DISPOSITION() -> String;
    // merged from 3 overloads
    fn createConnection(port: f64, host: Option<String>, connectionListener: Option<fn() -> ()>) -> Socket;
    // constant
    fn ZSTD_c_hashLog() -> f64;
    // constant
    fn HTTP2_HEADER_CACHE_CONTROL() -> String;
    // constant
    fn R_OK() -> f64;
    fn doesNotMatch(value: String, regExp: JsValue, message: Option<JsValue>);
    // constant
    fn BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1() -> f64;
    // constant
    fn ZSTD_error_literals_headerWrong() -> f64;
    fn beforeEach(fn_: Option<JsValue>, options: Option<HookOptions>);
    // merged from 4 overloads
    fn generatePrime(size: f64, options: GeneratePrimeOptionsBigInt, callback: Option<fn(Option<JsValue>, i64) -> ()>);
    // constant
    fn HTTP2_HEADER_FROM() -> String;
    // merged from 3 overloads
    fn mkdirSync(path: JsValue, options: MakeDirectoryOptions) -> Option<String>;
    fn deepStrictEqual<T>(actual: JsValue, expected: T, message: Option<JsValue>) -> bool;
    // constant
    fn BROTLI_MODE_FONT() -> f64;
    // constant
    fn ENGINE_METHOD_RSA() -> f64;
    // merged from 2 overloads
    fn unzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // merged from 2 overloads
    fn Z_STREAM_ERROR() -> f64;
    // constant
    fn NGHTTP2_STREAM_STATE_OPEN() -> f64;
    // merged from 2 overloads
    fn EventSource() -> JsValue;
    fn isUint16Array(object: JsValue) -> bool;
    // constant
    fn CacheStorage() -> JsValue;
    // constant
    fn writer() -> JsFn;
    // merged from 7 overloads
    fn mkdtemp(prefix: String, options: JsValue, callback: Option<fn(Option<ErrnoException>, String) -> ()>);
    fn parseEnv(content: String) -> Dict<String>;
    fn put(url: String, data: String);
    // merged from 10 overloads
    fn connect(port: Option<f64>, host: Option<String>, options: Option<ConnectionOptions>, secureConnectListener: Option<fn() -> ()>) -> TLSSocket;
    // constant
    fn kMaxLength() -> f64;
    // merged from 2 overloads
    fn unwatchFile(filename: JsValue, listener: Option<JsValue>);
    // constant
    fn HTTP2_HEADER_PREFER() -> String;
    // constant
    fn SQLITE_CREATE_TEMP_TABLE() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_INCREMENTAL() -> f64;
    // constant
    fn ZSTD_error_dictionary_wrong() -> f64;
    // constant
    fn ENETUNREACH() -> f64;
    fn backup(sourceDb: DatabaseSync, path: JsValue, options: Option<BackupOptions>) -> JsPromise<f64>;
    // constant
    fn EISDIR() -> f64;
    // constant
    fn NGHTTP2_SESSION_CLIENT() -> f64;
    fn createHistogram(options: Option<CreateHistogramOptions>) -> RecordableHistogram;
    // constant
    fn HTTP_STATUS_FOUND() -> f64;
    fn toUSVString(string: String) -> String;
    fn getSourceMapsSupport() -> SourceMapsSupport;
    // constant
    fn EFAULT() -> f64;
    // constant
    fn HTTP2_METHOD_UPDATE() -> String;
    // constant
    fn ETIME() -> f64;
    // merged from 2 overloads
    fn encapsulate(key: JsValue, callback: Option<fn(JsValue, JsValue) -> ()>);
    // merged from 3 overloads
    fn hash(algorithm: String, data: JsValue, options: Option<JsValue>) -> String;
    // constant
    fn DecoratorHandler() -> JsValue;
    fn createVerify(algorithm: String, options: Option<WritableOptions>) -> Verify;
    // constant
    fn ENOSTR() -> f64;
    // constant
    fn EROFS() -> f64;
    fn isWritable(stream: JsValue) -> Option<bool>;
    fn totalmem() -> f64;
    // constant
    fn WSAECANCELLED() -> f64;
    // constant
    fn HTTP_STATUS_UNORDERED_COLLECTION() -> f64;
    // constant
    fn HTTP2_HEADER_AUTHORIZATION() -> String;
    // constant
    fn SSL_OP_TLS_ROLLBACK_BUG() -> f64;
    // constant
    fn Client() -> JsValue;
    // merged from 4 overloads
    fn get(url: JsValue, options: RequestOptions, callback: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // constant
    fn EDOM() -> f64;
    // NOTE: constraint on `T` not enforced
    fn deprecate<T>(fn_: T, msg: String, code: Option<String>) -> T;
    // constant
    fn HTTP_STATUS_TEAPOT() -> f64;
    fn fchownSync(fd: f64, uid: f64, gid: f64);
    // constant
    fn O_RDWR() -> f64;
    // constant
    fn NGHTTP2_FLAG_END_HEADERS() -> f64;
    // constant
    fn ZSTD_error_prefix_unknown() -> f64;
    fn cursorTo(stream: WritableStream, x: f64, y: Option<f64>, callback: Option<fn() -> ()>) -> bool;
    fn isBuiltin(moduleName: String) -> bool;
    fn copyFileSync(src: JsValue, dest: JsValue, mode: Option<f64>);
    // merged from 2 overloads
    fn BADHINTS() -> String;
    // constant
    fn SQLITE_DROP_TABLE() -> f64;
    fn pathToFileURL(path: String, options: Option<PathToFileUrlOptions>) -> URL;
    // merged from 3 overloads
    fn realpathSync(path: JsValue, options: Option<JsValue>) -> String;
    // merged from 2 overloads
    fn resolveCaa(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<CaaRecord>) -> ()>);
    // constant
    fn KEYEXPORTREQUEST() -> f64;
    // constant
    fn application() -> Application;
    // constant
    fn ZSTD_d_windowLogMax() -> f64;
    // constant
    fn HTTP_STATUS_GONE() -> f64;
    fn Router(options: Option<RouterOptions>) -> Router;
    // constant
    fn threadId() -> f64;
    // merged from 2 overloads
    fn readv<TBuffers>(fd: f64, buffers: TBuffers, position: Option<f64>, cb: Option<fn(Option<ErrnoException>, f64, TBuffers) -> ()>);
    fn createECDH(curveName: String) -> ECDH;
    // constant
    fn ZSTD_error_parameter_outOfBound() -> f64;
    fn blob(stream: JsValue) -> JsPromise<JsValue>;
    // merged from 3 overloads
    fn setTimeout<T>(delay: Option<f64>, value: Option<T>, options: Option<TimerOptions>) -> JsPromise<T>;
    // constant
    fn URLPattern() -> JsValue;
    // constant
    fn JSSTREAM() -> f64;
    // constant
    fn ZSTD_c_contentSizeFlag() -> f64;
    fn isNumberObject(object: JsValue) -> bool;
    // constant
    fn SQLITE_ALTER_TABLE() -> f64;
    // merged from 4 overloads
    fn createInterface(input: ReadableStream, output: Option<WritableStream>, completer: Option<fn(String) -> JsValue>, terminal: Option<bool>) -> Interface;
    // constant
    fn signals() -> JsValue;
    fn inherits(constructor: JsValue, superConstructor: JsValue);
    // constant
    fn DEFAULT_SETTINGS_HEADER_TABLE_SIZE() -> f64;
    // constant
    fn HTTP2_HEADER_CONNECTION() -> String;
    // constant
    fn BROTLI_DEFAULT_MODE() -> f64;
    // constant
    fn NGHTTP2_PROTOCOL_ERROR() -> f64;
    fn isIPv6(input: String) -> bool;
    fn createSign(algorithm: String, options: Option<WritableOptions>) -> Sign;
    // constant
    fn kOptions() -> JsValue;
    // constant
    fn __filename() -> String;
    // constant
    fn HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS() -> String;
    // merged from 2 overloads
    fn BADRESP() -> String;
    // merged from 2 overloads
    fn Z_RLE() -> f64;
    // constant
    fn ZSTD_error_srcSize_wrong() -> f64;
    fn getHeapSpaceStatistics() -> JsArray<HeapSpaceInfo>;
    // constant
    fn ERANGE() -> f64;
    // constant
    fn ESTALE() -> f64;
    fn waitForDebugger();
    // constant
    fn VERIFYREQUEST() -> f64;
    // constant
    fn HTTP2_METHOD_PUT() -> String;
    // constant
    fn Pool() -> JsValue;
    fn ok(value: JsValue, message: Option<JsValue>) -> bool;
    // constant
    fn SHARE_ENV() -> JsValue;
    // constant
    fn WSAEREFUSED() -> f64;
    // constant
    fn ZSTD_error_memory_allocation() -> f64;
    // merged from 2 overloads
    fn ReadableByteStreamController() -> JsValue;
    // constant
    fn CompressionStream() -> JsValue;
    // merged from 2 overloads
    fn upgrade(url: Option<JsValue>, options: Option<JsValue>) -> JsPromise<UpgradeData>;
    // merged from 2 overloads
    fn gunzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn EBUSY() -> f64;
    // constant
    fn SQLITE_CHANGESET_REPLACE() -> f64;
    // constant
    fn Dispatcher() -> JsValue;
    fn createSecureContext(options: Option<SecureContextOptions>) -> SecureContext;
    // constant
    fn ZSTD_lazy() -> f64;
    // constant
    fn EALREADY() -> f64;
    // constant
    fn ZSTD_btopt() -> f64;
    // constant
    fn SQLITE_ATTACH() -> f64;
    // constant
    fn ENGINE_METHOD_DH() -> f64;
    // constant
    fn SubtleCrypto() -> JsValue;
    // constant
    fn PRIORITY_HIGHEST() -> f64;
    // constant
    fn NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE() -> f64;
    // constant
    fn Z_MIN_LEVEL() -> f64;
    fn stopCoverage();
    // constant
    fn BROTLI_MIN_QUALITY() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS() -> f64;
    // constant
    fn ZSTD_error_frameParameter_windowTooLarge() -> f64;
    // constant
    fn ENOTSUP() -> f64;
    // constant
    fn HTTP_STATUS_BAD_REQUEST() -> f64;
    // constant
    fn SQLITE_UPDATE() -> f64;
    // constant
    fn HTTP_STATUS_FAILED_DEPENDENCY() -> f64;
    // merged from 3 overloads
    fn cp(source: JsValue, destination: JsValue, opts: CopyOptions, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn O_APPEND() -> f64;
    // merged from 2 overloads
    fn gzip(buf: JsValue, options: ZlibOptions, callback: Option<fn(Option<JsValue>, JsValue) -> ()>);
    // constant
    fn BROTLI_ENCODE() -> f64;
    // constant
    fn RTLD_GLOBAL() -> f64;
    fn transcode(source: JsValue, fromEnc: String, toEnc: String) -> JsValue;
    fn start(options: Option<JsValue>) -> REPLServer;
    // constant
    fn ucs2() -> ucs2;
    // constant
    fn ENOTEMPTY() -> f64;
    // merged from 5 overloads
    fn createDiffieHellman(prime: String, primeEncoding: String, generator: Option<String>, generatorEncoding: Option<String>) -> DiffieHellman;
    // constant
    fn DEFLATERAW() -> f64;
    // constant
    fn INFLATE() -> f64;
    // constant
    fn OPENSSL_VERSION_NUMBER() -> f64;
    fn createPrivateKey(key: JsValue) -> KeyObject;
    // constant
    fn WORKER() -> f64;
    fn writeFileSync(file: JsValue, data: JsValue, options: Option<JsValue>);
    fn getPackedSettings(settings: Settings) -> JsValue;
    // constant
    fn SSL_OP_ALL() -> f64;
    // merged from 2 overloads
    fn Response() -> JsValue;
    // merged from 2 overloads
    fn Z_ERRNO() -> f64;
    fn getHeapSnapshot(options: Option<HeapSnapshotOptions>) -> Readable;
    // merged from 2 overloads
    fn resolveTlsa(hostname: String, callback: Option<fn(Option<ErrnoException>, JsArray<TlsaRecord>) -> ()>);
    // constant
    fn WSAEFAULT() -> f64;
    // constant
    fn ZSTD_error_dstSize_tooSmall() -> f64;
    // constant
    fn EPROTONOSUPPORT() -> f64;
    // constant
    fn HTTP2_METHOD_REPORT() -> String;
    // constant
    fn S_IRGRP() -> f64;
    // merged from 4 overloads
    fn suite(name: Option<String>, options: Option<TestOptions>, fn_: Option<JsValue>) -> JsPromise<()>;
    // constant
    fn ZSTD_error_corruption_detected() -> f64;
    // constant
    fn subtle() -> SubtleCrypto;
    // merged from 4 overloads
    fn generatePrimeSync(size: f64, options: Option<GeneratePrimeOptionsBigInt>) -> i64;
    fn createDeflate(options: Option<ZlibOptions>) -> Deflate;
    fn runInNewContext(code: String, contextObject: Option<JsValue>, options: Option<JsValue>) -> JsValue;
    fn mkdtempDisposableSync(prefix: String, options: Option<JsValue>) -> DisposableTempDir;
    // constant
    fn S_IFSOCK() -> f64;
    // constant
    fn WSAECONNREFUSED() -> f64;
    fn moveMessagePortToContext(port: MessagePort, contextifiedSandbox: Context) -> MessagePort;
    fn isDataView(object: JsValue) -> bool;
    // constant
    fn SSL_OP_PRIORITIZE_CHACHA() -> f64;
    // constant
    fn rootCertificates() -> JsArray<String>;
    // constant
    fn HTTP2_METHOD_MERGE() -> String;
    fn dot(source: JsValue) -> JsValue;
    // constant
    fn HTTP_STATUS_MISDIRECTED_REQUEST() -> f64;
    fn isKeyObject(object: JsValue) -> bool;
    // constant
    fn DISABLED() -> f64;
    // merged from 2 overloads
    fn chown(path: JsValue, uid: f64, gid: f64, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn HTTP_STATUS_ACCEPTED() -> f64;
    fn decompress(opts: Option<JsValue>) -> fn(JsValue) -> JsValue;
    // constant
    fn EIDRM() -> f64;
    // constant
    fn O_DIRECT() -> f64;
    // constant
    fn WSAEALREADY() -> f64;
    // constant
    fn HTTP2_HEADER_REFRESH() -> String;
    // constant
    fn BROTLI_PARAM_LARGE_WINDOW() -> f64;
    // constant
    fn O_DSYNC() -> f64;
    // constant
    fn fips() -> bool;
    // constant
    fn HTTP2_HEADER_CONTENT_RANGE() -> String;
    fn unescape(str: String) -> String;
    // constant
    fn HTTP2_METHOD_UNLOCK() -> String;
    fn arch() -> String;
    // constant
    fn HTTP2_HEADER_IF_NONE_MATCH() -> String;
    fn release() -> String;
    fn unsubscribe(name: JsValue, onMessage: fn(JsValue, JsValue) -> ()) -> bool;
    // constant
    fn HTTP_STATUS_MOVED_PERMANENTLY() -> f64;
    // constant
    fn RSA_PSS_SALTLEN_MAX_SIGN() -> f64;
    // constant
    fn TTYWRAP() -> f64;
    fn isFloat32Array(object: JsValue) -> bool;
    // constant
    fn NGHTTP2_CANCEL() -> f64;
    fn getCompileCacheDir() -> Option<String>;
    fn createUnzip(options: Option<ZlibOptions>) -> Unzip;
    // constant
    fn Z_TEXT() -> f64;
    fn isArray(object: JsValue) -> bool;
    // constant
    fn Z_MIN_WINDOWBITS() -> f64;
    // merged from 2 overloads
    fn Z_FILTERED() -> f64;
    // merged from 2 overloads
    fn process() -> Process;
    // constant
    fn NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE() -> f64;
    // constant
    fn DEFAULT_SETTINGS_MAX_FRAME_SIZE() -> f64;
    // constant
    fn HTTP2_HEADER_AGE() -> String;
    fn validateHeaderValue(name: String, value: String);
    fn addDeserializeCallback(callback: fn(JsValue) -> JsValue, data: Option<JsValue>);
    // merged from 3 overloads
    fn opendir(path: JsValue, options: OpenDirOptions, cb: Option<fn(Option<ErrnoException>, Dir) -> ()>);
    fn redirect(opts: Option<JsValue>) -> fn(JsValue) -> JsValue;
    // constant
    fn SQLITE_CREATE_TABLE() -> f64;
    // constant
    fn HEAPSNAPSHOT() -> f64;
    // merged from 2 overloads
    fn link(existingPath: JsValue, newPath: JsValue, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // constant
    fn Event() -> JsValue;
    // merged from 2 overloads
    fn BADNAME() -> String;
    fn runMain(main: Option<String>);
    // merged from 2 overloads
    fn EOF() -> String;
    // constant
    fn ENGINE_METHOD_NONE() -> f64;
    // constant
    fn SQLITE_DROP_INDEX() -> f64;
    fn styleText(format: JsValue, text: String, options: Option<StyleTextOptions>) -> String;
    fn isBigIntObject(object: JsValue) -> bool;
    // constant
    fn SQLITE_ANALYZE() -> f64;
    // constant
    fn ADDRCONFIG() -> f64;
    // constant
    fn ZSTD_greedy() -> f64;
    // constant
    fn SQLITE_TRANSACTION() -> f64;
    fn queueMicrotask(callback: fn() -> ());
    fn setDefaultAutoSelectFamily(value: bool);
    // constant
    fn raw() -> JsValue;
    // constant
    fn EACCES() -> f64;
    // constant
    fn WSAEMFILE() -> f64;
    // constant
    fn S_IFMT() -> f64;
    // constant
    fn ZSTD_error_frameParameter_unsupported() -> f64;
    // constant
    fn RSA_SSLV23_PADDING() -> f64;
    // constant
    fn SQLITE_DROP_VTABLE() -> f64;
    fn loadingFailed(params: LoadingFailedEventDataType);
    // constant
    fn NGHTTP2_FLAG_END_STREAM() -> f64;
    // constant
    fn NGHTTP2_SETTINGS_ENABLE_PUSH() -> f64;
    // constant
    fn BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2() -> f64;
    // constant
    fn BROTLI_MAX_INPUT_BLOCK_BITS() -> f64;
}

#[untagged]
enum Params {
    ParamsDictionary(ParamsDictionary),
    ParamsArray(ParamsArray),
}

#[untagged]
enum PathParams {
    Str(String),
    RegExp(RegExp),
    Array(Array<JsValue>),
}

#[untagged]
enum FilterCallsOperator {
    AND,
    OR,
}

#[untagged]
enum FilterCallsParameter {
    Str(String),
    RegExp(RegExp),
}

#[untagged]
enum UndiciHeaders {
    Record(Record<String, JsValue>),
    IncomingHttpHeaders(IncomingHttpHeaders),
    Array(Vec<String>),
    Iterable(Iterable<(String, JsValue)>),
}

#[untagged]
enum FormDataEntryValue {
    Str(String),
    File(File),
}

#[untagged]
enum RequestInfo {
    Str(String),
    URL(URL),
    Request(Request),
}

#[untagged]
enum BodyInit {
    ArrayBuffer(ArrayBuffer),
    AsyncIterable(AsyncIterable<JsValue>),
    Blob(Blob),
    FormData(FormData),
    Iterable(Iterable<JsValue>),
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
    URLSearchParams(URLSearchParams),
    Str(String),
}

#[untagged]
enum HeadersInit {
    Array(Vec<(String, String)>),
    HeaderRecord(HeaderRecord),
    Headers(Headers),
}

#[untagged]
enum RequestCache {
    Default,
    ForceCache,
    NoCache,
    NoStore,
    OnlyIfCached,
    Reload,
}

#[untagged]
enum RequestCredentials {
    Omit,
    Include,
    SameOrigin,
}

#[untagged]
enum ReferrerPolicy {
    Empty,
    NoReferrer,
    NoReferrerWhenDowngrade,
    Origin,
    OriginWhenCrossOrigin,
    SameOrigin,
    StrictOrigin,
    StrictOriginWhenCrossOrigin,
    UnsafeUrl,
}

#[untagged]
enum RequestMode {
    Cors,
    Navigate,
    NoCors,
    SameOrigin,
}

#[untagged]
enum RequestRedirect {
    Error,
    Follow,
    Manual,
}

#[untagged]
enum ResponseType {
    Basic,
    Cors,
    Default,
    Error,
    Opaque,
    Opaqueredirect,
}

#[untagged]
enum ResponseRedirectStatus {
    N301,
    N302,
    N303,
    N307,
    N308,
}

#[untagged]
enum InputType {
    Str(String),
    ArrayBuffer(ArrayBuffer),
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
}

#[untagged]
enum Transferable {
    ArrayBuffer(ArrayBuffer),
    MessagePort(MessagePort),
    AbortSignal(AbortSignal),
    FileHandle(FileHandle),
    ReadableStream(ReadableStream),
    WritableStream(WritableStream),
    TransformStream(TransformStream),
}

#[untagged]
enum LockMode {
    Exclusive,
    Shared,
}

#[untagged]
enum Serializable {
    Str(String),
    Obj(JsValue),
    Num(f64),
    Bool(bool),
    BigInt(i64),
}

#[untagged]
enum MeasureMemoryMode {
    Summary,
    Detailed,
}

#[untagged]
enum ModuleStatus {
    Unlinked,
    Linking,
    Linked,
    Evaluating,
    Evaluated,
    Errored,
}

#[untagged]
enum DoesZapCodeSpaceFlag {
    N0,
    N1,
}

#[untagged]
enum ParseArgsOptionsType {
    Boolean,
    String,
}

#[untagged]
enum Direction {
    Num(f64),
    N0,
    N1,
}

#[untagged]
enum SecureVersion {
    TLSv13,
    TLSv12,
    TLSv11,
    TLSv1,
}

#[untagged]
enum BufferSource {
    ArrayBufferView(ArrayBufferView),
    ArrayBuffer(ArrayBuffer),
}

#[untagged]
enum CompressionFormat {
    Brotli,
    Deflate,
    DeflateRaw,
    Gzip,
}

#[untagged]
enum SQLInputValue {
    Num(f64),
    BigInt(i64),
    Str(String),
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
}

#[untagged]
enum SQLOutputValue {
    Num(f64),
    BigInt(i64),
    Str(String),
    NodeJS.NonSharedUint8Array(NodeJS.NonSharedUint8Array),
}

#[untagged]
enum Direction {
    Num(f64),
    N0,
    N1,
}

#[untagged]
enum Architecture {
    Arm,
    Arm64,
    Ia32,
    Loong64,
    Mips,
    Mipsel,
    Ppc64,
    Riscv64,
    S390x,
    X64,
}

#[untagged]
enum UncaughtExceptionOrigin {
    UncaughtException,
    UnhandledRejection,
}

#[untagged]
enum MultipleResolveType {
    Resolve,
    Reject,
}

#[untagged]
enum EntryType {
    Dns,
    Function,
    Gc,
    Http2,
    Http,
    Mark,
    Measure,
    Net,
    Node,
    Resource,
}

#[untagged]
enum NetworkInterfaceInfo {
    NetworkInterfaceInfoIPv4(NetworkInterfaceInfoIPv4),
    NetworkInterfaceInfoIPv6(NetworkInterfaceInfoIPv6),
}

#[untagged]
enum SocketConnectOpts {
    TcpSocketConnectOpts(TcpSocketConnectOpts),
    IpcSocketConnectOpts(IpcSocketConnectOpts),
}

#[untagged]
enum SocketReadyState {
    Opening,
    Open,
    ReadOnly,
    WriteOnly,
    Closed,
}

#[untagged]
enum IPVersion {
    Ipv4,
    Ipv6,
}

#[untagged]
enum NetConnectOpts {
    TcpNetConnectOpts(TcpNetConnectOpts),
    IpcNetConnectOpts(IpcNetConnectOpts),
}

#[untagged]
enum ImportPhase {
    Source,
    Evaluation,
}

#[untagged]
enum ModuleFormat {
    Addon,
    Builtin,
    Commonjs,
    CommonjsTypescript,
    Json,
    Module,
    ModuleTypescript,
    Wasm,
}

#[untagged]
enum ModuleSource {
    Str(String),
    ArrayBuffer(ArrayBuffer),
    NodeJS.TypedArray(NodeJS.TypedArray),
}

#[untagged]
enum OutgoingHttpHeader {
    Num(f64),
    Str(String),
    Array(Vec<String>),
}

#[untagged]
enum PathLike {
    Str(String),
    Buffer(Buffer),
    URL(URL),
}

#[untagged]
enum PathOrFileDescriptor {
    PathLike(PathLike),
    Num(f64),
}

#[untagged]
enum TimeLike {
    Str(String),
    Num(f64),
    Date(Date),
}

#[untagged]
enum EncodingOption {
    ObjectEncodingOptions(ObjectEncodingOptions),
    BufferEncoding(BufferEncoding),
}

#[untagged]
enum OpenMode {
    Num(f64),
    Str(String),
}

#[untagged]
enum Mode {
    Num(f64),
    Str(String),
}

#[untagged]
enum Type {
    Dir,
    File,
    Junction,
}

#[untagged]
enum ReadPosition {
    Num(f64),
    BigInt(i64),
}

#[untagged]
enum WatchEventType {
    Rename,
    Change,
}

#[untagged]
enum AnyRecordWithTtl {
    AnyARecord(AnyARecord),
    AnyAaaaRecord(AnyAaaaRecord),
}

#[untagged]
enum SocketType {
    Udp4,
    Udp6,
}

#[untagged]
enum BinaryToTextEncoding {
    Base64,
    Base64url,
    Hex,
    Binary,
}

#[untagged]
enum CharacterEncoding {
    Utf8,
    Utf8,
    Utf16le,
    Utf16le,
    Latin1,
}

#[untagged]
enum LegacyCharacterEncoding {
    Ascii,
    Binary,
    Ucs2,
    Ucs2,
}

#[untagged]
enum Encoding {
    BinaryToTextEncoding(BinaryToTextEncoding),
    CharacterEncoding(CharacterEncoding),
    LegacyCharacterEncoding(LegacyCharacterEncoding),
}

#[untagged]
enum ECDHKeyFormat {
    Compressed,
    Uncompressed,
    Hybrid,
}

#[untagged]
enum KeyObjectType {
    Secret,
    Public,
    Private,
}

#[untagged]
enum CipherCCMTypes {
    Aes128Ccm,
    Aes192Ccm,
    Aes256Ccm,
}

#[untagged]
enum CipherGCMTypes {
    Aes128Gcm,
    Aes192Gcm,
    Aes256Gcm,
}

#[untagged]
enum CipherOCBTypes {
    Aes128Ocb,
    Aes192Ocb,
    Aes256Ocb,
}

#[untagged]
enum BinaryLike {
    Str(String),
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
}

#[untagged]
enum CipherKey {
    BinaryLike(BinaryLike),
    KeyObject(KeyObject),
}

#[untagged]
enum DSAEncoding {
    Der,
    IeeeP1363,
}

#[untagged]
enum KeyLike {
    Str(String),
    Buffer(Buffer),
    KeyObject(KeyObject),
}

#[untagged]
enum KeyFormat {
    Pem,
    Der,
    Jwk,
}

#[untagged]
enum LargeNumberLike {
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
    SharedArrayBuffer(SharedArrayBuffer),
    ArrayBuffer(ArrayBuffer),
    BigInt(i64),
}

#[untagged]
enum Argon2Algorithm {
    Argon2d,
    Argon2i,
    Argon2id,
}

#[untagged]
enum BufferSource {
    ArrayBufferView(ArrayBufferView),
    ArrayBuffer(ArrayBuffer),
}

#[untagged]
enum KeyFormat {
    Jwk,
    Pkcs8,
    Raw,
    RawPublic,
    RawSecret,
    RawSeed,
    Spki,
}

#[untagged]
enum KeyType {
    Private,
    Public,
    Secret,
}

#[untagged]
enum AlgorithmIdentifier {
    Algorithm(Algorithm),
    Str(String),
}

#[untagged]
enum SerializationType {
    Json,
    Advanced,
}

#[untagged]
enum Serializable {
    Str(String),
    Obj(JsValue),
    Num(f64),
    Bool(bool),
    BigInt(i64),
}

#[untagged]
enum SendHandle {
    net.Socket(net.Socket),
    net.Server(net.Server),
    dgram.Socket(dgram.Socket),
}

#[untagged]
enum IOType {
    Overlapped,
    Pipe,
    Ignore,
    Inherit,
}

#[untagged]
enum StdioOptions {
    IOType(IOType),
    Array(Array<JsValue>),
}

#[untagged]
enum SerializationType {
    Json,
    Advanced,
}

#[untagged]
enum StdioNull {
    Inherit,
    Ignore,
    Stream(Stream),
}

#[untagged]
enum StdioPipeNamed {
    Pipe,
    Overlapped,
}

#[untagged]
enum TranscodeEncoding {
    Ascii,
    Utf8,
    Utf8,
    Utf16le,
    Utf16le,
    Ucs2,
    Ucs2,
    Latin1,
    Binary,
}

#[untagged]
enum BinaryType {
    Blob,
    Arraybuffer,
}

#[untagged]
enum EventListenerOrEventListenerObject {
    EventListener(EventListener),
    EventListenerObject(EventListenerObject),
}

#[untagged]
enum CacheMethods {
    GET,
    HEAD,
    OPTIONS,
    TRACE,
}

#[untagged]
enum SnapshotRecorderMode {
    Record,
    Playback,
    Update,
}

#[untagged]
enum FilterCallsOperator {
    AND,
    OR,
}

#[untagged]
enum FilterCallsParameter {
    Str(String),
    RegExp(RegExp),
}

#[untagged]
enum RequestInfo {
    Str(String),
    URL(URL),
    Request(Request),
}

#[untagged]
enum BodyInit {
    ArrayBuffer(ArrayBuffer),
    AsyncIterable(AsyncIterable<JsValue>),
    Blob(Blob),
    FormData(FormData),
    Iterable(Iterable<JsValue>),
    NodeJS.ArrayBufferView(NodeJS.ArrayBufferView),
    URLSearchParams(URLSearchParams),
    Str(String),
}

#[untagged]
enum HeadersInit {
    Array(Vec<(String, String)>),
    HeaderRecord(HeaderRecord),
    Headers(Headers),
}

#[untagged]
enum RequestCache {
    Default,
    ForceCache,
    NoCache,
    NoStore,
    OnlyIfCached,
    Reload,
}

#[untagged]
enum RequestCredentials {
    Omit,
    Include,
    SameOrigin,
}

#[untagged]
enum ReferrerPolicy {
    Empty,
    NoReferrer,
    NoReferrerWhenDowngrade,
    Origin,
    OriginWhenCrossOrigin,
    SameOrigin,
    StrictOrigin,
    StrictOriginWhenCrossOrigin,
    UnsafeUrl,
}

#[untagged]
enum RequestMode {
    Cors,
    Navigate,
    NoCors,
    SameOrigin,
}

#[untagged]
enum RequestRedirect {
    Error,
    Follow,
    Manual,
}

#[untagged]
enum ResponseType {
    Basic,
    Cors,
    Default,
    Error,
    Opaque,
    Opaqueredirect,
}

#[untagged]
enum ResponseRedirectStatus {
    N301,
    N302,
    N303,
    N307,
    N308,
}

#[untagged]
enum UndiciHeaders {
    Record(Record<String, JsValue>),
    IncomingHttpHeaders(IncomingHttpHeaders),
    Array(Vec<String>),
    Iterable(Iterable<(String, JsValue)>),
}

#[untagged]
enum FormDataEntryValue {
    Str(String),
    File(File),
}


impl AbortController {
    #[getter]
    extern "js" signal: JsValue;

    extern "js" fn abort(self, reason: Option<JsValue>);
}

impl AbortSignal {
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    #[setter]
    extern "js" onabort: Option<JsFn>;
    #[getter]
    extern "js" reason: JsValue;

    extern "js" fn throwIfAborted(self);
}

impl Abortable {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl AddEventListenerOptions {
    #[getter]
    #[setter]
    extern "js" once: Option<bool>;
    #[getter]
    #[setter]
    extern "js" passive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" once: Option<bool>;
    #[getter]
    #[setter]
    extern "js" passive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
}

impl AddHeapSnapshotChunkEventDataType {
    #[getter]
    #[setter]
    extern "js" chunk: String;
}

impl AddInspectedHeapObjectParameterType {
    #[getter]
    #[setter]
    extern "js" heapObjectId: String;
}

impl Address {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" addressType: JsValue;
}

impl AddressInfo {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
}

impl AeadParams {
    #[getter]
    #[setter]
    extern "js" additionalData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
    #[getter]
    #[setter]
    extern "js" tagLength: f64;
}

impl AesCbcParams {
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
}

impl AesCtrParams {
    #[getter]
    #[setter]
    extern "js" counter: JsValue;
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl AesDerivedKeyParams {
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl AesGcmParams {
    #[getter]
    #[setter]
    extern "js" additionalData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" iv: JsValue;
    #[getter]
    #[setter]
    extern "js" tagLength: Option<f64>;
}

impl AesKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl AesKeyGenParams {
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl Agent {
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property getter
    extern "js" fn closed(self) -> bool;
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    extern "js" fn new(opts: Option<Options>) -> Agent;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
}

impl AgentOptions {
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveMsecs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" agentKeepAliveTimeoutBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxTotalSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxFreeSockets: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" scheduling: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyEnv: Option<Option<ProxyEnv>>;
    #[getter]
    #[setter]
    extern "js" defaultPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
}

impl AggregateOptions<T> {
    #[getter]
    #[setter]
    extern "js" start: JsValue;
    #[getter]
    #[setter]
    extern "js" result: Option<Option<fn(T) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" inverse: Option<Option<fn(T, JsArray<JsValue>) -> T>>;

    // function property
    extern "js" fn step(self) -> fn(T, JsArray<JsValue>) -> T;
}

impl Algorithm {
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl AlternativeServiceOptions {
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
}

impl AnyARecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyAaaaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyCaaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyCnameRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnyMxRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyNaptrRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyNsRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnyPtrRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: String;
}

impl AnySoaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnySrvRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyTlsaRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl AnyTxtRecord {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" entries: JsArray<String>;
}

impl Application<LocalsObj> {
    #[getter]
    #[setter]
    extern "js" get: fn(String) -> JsValue;
    #[getter]
    #[setter]
    extern "js" router: String;
    #[getter]
    #[setter]
    extern "js" settings: JsValue;
    #[getter]
    #[setter]
    extern "js" resource: JsValue;
    #[getter]
    #[setter]
    extern "js" map: JsValue;
    #[getter]
    #[setter]
    extern "js" locals: LocalsObj;
    #[getter]
    #[setter]
    extern "js" routes: JsValue;
    #[getter]
    #[setter]
    extern "js" _router: JsValue;
    #[getter]
    #[setter]
    extern "js" use_: IRouterHandler<JsValue>;
    #[getter]
    #[setter]
    extern "js" mountpath: JsValue;

    extern "js" fn init(self);
    // merged from 2 overloads
    extern "js" fn render(self, name: String, options: Option<JsValue>, callback: Option<fn(JsValue, String) -> ()>);
    // merged from 6 overloads
    extern "js" fn listen(self, port: f64, hostname: Option<String>, backlog: Option<f64>, callback: Option<fn() -> ()>) -> Server;
    extern "js" fn enabled(self, setting: String) -> bool;
    // function property
    extern "js" fn on(self) -> fn(String, fn(Application) -> ()) -> Application;
    extern "js" fn defaultConfiguration(self);
    extern "js" fn disabled(self, setting: String) -> bool;
    extern "js" fn set(self, setting: String, val: JsValue) -> Application;
    // merged from 2 overloads
    extern "js" fn param(self, name: JsValue, handler: Option<fn(Request, Response, NextFunction, JsValue, String) -> JsValue>) -> Application;
    extern "js" fn engine(self, ext: String, fn_: fn(String, JsValue, fn(JsValue, String) -> ()) -> ()) -> Application;
    extern "js" fn path(self) -> String;
    extern "js" fn enable(self, setting: String) -> Application;
    extern "js" fn disable(self, setting: String) -> Application;
}

impl ApplyChangesetOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String) -> bool>>;
    #[getter]
    #[setter]
    extern "js" onConflict: Option<Option<fn(f64) -> f64>>;
}

impl Argon2Parameters {
    #[getter]
    #[setter]
    extern "js" message: JsValue;
    #[getter]
    #[setter]
    extern "js" nonce: JsValue;
    #[getter]
    #[setter]
    extern "js" parallelism: f64;
    #[getter]
    #[setter]
    extern "js" tagLength: f64;
    #[getter]
    #[setter]
    extern "js" memory: f64;
    #[getter]
    #[setter]
    extern "js" passes: f64;
    #[getter]
    #[setter]
    extern "js" secret: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" associatedData: Option<JsValue>;
}

impl Argon2Params {
    #[getter]
    #[setter]
    extern "js" associatedData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" memory: f64;
    #[getter]
    #[setter]
    extern "js" nonce: JsValue;
    #[getter]
    #[setter]
    extern "js" parallelism: f64;
    #[getter]
    #[setter]
    extern "js" passes: f64;
    #[getter]
    #[setter]
    extern "js" secretValue: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" version: Option<f64>;
}

impl ArrayOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl AssertOptions {
    #[getter]
    #[setter]
    extern "js" diff: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" strict: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" skipPrototype: Option<Option<bool>>;
}

impl AssertSnapshotOptions {
    #[getter]
    #[setter]
    extern "js" serializers: Option<Option<JsArray<fn(JsValue) -> JsValue>>>;
}

impl AssertionError {
    extern "js" fn new(options: AssertionErrorOptions) -> AssertionError;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_generatedMessage(self, value: bool);
    // property setter
    extern "js" fn set_expected(self, value: JsValue);
    // property getter
    extern "js" fn actual(self) -> JsValue;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn operator(self) -> String;
    // property getter
    extern "js" fn expected(self) -> JsValue;
    // property setter
    extern "js" fn set_operator(self, value: String);
    // property setter
    extern "js" fn set_actual(self, value: JsValue);
    // property getter
    extern "js" fn generatedMessage(self) -> bool;
}

impl AssertionErrorOptions {
    #[getter]
    #[setter]
    extern "js" message: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" actual: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" expected: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" operator: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stackStartFn: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" diff: Option<JsValue>;
}

impl AsymmetricKeyDetails {
    #[getter]
    #[setter]
    extern "js" modulusLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<i64>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<String>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<String>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" divisorLength: Option<f64>;
    #[getter]
    #[setter]
    extern "js" namedCurve: Option<String>;
}

impl AsyncHook {
    extern "js" fn disable(self) -> AsyncHook;
    extern "js" fn enable(self) -> AsyncHook;
}

impl AsyncLocalStorage<T> {
    // property (readonly)
    extern "js" fn name(self) -> String;
    extern "js" fn new<T>(options: Option<AsyncLocalStorageOptions>) -> AsyncLocalStorage;
    extern "js" fn getStore(self) -> Option<T>;
    // merged from 2 overloads
    extern "js" fn run(self, store: T, callback: fn(TArgs) -> R, args: Option<TArgs>) -> R;
    extern "js" fn exit(self, callback: fn(TArgs) -> R, args: TArgs) -> R;
    extern "js" fn disable(self);
    extern "js" fn snapshot<T>() -> JsFn;
    extern "js" fn enterWith(self, store: T);
    extern "js" fn bind<T, Func>(fn_: Func) -> Func;
}

impl AsyncLocalStorageOptions {
    #[getter]
    #[setter]
    extern "js" defaultValue: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl AsyncResource {
    extern "js" fn new(type_: String, triggerAsyncId: Option<JsValue>) -> AsyncResource;
    extern "js" fn emitDestroy(self) -> AsyncResource;
    extern "js" fn asyncId(self) -> f64;
    extern "js" fn runInAsyncScope(self, fn_: JsFn, thisArg: Option<This>, args: JsArray<JsValue>) -> Result;
    extern "js" fn bind<Func, ThisArg>(fn_: Func, type_: Option<String>, thisArg: Option<ThisArg>) -> Func;
    extern "js" fn triggerAsyncId(self) -> f64;
    extern "js" fn bind(self, fn_: Func) -> Func;
}

impl AsyncResourceOptions {
    #[getter]
    #[setter]
    extern "js" triggerAsyncId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" requireManualDestroy: Option<Option<bool>>;
}

impl AttachedToTargetEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" targetInfo: TargetInfo;
    #[getter]
    #[setter]
    extern "js" waitingForDebugger: bool;
}

impl AttachedToWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" workerInfo: WorkerInfo;
    #[getter]
    #[setter]
    extern "js" waitingForDebugger: bool;
}

impl AwaitPromiseParameterType {
    #[getter]
    #[setter]
    extern "js" promiseObjectId: String;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
}

impl AwaitPromiseReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl BackupOptions {
    #[getter]
    #[setter]
    extern "js" source: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" target: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" rate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" progress: Option<Option<fn(BackupProgressInfo) -> ()>>;
}

impl BackupProgressInfo {
    #[getter]
    #[setter]
    extern "js" totalPages: f64;
    #[getter]
    #[setter]
    extern "js" remainingPages: f64;
}

impl BalancedPool {
    // property getter
    extern "js" fn upstreams(self) -> JsArray<String>;
    extern "js" fn removeUpstream(self, upstream: JsValue) -> BalancedPool;
    extern "js" fn addUpstream(self, upstream: JsValue) -> BalancedPool;
    extern "js" fn new(url: JsValue, options: Option<Options>) -> BalancedPool;
    // property getter
    extern "js" fn closed(self) -> bool;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property setter
    extern "js" fn set_upstreams(self, value: JsArray<String>);
    // merged from 2 overloads
    extern "js" fn connect(self, options: JsValue, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property getter
    extern "js" fn destroyed(self) -> bool;
}

impl BalancedPoolMissingUpstreamError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl BaseOptions {
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineOffset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnOffset: Option<Option<f64>>;
}

impl BasePrivateKeyEncodingOptions<T> {
    #[getter]
    #[setter]
    extern "js" format: T;
    #[getter]
    #[setter]
    extern "js" cipher: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
}

impl BigIntOptions {
    #[getter]
    #[setter]
    extern "js" bigint: bool;
}

impl BigIntStats {
    #[getter]
    #[setter]
    extern "js" atimeNs: i64;
    #[getter]
    #[setter]
    extern "js" mtimeNs: i64;
    #[getter]
    #[setter]
    extern "js" ctimeNs: i64;
    #[getter]
    #[setter]
    extern "js" birthtimeNs: i64;
}

impl BindOptions {
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" address: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
}

impl Blob {
    extern "js" fn slice(self, start: Option<f64>, end: Option<f64>, type_: Option<String>) -> Blob;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn new(sources: JsArray<JsValue>, options: Option<BlobOptions>) -> Blob;
    extern "js" fn text(self) -> JsPromise<String>;
    // property (readonly)
    extern "js" fn type_(self) -> String;
    extern "js" fn stream(self) -> JsValue;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    // property (readonly)
    extern "js" fn size(self) -> f64;
}

impl BlobOptions {
    #[getter]
    #[setter]
    extern "js" endings: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl BlockList {
    // merged from 2 overloads
    extern "js" fn addAddress(self, address: String, type_: Option<String>);
    // merged from 2 overloads
    extern "js" fn addRange(self, start: String, end: String, type_: Option<String>);
    // property setter
    extern "js" fn set_rules(self, value: JsArray<String>);
    // merged from 2 overloads
    extern "js" fn check(self, address: String, type_: Option<String>) -> bool;
    // property getter
    extern "js" fn rules(self) -> JsArray<String>;
    extern "js" fn isBlockList(value: JsValue) -> bool;
    extern "js" fn toJSON(self) -> JsArray<String>;
    extern "js" fn fromJSON(self, data: JsValue);
    // merged from 2 overloads
    extern "js" fn addSubnet(self, net: String, prefix: f64, type_: Option<String>);
}

impl BodyMixin {
    #[getter]
    extern "js" body: Option<()>;
    #[getter]
    extern "js" bodyUsed: bool;
    #[getter]
    extern "js" body: Option<()>;
    #[getter]
    extern "js" bodyUsed: bool;

    extern "js" fn json(self) -> JsPromise<JsValue>;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn formData(self) -> JsPromise<()>;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    extern "js" fn blob(self) -> JsPromise<Blob>;
    extern "js" fn text(self) -> JsPromise<String>;
}

impl BodyReadable {
    extern "js" fn blob(self) -> JsPromise<Blob>;
    extern "js" fn bytes(self) -> JsPromise<JsValue>;
    extern "js" fn text(self) -> JsPromise<String>;
    // property (readonly)
    extern "js" fn bodyUsed(self) -> bool;
    // property (readonly)
    extern "js" fn body(self) -> Option<()>;
    extern "js" fn dump(self, opts: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn json(self) -> JsPromise<JsValue>;
    extern "js" fn formData(self) -> JsPromise<()>;
    extern "js" fn arrayBuffer(self) -> JsPromise<JsValue>;
    extern "js" fn new(opts: JsValue) -> BodyReadable;
}

impl BodyTimeoutError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl BreakLocation {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl BreakpointResolvedEventDataType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
}

impl BroadcastChannel {
    extern "js" fn close(self);
    // property getter
    extern "js" fn onmessage(self) -> fn(MessageEvent) -> ();
    // property setter
    extern "js" fn set_onmessage(self, value: fn(MessageEvent) -> ());
    extern "js" fn new(name: String) -> BroadcastChannel;
    // property (readonly)
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_onmessageerror(self, value: fn(MessageEvent) -> ());
    extern "js" fn postMessage(self, message: JsValue);
    // property getter
    extern "js" fn onmessageerror(self) -> fn(MessageEvent) -> ();
}

impl BrotliOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" params: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
}

impl Buffer<TArrayBuffer> {
    extern "js" fn slice(self, start: Option<f64>, end: Option<f64>) -> Buffer<JsValue>;
    extern "js" fn subarray(self, start: Option<f64>, end: Option<f64>) -> Buffer<TArrayBuffer>;
}

impl BufferConstructor {
    #[getter]
    #[setter]
    extern "js" poolSize: f64;

    // merged from 4 overloads
    extern "js" fn from(self, arrayBuffer: JsValue, byteOffset: Option<f64>, length: Option<f64>) -> JsValue;
    extern "js" fn alloc(self, size: f64, fill: Option<JsValue>, encoding: Option<String>) -> Buffer<JsValue>;
    extern "js" fn copyBytesFrom(self, view: JsValue, offset: Option<f64>, length: Option<f64>) -> Buffer<JsValue>;
    extern "js" fn concat(self, list: JsArray<JsValue>, totalLength: Option<f64>) -> Buffer<JsValue>;
    extern "js" fn allocUnsafe(self, size: f64) -> Buffer<JsValue>;
    extern "js" fn allocUnsafeSlow(self, size: f64) -> Buffer<JsValue>;
    extern "js" fn of(self, items: JsArray<f64>) -> Buffer<JsValue>;
}

impl BuiltInModule {
    #[getter]
    #[setter]
    extern "js" assert: JsValue;
    #[getter]
    #[setter]
    extern "js" node:assert: JsValue;
    #[getter]
    #[setter]
    extern "js" assert/strict: JsValue;
    #[getter]
    #[setter]
    extern "js" node:assert/strict: JsValue;
    #[getter]
    #[setter]
    extern "js" async_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" node:async_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" buffer: JsValue;
    #[getter]
    #[setter]
    extern "js" node:buffer: JsValue;
    #[getter]
    #[setter]
    extern "js" child_process: JsValue;
    #[getter]
    #[setter]
    extern "js" node:child_process: JsValue;
    #[getter]
    #[setter]
    extern "js" cluster: JsValue;
    #[getter]
    #[setter]
    extern "js" node:cluster: JsValue;
    #[getter]
    #[setter]
    extern "js" console: JsValue;
    #[getter]
    #[setter]
    extern "js" node:console: JsValue;
    #[getter]
    #[setter]
    extern "js" constants: JsValue;
    #[getter]
    #[setter]
    extern "js" node:constants: JsValue;
    #[getter]
    #[setter]
    extern "js" crypto: JsValue;
    #[getter]
    #[setter]
    extern "js" node:crypto: JsValue;
    #[getter]
    #[setter]
    extern "js" dgram: JsValue;
    #[getter]
    #[setter]
    extern "js" node:dgram: JsValue;
    #[getter]
    #[setter]
    extern "js" diagnostics_channel: JsValue;
    #[getter]
    #[setter]
    extern "js" node:diagnostics_channel: JsValue;
    #[getter]
    #[setter]
    extern "js" dns: JsValue;
    #[getter]
    #[setter]
    extern "js" node:dns: JsValue;
    #[getter]
    #[setter]
    extern "js" dns/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:dns/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" domain: JsValue;
    #[getter]
    #[setter]
    extern "js" node:domain: JsValue;
    #[getter]
    #[setter]
    extern "js" events: JsValue;
    #[getter]
    #[setter]
    extern "js" node:events: JsValue;
    #[getter]
    #[setter]
    extern "js" fs: JsValue;
    #[getter]
    #[setter]
    extern "js" node:fs: JsValue;
    #[getter]
    #[setter]
    extern "js" fs/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:fs/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" http: JsValue;
    #[getter]
    #[setter]
    extern "js" node:http: JsValue;
    #[getter]
    #[setter]
    extern "js" http2: JsValue;
    #[getter]
    #[setter]
    extern "js" node:http2: JsValue;
    #[getter]
    #[setter]
    extern "js" https: JsValue;
    #[getter]
    #[setter]
    extern "js" node:https: JsValue;
    #[getter]
    #[setter]
    extern "js" inspector: JsValue;
    #[getter]
    #[setter]
    extern "js" node:inspector: JsValue;
    #[getter]
    #[setter]
    extern "js" inspector/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:inspector/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" module: JsValue;
    #[getter]
    #[setter]
    extern "js" node:module: JsValue;
    #[getter]
    #[setter]
    extern "js" net: JsValue;
    #[getter]
    #[setter]
    extern "js" node:net: JsValue;
    #[getter]
    #[setter]
    extern "js" os: JsValue;
    #[getter]
    #[setter]
    extern "js" node:os: JsValue;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" node:path: JsValue;
    #[getter]
    #[setter]
    extern "js" path/posix: JsValue;
    #[getter]
    #[setter]
    extern "js" node:path/posix: JsValue;
    #[getter]
    #[setter]
    extern "js" path/win32: JsValue;
    #[getter]
    #[setter]
    extern "js" node:path/win32: JsValue;
    #[getter]
    #[setter]
    extern "js" perf_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" node:perf_hooks: JsValue;
    #[getter]
    #[setter]
    extern "js" process: JsValue;
    #[getter]
    #[setter]
    extern "js" node:process: JsValue;
    #[getter]
    #[setter]
    extern "js" punycode: JsValue;
    #[getter]
    #[setter]
    extern "js" node:punycode: JsValue;
    #[getter]
    #[setter]
    extern "js" querystring: JsValue;
    #[getter]
    #[setter]
    extern "js" node:querystring: JsValue;
    #[getter]
    #[setter]
    extern "js" readline: JsValue;
    #[getter]
    #[setter]
    extern "js" node:readline: JsValue;
    #[getter]
    #[setter]
    extern "js" readline/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:readline/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" repl: JsValue;
    #[getter]
    #[setter]
    extern "js" node:repl: JsValue;
    #[getter]
    #[setter]
    extern "js" node:sea: JsValue;
    #[getter]
    #[setter]
    extern "js" node:sqlite: JsValue;
    #[getter]
    #[setter]
    extern "js" stream: JsValue;
    #[getter]
    #[setter]
    extern "js" node:stream: JsValue;
    #[getter]
    #[setter]
    extern "js" stream/consumers: JsValue;
    #[getter]
    #[setter]
    extern "js" node:stream/consumers: JsValue;
    #[getter]
    #[setter]
    extern "js" stream/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:stream/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" stream/web: JsValue;
    #[getter]
    #[setter]
    extern "js" node:stream/web: JsValue;
    #[getter]
    #[setter]
    extern "js" string_decoder: JsValue;
    #[getter]
    #[setter]
    extern "js" node:string_decoder: JsValue;
    #[getter]
    #[setter]
    extern "js" node:test: JsValue;
    #[getter]
    #[setter]
    extern "js" node:test/reporters: JsValue;
    #[getter]
    #[setter]
    extern "js" timers: JsValue;
    #[getter]
    #[setter]
    extern "js" node:timers: JsValue;
    #[getter]
    #[setter]
    extern "js" timers/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" node:timers/promises: JsValue;
    #[getter]
    #[setter]
    extern "js" tls: JsValue;
    #[getter]
    #[setter]
    extern "js" node:tls: JsValue;
    #[getter]
    #[setter]
    extern "js" trace_events: JsValue;
    #[getter]
    #[setter]
    extern "js" node:trace_events: JsValue;
    #[getter]
    #[setter]
    extern "js" tty: JsValue;
    #[getter]
    #[setter]
    extern "js" node:tty: JsValue;
    #[getter]
    #[setter]
    extern "js" url: JsValue;
    #[getter]
    #[setter]
    extern "js" node:url: JsValue;
    #[getter]
    #[setter]
    extern "js" util: JsValue;
    #[getter]
    #[setter]
    extern "js" node:util: JsValue;
    #[getter]
    #[setter]
    extern "js" sys: JsValue;
    #[getter]
    #[setter]
    extern "js" node:sys: JsValue;
    #[getter]
    #[setter]
    extern "js" util/types: JsValue;
    #[getter]
    #[setter]
    extern "js" node:util/types: JsValue;
    #[getter]
    #[setter]
    extern "js" v8: JsValue;
    #[getter]
    #[setter]
    extern "js" node:v8: JsValue;
    #[getter]
    #[setter]
    extern "js" vm: JsValue;
    #[getter]
    #[setter]
    extern "js" node:vm: JsValue;
    #[getter]
    #[setter]
    extern "js" wasi: JsValue;
    #[getter]
    #[setter]
    extern "js" node:wasi: JsValue;
    #[getter]
    #[setter]
    extern "js" worker_threads: JsValue;
    #[getter]
    #[setter]
    extern "js" node:worker_threads: JsValue;
    #[getter]
    #[setter]
    extern "js" zlib: JsValue;
    #[getter]
    #[setter]
    extern "js" node:zlib: JsValue;
}

impl ByteLengthQueuingStrategy {
    #[getter]
    extern "js" highWaterMark: f64;
    #[getter]
    extern "js" size: QueuingStrategySize<JsValue>;
}

impl ByteRange {
    #[getter]
    #[setter]
    extern "js" start: f64;
    #[getter]
    #[setter]
    extern "js" end: f64;
}

impl CPUProfileHandle {
    extern "js" fn stop(self) -> JsPromise<String>;
}

impl CShakeParams {
    #[getter]
    #[setter]
    extern "js" customization: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" functionName: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl CaaRecord {
    #[getter]
    #[setter]
    extern "js" critical: f64;
    #[getter]
    #[setter]
    extern "js" issue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" issuewild: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" iodef: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactemail: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" contactphone: Option<Option<String>>;
}

impl Cache {
    extern "js" fn match_(self, request: JsValue, options: Option<CacheQueryOptions>) -> JsPromise<Option<Response>>;
    extern "js" fn matchAll(self, request: Option<JsValue>, options: Option<CacheQueryOptions>) -> JsPromise<JsArray<Response>>;
    extern "js" fn addAll(self, requests: JsArray<JsValue>) -> JsPromise<()>;
    extern "js" fn delete(self, request: JsValue, options: Option<CacheQueryOptions>) -> JsPromise<bool>;
    extern "js" fn add(self, request: JsValue) -> JsPromise<()>;
    extern "js" fn keys(self, request: Option<JsValue>, options: Option<CacheQueryOptions>) -> JsPromise<JsArray<Request>>;
    extern "js" fn put(self, request: JsValue, response: Response) -> JsPromise<()>;
}

impl CacheControlDirectives {
    #[getter]
    #[setter]
    extern "js" max-stale: Option<f64>;
    #[getter]
    #[setter]
    extern "js" min-fresh: Option<f64>;
    #[getter]
    #[setter]
    extern "js" max-age: Option<f64>;
    #[getter]
    #[setter]
    extern "js" s-maxage: Option<f64>;
    #[getter]
    #[setter]
    extern "js" stale-while-revalidate: Option<f64>;
    #[getter]
    #[setter]
    extern "js" stale-if-error: Option<f64>;
    #[getter]
    #[setter]
    extern "js" public_: Option<bool>;
    #[getter]
    #[setter]
    extern "js" private_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" no-store: Option<bool>;
    #[getter]
    #[setter]
    extern "js" no-cache: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" must-revalidate: Option<bool>;
    #[getter]
    #[setter]
    extern "js" proxy-revalidate: Option<bool>;
    #[getter]
    #[setter]
    extern "js" immutable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" no-transform: Option<bool>;
    #[getter]
    #[setter]
    extern "js" must-understand: Option<bool>;
    #[getter]
    #[setter]
    extern "js" only-if-cached: Option<bool>;
}

impl CacheHandlerOptions {
    #[getter]
    #[setter]
    extern "js" store: CacheStore;
    #[getter]
    #[setter]
    extern "js" cacheByDefault: Option<f64>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
}

impl CacheKey {
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl CacheOptions {
    #[getter]
    #[setter]
    extern "js" store: Option<CacheStore>;
    #[getter]
    #[setter]
    extern "js" methods: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" cacheByDefault: Option<f64>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
}

impl CacheQueryOptions {
    #[getter]
    #[setter]
    extern "js" ignoreSearch: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreMethod: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreVary: Option<bool>;
}

impl CacheStorage {
    extern "js" fn match_(self, request: JsValue, options: Option<MultiCacheQueryOptions>) -> JsPromise<Option<Response>>;
    extern "js" fn delete(self, cacheName: String) -> JsPromise<bool>;
    extern "js" fn keys(self) -> JsPromise<JsArray<String>>;
    extern "js" fn has(self, cacheName: String) -> JsPromise<bool>;
    extern "js" fn open(self, cacheName: String) -> JsPromise<Cache>;
}

impl CacheStore {
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
    extern "js" fn createWriteStream(self, key: CacheKey, val: CacheValue) -> Option<Writable>;
    extern "js" fn get(self, key: CacheKey) -> JsValue;
}

impl CacheValue {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusMessage: String;
    #[getter]
    #[setter]
    extern "js" headers: JsValue;
    #[getter]
    #[setter]
    extern "js" vary: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" etag: Option<String>;
    #[getter]
    #[setter]
    extern "js" cacheControlDirectives: Option<CacheControlDirectives>;
    #[getter]
    #[setter]
    extern "js" cachedAt: f64;
    #[getter]
    #[setter]
    extern "js" staleAt: f64;
    #[getter]
    #[setter]
    extern "js" deleteAt: f64;
}

impl CallArgument {
    #[getter]
    #[setter]
    extern "js" value: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" unserializableValue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
}

impl CallFrame {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" functionLocation: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" scopeChain: JsArray<Scope>;
    #[getter]
    #[setter]
    extern "js" this: RemoteObject;
    #[getter]
    #[setter]
    extern "js" returnValue: Option<Option<RemoteObject>>;
}

impl CallFunctionOnParameterType {
    #[getter]
    #[setter]
    extern "js" functionDeclaration: String;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" arguments: Option<Option<JsArray<CallArgument>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" userGesture: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
}

impl CallFunctionOnReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl CallSite {
    extern "js" fn isNative(self) -> bool;
    extern "js" fn isToplevel(self) -> bool;
    extern "js" fn getScriptNameOrSourceURL(self) -> Option<String>;
    extern "js" fn getFileName(self) -> Option<String>;
    extern "js" fn getEnclosingColumnNumber(self) -> Option<f64>;
    extern "js" fn getThis(self) -> JsValue;
    extern "js" fn getColumnNumber(self) -> Option<f64>;
    extern "js" fn getMethodName(self) -> Option<String>;
    extern "js" fn isConstructor(self) -> bool;
    extern "js" fn isEval(self) -> bool;
    extern "js" fn isAsync(self) -> bool;
    extern "js" fn getFunctionName(self) -> Option<String>;
    extern "js" fn getEvalOrigin(self) -> Option<String>;
    extern "js" fn getEnclosingLineNumber(self) -> Option<f64>;
    extern "js" fn getPromiseIndex(self) -> Option<f64>;
    extern "js" fn getLineNumber(self) -> Option<f64>;
    extern "js" fn getPosition(self) -> f64;
    extern "js" fn getTypeName(self) -> Option<String>;
    extern "js" fn isPromiseAll(self) -> bool;
    extern "js" fn getScriptHash(self) -> String;
    extern "js" fn getFunction(self) -> Option<JsFn>;
}

impl CallSiteObject {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" scriptName: String;
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl CallTracker {
    extern "js" fn reset(self, fn_: Option<JsFn>);
    // merged from 4 overloads
    extern "js" fn calls(self, fn_: (), exact: Option<f64>) -> fn() -> ();
    extern "js" fn getCalls(self, fn_: JsFn) -> JsArray<CallTrackerCall>;
    extern "js" fn report(self) -> JsArray<CallTrackerReportInformation>;
    extern "js" fn verify(self);
}

impl CallTrackerCall {
    #[getter]
    #[setter]
    extern "js" thisArg: JsValue;
    #[getter]
    #[setter]
    extern "js" arguments: JsArray<JsValue>;
}

impl CallTrackerReportInformation {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" actual: f64;
    #[getter]
    #[setter]
    extern "js" expected: f64;
    #[getter]
    #[setter]
    extern "js" operator: String;
    #[getter]
    #[setter]
    extern "js" stack: JsValue;
}

impl Certificate {
    #[getter]
    #[setter]
    extern "js" C: String;
    #[getter]
    #[setter]
    extern "js" ST: String;
    #[getter]
    #[setter]
    extern "js" L: String;
    #[getter]
    #[setter]
    extern "js" O: String;
    #[getter]
    #[setter]
    extern "js" OU: String;
    #[getter]
    #[setter]
    extern "js" CN: String;

    extern "js" fn exportChallenge(self, spkac: JsValue) -> JsValue;
    extern "js" fn exportPublicKey(self, spkac: JsValue, encoding: Option<String>) -> JsValue;
    extern "js" fn verifySpkac(self, spkac: JsValue) -> bool;
    extern "js" fn exportPublicKey(spkac: JsValue, encoding: Option<String>) -> JsValue;
    extern "js" fn verifySpkac(spkac: JsValue) -> bool;
    extern "js" fn exportChallenge(spkac: JsValue) -> JsValue;
}

impl Channel<StoreType, ContextType> {
    extern "js" fn unbindStore(self, store: AsyncLocalStorage<StoreType>) -> bool;
    // property (readonly)
    extern "js" fn hasSubscribers(self) -> bool;
    extern "js" fn unsubscribe(self, onMessage: fn(JsValue, JsValue) -> ());
    // property (readonly)
    extern "js" fn name(self) -> JsValue;
    extern "js" fn publish(self, message: JsValue);
    extern "js" fn bindStore(self, store: AsyncLocalStorage<StoreType>, transform: Option<fn(ContextType) -> StoreType>);
    extern "js" fn new<StoreType, ContextType>(name: JsValue) -> Channel;
    extern "js" fn subscribe(self, onMessage: fn(JsValue, JsValue) -> ());
    extern "js" fn runStores(self, context: ContextType, fn_: JsFn, thisArg: Option<ThisArg>, args: Args) -> Result;
}

impl CheckPrimeOptions {
    #[getter]
    #[setter]
    extern "js" checks: Option<Option<f64>>;
}

impl ChildProcess {
    // property (readonly)
    extern "js" fn pid(self) -> Option<Option<f64>>;
    // property getter
    extern "js" fn stdout(self) -> Option<Readable>;
    // property (readonly)
    extern "js" fn spawnargs(self) -> JsArray<String>;
    // property (readonly)
    extern "js" fn signalCode(self) -> Option<String>;
    // property (readonly)
    extern "js" fn connected(self) -> bool;
    // property getter
    extern "js" fn stdin(self) -> Option<Writable>;
    extern "js" fn kill(self, signal: Option<JsValue>) -> bool;
    // property setter
    extern "js" fn set_stdin(self, value: Option<Writable>);
    extern "js" fn ref(self);
    // property (readonly)
    extern "js" fn killed(self) -> bool;
    extern "js" fn unref(self);
    // property (readonly)
    extern "js" fn spawnfile(self) -> String;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // property setter
    extern "js" fn set_stdout(self, value: Option<Readable>);
    // merged from 3 overloads
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // property (readonly)
    extern "js" fn exitCode(self) -> Option<f64>;
    extern "js" fn disconnect(self);
    // property (readonly)
    extern "js" fn channel(self) -> Option<Option<Control>>;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // property (readonly)
    extern "js" fn stdio(self) -> JsValue;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // property getter
    extern "js" fn stderr(self) -> Option<Readable>;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
    // property setter
    extern "js" fn set_stderr(self, value: Option<Readable>);
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> ChildProcess;
}

impl ChildProcessByStdio<I, O, E> {
    #[getter]
    #[setter]
    extern "js" stdin: I;
    #[getter]
    #[setter]
    extern "js" stdout: O;
    #[getter]
    #[setter]
    extern "js" stderr: E;
    #[getter]
    extern "js" stdio: JsValue;
}

impl ChildProcessWithoutNullStreams {
    #[getter]
    #[setter]
    extern "js" stdin: Writable;
    #[getter]
    #[setter]
    extern "js" stdout: Readable;
    #[getter]
    #[setter]
    extern "js" stderr: Readable;
    #[getter]
    extern "js" stdio: JsValue;
}

impl CipherCCM {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> CipherCCM;
}

impl CipherCCMOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: f64;
}

impl CipherChaCha20Poly1305 {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> CipherChaCha20Poly1305;
}

impl CipherChaCha20Poly1305Options {
    #[getter]
    #[setter]
    extern "js" authTagLength: Option<Option<f64>>;
}

impl CipherGCM {
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> CipherGCM;
    extern "js" fn getAuthTag(self) -> JsValue;
}

impl CipherGCMOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: Option<Option<f64>>;
}

impl CipherInfo {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nid: f64;
    #[getter]
    #[setter]
    extern "js" blockSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ivLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keyLength: f64;
    #[getter]
    #[setter]
    extern "js" mode: String;
}

impl CipherInfoOptions {
    #[getter]
    #[setter]
    extern "js" keyLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ivLength: Option<Option<f64>>;
}

impl CipherNameAndProtocol {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" version: String;
    #[getter]
    #[setter]
    extern "js" standardName: String;
}

impl CipherOCB {
    extern "js" fn getAuthTag(self) -> JsValue;
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> CipherOCB;
}

impl CipherOCBOptions {
    #[getter]
    #[setter]
    extern "js" authTagLength: f64;
}

impl Cipheriv {
    extern "js" fn setAutoPadding(self, autoPadding: Option<bool>) -> Cipheriv;
    // merged from 4 overloads
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
    extern "js" fn new() -> Cipheriv;
    // merged from 2 overloads
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
}

impl Client {
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn pipelining(self) -> f64;
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
    // merged from 2 overloads
    extern "js" fn connect(self, options: JsValue, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
    // property setter
    extern "js" fn set_pipelining(self, value: f64);
    // property getter
    extern "js" fn closed(self) -> bool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn new(url: JsValue, options: Option<Options>) -> Client;
}

impl ClientBeforeConnectMessage {
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientClosedError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl ClientConnectErrorMessage {
    #[getter]
    #[setter]
    extern "js" error: JsValue;
    #[getter]
    #[setter]
    extern "js" socket: Socket;
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientConnectedMessage {
    #[getter]
    #[setter]
    extern "js" socket: Socket;
    #[getter]
    #[setter]
    extern "js" connectParams: ConnectParams;
    #[getter]
    #[setter]
    extern "js" connector: connector;
}

impl ClientDestroyedError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl ClientHttp2Session {
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    extern "js" fn request(self, headers: Option<JsValue>, options: Option<ClientSessionRequestOptions>) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn(String, String, f64) -> ()) -> ClientHttp2Session;
    // merged from 5 overloads
    extern "js" fn emit(self, event: String, stream: ClientHttp2Stream, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
}

impl ClientHttp2Stream {
    // merged from 5 overloads
    extern "js" fn emit(self, event: String, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn() -> JsValue) -> ClientHttp2Stream;
}

impl ClientRequest {
    // property getter
    extern "js" fn aborted(self) -> bool;
    // property getter
    extern "js" fn host(self) -> String;
    // property getter
    extern "js" fn reusedSocket(self) -> bool;
    extern "js" fn setNoDelay(self, noDelay: Option<bool>);
    // property getter
    extern "js" fn maxHeadersCount(self) -> f64;
    // property getter
    extern "js" fn path(self) -> String;
    // property getter
    extern "js" fn protocol(self) -> String;
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property setter
    extern "js" fn set_reusedSocket(self, value: bool);
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property setter
    extern "js" fn set_method(self, value: String);
    extern "js" fn abort(self);
    extern "js" fn setTimeout(self, timeout: f64, callback: Option<fn() -> ()>) -> ClientRequest;
    extern "js" fn setSocketKeepAlive(self, enable: Option<bool>, initialDelay: Option<f64>);
    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property setter
    extern "js" fn set_protocol(self, value: String);
    // property setter
    extern "js" fn set_maxHeadersCount(self, value: f64);
    extern "js" fn getRawHeaderNames(self) -> JsArray<String>;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property setter
    extern "js" fn set_host(self, value: String);
    extern "js" fn onSocket(self, socket: Socket);
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> ClientRequest;
    // property setter
    extern "js" fn set_path(self, value: String);
    extern "js" fn new(url: JsValue, cb: Option<fn(IncomingMessage) -> ()>) -> ClientRequest;
    // property setter
    extern "js" fn set_aborted(self, value: bool);
    // property getter
    extern "js" fn method(self) -> String;
}

impl ClientRequestArgs {
    #[getter]
    #[setter]
    extern "js" _defaultAgent: Option<Option<Agent>>;
    #[getter]
    #[setter]
    extern "js" agent: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" createConnection: Option<Option<fn(ClientRequestArgs, fn(Option<JsValue>, Duplex) -> ()) -> Option<Duplex>>>;
    #[getter]
    #[setter]
    extern "js" defaultPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" insecureHTTPParser: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" setDefaultHeaders: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setHost: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uniqueHeaders: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" joinDuplicateHeaders: Option<Option<bool>>;
}

impl ClientSendHeadersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" headers: String;
    #[getter]
    #[setter]
    extern "js" socket: Socket;
}

impl ClientSessionOptions {
    #[getter]
    #[setter]
    extern "js" maxReservedRemoteStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" createConnection: Option<Option<fn(URL, SessionOptions) -> Duplex>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
}

impl ClientSessionRequestOptions {
    #[getter]
    #[setter]
    extern "js" endStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" parent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ClientStats {
    // property setter
    extern "js" fn set_connected(self, value: bool);
    // property getter
    extern "js" fn connected(self) -> bool;
    // property getter
    extern "js" fn pending(self) -> f64;
    // property getter
    extern "js" fn running(self) -> f64;
    // property setter
    extern "js" fn set_pending(self, value: f64);
    // property setter
    extern "js" fn set_running(self, value: f64);
    // property getter
    extern "js" fn size(self) -> f64;
    extern "js" fn new(pool: Client) -> ClientStats;
    // property setter
    extern "js" fn set_size(self, value: f64);
}

impl CloseEvent {
    #[getter]
    extern "js" code: f64;
    #[getter]
    extern "js" reason: String;
    #[getter]
    extern "js" wasClean: bool;
}

impl CloseEventInit {
    #[getter]
    #[setter]
    extern "js" code: Option<f64>;
    #[getter]
    #[setter]
    extern "js" reason: Option<String>;
    #[getter]
    #[setter]
    extern "js" wasClean: Option<bool>;
}

impl CloseParameterType {
    #[getter]
    #[setter]
    extern "js" handle: String;
}

impl Cluster {
    #[getter]
    extern "js" isMaster: bool;
    #[getter]
    extern "js" isPrimary: bool;
    #[getter]
    extern "js" isWorker: bool;
    #[getter]
    #[setter]
    extern "js" schedulingPolicy: f64;
    #[getter]
    extern "js" settings: ClusterSettings;
    #[getter]
    extern "js" worker: Option<Worker>;
    #[getter]
    extern "js" workers: Option<Dict<Worker>>;
    #[getter]
    extern "js" SCHED_NONE: f64;
    #[getter]
    extern "js" SCHED_RR: f64;

    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    extern "js" fn fork(self, env: Option<JsValue>) -> Worker;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    extern "js" fn setupPrimary(self, settings: Option<ClusterSettings>);
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Cluster;
    extern "js" fn disconnect(self, callback: Option<fn() -> ()>);
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, worker: Worker, code: Option<f64>, signal: Option<String>) -> bool;
    extern "js" fn setupMaster(self, settings: Option<ClusterSettings>);
}

impl ClusterSettings {
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" exec: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" inspectPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
}

impl CommonConnectionOptions {
    #[getter]
    #[setter]
    extern "js" secureContext: Option<Option<SecureContext>>;
    #[getter]
    #[setter]
    extern "js" enableTrace: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requestCert: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ALPNProtocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" SNICallback: Option<Option<fn(String, fn(Option<JsValue>, SecureContext) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
}

impl CommonExecOptions {
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
}

impl CommonOptions {
    #[getter]
    #[setter]
    extern "js" windowsHide: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl CommonSpawnOptions {
    #[getter]
    #[setter]
    extern "js" argv0: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
}

impl CompileFunctionOptions {
    #[getter]
    #[setter]
    extern "js" parsingContext: Option<Option<Context>>;
    #[getter]
    #[setter]
    extern "js" contextExtensions: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl CompileScriptParameterType {
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" sourceURL: String;
    #[getter]
    #[setter]
    extern "js" persistScript: bool;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl CompileScriptReturnType {
    #[getter]
    #[setter]
    extern "js" scriptId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl CompressionStream {
    extern "js" fn new(format: String) -> CompressionStream;
    // property (readonly)
    extern "js" fn writable(self) -> WritableStream;
    // property (readonly)
    extern "js" fn readable(self) -> ReadableStream;
}

impl ConnectData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
}

impl ConnectOptions<TOpaque> {
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<TOpaque>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: JsValue;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<TOpaque>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
}

impl ConnectParams {
    #[getter]
    #[setter]
    extern "js" host: JsValue;
    #[getter]
    #[setter]
    extern "js" hostname: JsValue;
    #[getter]
    #[setter]
    extern "js" protocol: JsValue;
    #[getter]
    #[setter]
    extern "js" port: JsValue;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
}

impl ConnectTimeoutError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl ConnectionOptions {
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" socket: Option<Option<Duplex>>;
    #[getter]
    #[setter]
    extern "js" checkServerIdentity: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" servername: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" session: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" minDHSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" pskCallback: Option<Option<fn(Option<String>) -> Option<PSKCallbackNegotation>>>;
}

impl Console {
    #[getter]
    #[setter]
    extern "js" Console: ConsoleConstructor;

    extern "js" fn timeLog(self, label: Option<String>, data: JsArray<JsValue>);
    extern "js" fn warn(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn profile(self, label: Option<String>);
    extern "js" fn timeEnd(self, label: Option<String>);
    extern "js" fn dir(self, obj: JsValue, options: Option<InspectOptions>);
    extern "js" fn countReset(self, label: Option<String>);
    extern "js" fn groupEnd(self);
    extern "js" fn profileEnd(self, label: Option<String>);
    extern "js" fn info(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn log(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn dirxml(self, data: JsArray<JsValue>);
    extern "js" fn trace(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn time(self, label: Option<String>);
    extern "js" fn debug(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn timeStamp(self, label: Option<String>);
    extern "js" fn assert(self, value: JsValue, message: Option<String>, optionalParams: JsArray<JsValue>);
    extern "js" fn table(self, tabularData: JsValue, properties: Option<JsArray<String>>);
    extern "js" fn group(self, label: JsArray<JsValue>);
    extern "js" fn error(self, message: Option<JsValue>, optionalParams: JsArray<JsValue>);
    extern "js" fn clear(self);
    extern "js" fn groupCollapsed(self, label: JsArray<JsValue>);
    extern "js" fn count(self, label: Option<String>);
}

impl ConsoleAPICalledEventDataType {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" args: JsArray<RemoteObject>;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<String>>;
}

impl ConsoleConstructor {
    #[getter]
    #[setter]
    extern "js" prototype: Console;
}

impl ConsoleConstructorOptions {
    #[getter]
    #[setter]
    extern "js" stdout: WritableStream;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" ignoreErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" colorMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" inspectOptions: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" groupIndentation: Option<Option<f64>>;
}

impl ConsoleMessage {
    #[getter]
    #[setter]
    extern "js" source: String;
    #[getter]
    #[setter]
    extern "js" level: String;
    #[getter]
    #[setter]
    extern "js" text: String;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" line: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" column: Option<Option<f64>>;
}

impl ConsoleProfileFinishedEventDataType {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" profile: Profile;
    #[getter]
    #[setter]
    extern "js" title: Option<Option<String>>;
}

impl ConsoleProfileStartedEventDataType {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" title: Option<Option<String>>;
}

impl ContextParams {
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl ContinueToLocationParameterType {
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" targetCallFrames: Option<Option<String>>;
}

impl Control {
    extern "js" fn ref(self);
    extern "js" fn unref(self);
}

impl Cookie {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: String;
    #[getter]
    #[setter]
    extern "js" expires: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxAge: Option<f64>;
    #[getter]
    #[setter]
    extern "js" domain: Option<String>;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" secure: Option<bool>;
    #[getter]
    #[setter]
    extern "js" httpOnly: Option<bool>;
    #[getter]
    #[setter]
    extern "js" sameSite: Option<String>;
    #[getter]
    #[setter]
    extern "js" unparsed: Option<JsArray<String>>;
}

impl CookieOptions {
    #[getter]
    #[setter]
    extern "js" maxAge: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signed: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" expires: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" httpOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" domain: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" secure: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" encode: Option<Option<fn(String) -> String>>;
    #[getter]
    #[setter]
    extern "js" sameSite: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" priority: Option<String>;
    #[getter]
    #[setter]
    extern "js" partitioned: Option<Option<bool>>;
}

impl CopyOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String, String) -> JsValue>>;
}

impl CopyOptionsBase {
    #[getter]
    #[setter]
    extern "js" dereference: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" errorOnExist: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" preserveTimestamps: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" verbatimSymlinks: Option<Option<bool>>;
}

impl CopySyncOptions {
    #[getter]
    #[setter]
    extern "js" filter: Option<Option<fn(String, String) -> bool>>;
}

impl CountQueuingStrategy {
    #[getter]
    extern "js" highWaterMark: f64;
    #[getter]
    extern "js" size: QueuingStrategySize;
}

impl CoverageRange {
    #[getter]
    #[setter]
    extern "js" startOffset: f64;
    #[getter]
    #[setter]
    extern "js" endOffset: f64;
    #[getter]
    #[setter]
    extern "js" count: f64;
}

impl CpuInfo {
    #[getter]
    #[setter]
    extern "js" model: String;
    #[getter]
    #[setter]
    extern "js" speed: f64;
    #[getter]
    #[setter]
    extern "js" times: JsValue;
}

impl CpuUsage {
    #[getter]
    #[setter]
    extern "js" user: f64;
    #[getter]
    #[setter]
    extern "js" system: f64;
}

impl CreateContextOptions {
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" codeGeneration: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" microtaskMode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl CreateHistogramOptions {
    #[getter]
    #[setter]
    extern "js" lowest: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" highest: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" figures: Option<Option<f64>>;
}

impl CreateReadStreamFSImplementation {
    // function property
    extern "js" fn read(self) -> fn(JsArray<JsValue>) -> JsValue;
}

impl CreateReadStreamOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
}

impl CreateSessionOptions {
    #[getter]
    #[setter]
    extern "js" table: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" db: Option<Option<String>>;
}

impl CreateTracingOptions {
    #[getter]
    #[setter]
    extern "js" categories: JsArray<String>;
}

impl CreateWriteStreamFSImplementation {
    // function property
    extern "js" fn write(self) -> fn(JsArray<JsValue>) -> JsValue;
    // function property
    extern "js" fn writev(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
}

impl CreateWriteStreamOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<bool>>;
}

impl Crypto {
    #[getter]
    extern "js" subtle: SubtleCrypto;

    extern "js" fn randomUUID(self) -> String;
    extern "js" fn getRandomValues(self, typedArray: JsValue) -> JsValue;
}

impl CryptoKey {
    #[getter]
    extern "js" algorithm: KeyAlgorithm;
    #[getter]
    extern "js" extractable: bool;
    #[getter]
    extern "js" type_: String;
    #[getter]
    extern "js" usages: JsArray<String>;
}

impl CryptoKeyPair {
    #[getter]
    #[setter]
    extern "js" privateKey: CryptoKey;
    #[getter]
    #[setter]
    extern "js" publicKey: CryptoKey;
}

impl CursorPos {
    #[getter]
    #[setter]
    extern "js" rows: f64;
    #[getter]
    #[setter]
    extern "js" cols: f64;
}

impl CustomEvent<T> {
    #[getter]
    extern "js" detail: T;
}

impl CustomEventInit<T> {
    #[getter]
    #[setter]
    extern "js" detail: Option<T>;
}

impl CustomPreview {
    #[getter]
    #[setter]
    extern "js" header: String;
    #[getter]
    #[setter]
    extern "js" hasBody: bool;
    #[getter]
    #[setter]
    extern "js" formatterObjectId: String;
    #[getter]
    #[setter]
    extern "js" bindRemoteObjectFunctionId: String;
    #[getter]
    #[setter]
    extern "js" configObjectId: Option<Option<String>>;
}

impl CustomPromisifyLegacy<TCustom> {
    #[getter]
    #[setter]
    extern "js" __promisify__: TCustom;
}

impl DOMException {
    #[getter]
    extern "js" code: f64;
    #[getter]
    extern "js" message: String;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" INDEX_SIZE_ERR: f64;
    #[getter]
    extern "js" DOMSTRING_SIZE_ERR: f64;
    #[getter]
    extern "js" HIERARCHY_REQUEST_ERR: f64;
    #[getter]
    extern "js" WRONG_DOCUMENT_ERR: f64;
    #[getter]
    extern "js" INVALID_CHARACTER_ERR: f64;
    #[getter]
    extern "js" NO_DATA_ALLOWED_ERR: f64;
    #[getter]
    extern "js" NO_MODIFICATION_ALLOWED_ERR: f64;
    #[getter]
    extern "js" NOT_FOUND_ERR: f64;
    #[getter]
    extern "js" NOT_SUPPORTED_ERR: f64;
    #[getter]
    extern "js" INUSE_ATTRIBUTE_ERR: f64;
    #[getter]
    extern "js" INVALID_STATE_ERR: f64;
    #[getter]
    extern "js" SYNTAX_ERR: f64;
    #[getter]
    extern "js" INVALID_MODIFICATION_ERR: f64;
    #[getter]
    extern "js" NAMESPACE_ERR: f64;
    #[getter]
    extern "js" INVALID_ACCESS_ERR: f64;
    #[getter]
    extern "js" VALIDATION_ERR: f64;
    #[getter]
    extern "js" TYPE_MISMATCH_ERR: f64;
    #[getter]
    extern "js" SECURITY_ERR: f64;
    #[getter]
    extern "js" NETWORK_ERR: f64;
    #[getter]
    extern "js" ABORT_ERR: f64;
    #[getter]
    extern "js" URL_MISMATCH_ERR: f64;
    #[getter]
    extern "js" QUOTA_EXCEEDED_ERR: f64;
    #[getter]
    extern "js" TIMEOUT_ERR: f64;
    #[getter]
    extern "js" INVALID_NODE_TYPE_ERR: f64;
    #[getter]
    extern "js" DATA_CLONE_ERR: f64;
}

impl DSAKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" divisorLength: f64;
}

impl DSAKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" divisorLength: f64;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl DataCollectedEventDataType {
    #[getter]
    #[setter]
    extern "js" value: JsArray<JsValue>;
}

impl DataReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" dataLength: f64;
    #[getter]
    #[setter]
    extern "js" encodedDataLength: f64;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<String>>;
}

impl DatabaseSync {
    extern "js" fn close(self);
    // merged from 2 overloads
    extern "js" fn function_(self, name: String, options: FunctionOptions, func: Option<fn(JsArray<JsValue>) -> JsValue>);
    extern "js" fn loadExtension(self, path: String);
    extern "js" fn setAuthorizer(self, callback: Option<fn(f64, Option<String>, Option<String>, Option<String>, Option<String>) -> f64>);
    // property (readonly)
    extern "js" fn isTransaction(self) -> bool;
    // merged from 2 overloads
    extern "js" fn aggregate(self, name: String, options: AggregateOptions);
    extern "js" fn enableLoadExtension(self, allow: bool);
    extern "js" fn location(self, dbName: Option<String>) -> Option<String>;
    extern "js" fn exec(self, sql: String);
    extern "js" fn createTagStore(self, maxSize: Option<f64>) -> SQLTagStore;
    // property (readonly)
    extern "js" fn isOpen(self) -> bool;
    extern "js" fn prepare(self, sql: String) -> StatementSync;
    extern "js" fn createSession(self, options: Option<CreateSessionOptions>) -> Session;
    extern "js" fn applyChangeset(self, changeset: JsValue, options: Option<ApplyChangesetOptions>) -> bool;
    extern "js" fn new(path: JsValue, options: Option<DatabaseSyncOptions>) -> DatabaseSync;
    extern "js" fn open(self);
}

impl DatabaseSyncOptions {
    #[getter]
    #[setter]
    extern "js" open: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" enableForeignKeyConstraints: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" enableDoubleQuotedStringLiterals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowExtension: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" readBigInts: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnArrays: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowBareNamedParameters: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowUnknownNamedParameters: Option<Option<bool>>;
}

impl DebugLogger {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl DecipherCCM {
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> DecipherCCM;
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherCCM;
}

impl DecipherChaCha20Poly1305 {
    extern "js" fn setAAD(self, buffer: JsValue, options: JsValue) -> DecipherChaCha20Poly1305;
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherChaCha20Poly1305;
}

impl DecipherGCM {
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> DecipherGCM;
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherGCM;
}

impl DecipherOCB {
    extern "js" fn setAuthTag(self, buffer: JsValue) -> DecipherOCB;
    extern "js" fn setAAD(self, buffer: JsValue, options: Option<JsValue>) -> DecipherOCB;
}

impl Decipheriv {
    // merged from 2 overloads
    extern "js" fn final(self, outputEncoding: Option<JsValue>) -> String;
    extern "js" fn setAutoPadding(self, auto_padding: Option<bool>) -> Decipheriv;
    extern "js" fn new() -> Decipheriv;
    // merged from 4 overloads
    extern "js" fn update(self, data: JsValue, inputEncoding: Option<()>, outputEncoding: Option<JsValue>) -> String;
}

impl DecompressionStream {
    extern "js" fn new(format: String) -> DecompressionStream;
    // property (readonly)
    extern "js" fn readable(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn writable(self) -> WritableStream;
}

impl DecoratorHandler {
    extern "js" fn new(handler: DispatchHandler) -> DecoratorHandler;
}

impl DeleteByUri {
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" path: String;
}

impl Deserializer {
    extern "js" fn new(data: JsValue) -> Deserializer;
    extern "js" fn readHeader(self) -> bool;
    extern "js" fn readValue(self) -> JsValue;
    extern "js" fn transferArrayBuffer(self, id: f64, arrayBuffer: JsValue);
    extern "js" fn readUint64(self) -> (f64, f64);
    extern "js" fn readDouble(self) -> f64;
    extern "js" fn getWireFormatVersion(self) -> f64;
    extern "js" fn readUint32(self) -> f64;
    extern "js" fn readRawBytes(self, length: f64) -> Buffer;
}

impl DetachParameterType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl DetachedFromWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl DetailedPeerCertificate {
    #[getter]
    #[setter]
    extern "js" issuerCertificate: DetailedPeerCertificate;
}

impl DiffieHellman {
    extern "js" fn new() -> DiffieHellman;
    // merged from 2 overloads
    extern "js" fn getPrime(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getPublicKey(self, encoding: Option<String>) -> String;
    // merged from 4 overloads
    extern "js" fn computeSecret(self, otherPublicKey: JsValue, inputEncoding: Option<()>, outputEncoding: Option<()>) -> JsValue;
    // property getter
    extern "js" fn verifyError(self) -> f64;
    // merged from 2 overloads
    extern "js" fn generateKeys(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getPrivateKey(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn getGenerator(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn setPublicKey(self, publicKey: String, encoding: Option<JsValue>);
    // merged from 2 overloads
    extern "js" fn setPrivateKey(self, privateKey: String, encoding: Option<JsValue>);
    // property setter
    extern "js" fn set_verifyError(self, value: f64);
}

impl DiffieHellmanGroupConstructor {
    #[getter]
    extern "js" prototype: JsValue;
}

impl Dir {
    extern "js" fn closeSync(self);
    extern "js" fn readSync(self) -> Option<Dirent>;
    // property (readonly)
    extern "js" fn path(self) -> String;
    // merged from 2 overloads
    extern "js" fn read(self, cb: Option<fn(Option<ErrnoException>, Option<Dirent>) -> ()>);
    // merged from 2 overloads
    extern "js" fn close(self, cb: Option<fn(Option<ErrnoException>) -> ()>);
}

impl Dirent<Name> {
    extern "js" fn isBlockDevice(self) -> bool;
    extern "js" fn isSymbolicLink(self) -> bool;
    extern "js" fn isDirectory(self) -> bool;
    extern "js" fn isSocket(self) -> bool;
    // property getter
    extern "js" fn name(self) -> Name;
    // property setter
    extern "js" fn set_name(self, value: Name);
    // property getter
    extern "js" fn parentPath(self) -> String;
    extern "js" fn isFile(self) -> bool;
    extern "js" fn isCharacterDevice(self) -> bool;
    // property setter
    extern "js" fn set_parentPath(self, value: String);
    extern "js" fn isFIFO(self) -> bool;
}

impl DispatchController {
    extern "js" fn abort(self, reason: JsValue);
    extern "js" fn pause(self);
    extern "js" fn reason(self) -> Option<JsValue>;
    extern "js" fn aborted(self) -> bool;
    extern "js" fn resume(self);
    extern "js" fn paused(self) -> bool;
}

impl DispatchHandler {
    extern "js" fn onRequestStart(self, controller: DispatchController, context: JsValue);
    extern "js" fn onConnect(self, abort: fn(JsValue) -> ());
    extern "js" fn onUpgrade(self, statusCode: f64, headers: JsValue, socket: Duplex);
    extern "js" fn onError(self, err: JsValue);
    extern "js" fn onHeaders(self, statusCode: f64, headers: JsArray<Buffer>, resume: fn() -> (), statusText: String) -> bool;
    extern "js" fn onData(self, chunk: Buffer) -> bool;
    extern "js" fn onResponseEnd(self, controller: DispatchController, trailers: IncomingHttpHeaders);
    extern "js" fn onComplete(self, trailers: Option<JsArray<String>>);
    extern "js" fn onBodySent(self, chunkSize: f64, totalBytesSent: f64);
    extern "js" fn onResponseStart(self, controller: DispatchController, statusCode: f64, headers: IncomingHttpHeaders, statusMessage: Option<String>);
    extern "js" fn onResponseStarted(self);
    extern "js" fn onResponseError(self, controller: DispatchController, error: JsValue);
    extern "js" fn onResponseData(self, controller: DispatchController, chunk: Buffer);
    extern "js" fn onRequestUpgrade(self, controller: DispatchController, statusCode: f64, headers: IncomingHttpHeaders, socket: Duplex);
}

impl DispatchOptions {
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: JsValue;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" idempotent: Option<bool>;
    #[getter]
    #[setter]
    extern "js" blocking: Option<bool>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" reset: Option<bool>;
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" expectContinue: Option<bool>;
}

impl Dispatcher {
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    // merged from 4 overloads
    extern "js" fn prependOnceListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn prependListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 2 overloads
    extern "js" fn compose(self, dispatchers: JsArray<fn(JsValue) -> JsValue>) -> ComposedDispatcher;
    // merged from 4 overloads
    extern "js" fn listeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // merged from 2 overloads
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn stream(self, options: RequestOptions<TOpaque>, factory: fn(StreamFactoryData<TOpaque>) -> Writable, callback: Option<fn(Option<JsValue>, StreamData<TOpaque>) -> ()>);
    extern "js" fn pipeline(self, options: PipelineOptions<TOpaque>, handler: fn(PipelineHandlerData<TOpaque>) -> Readable) -> Duplex;
    // merged from 4 overloads
    extern "js" fn off(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn on(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn once(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn rawListeners(self, eventName: String) -> JsArray<fn(URL, JsArray<Dispatcher>) -> ()>;
    // merged from 4 overloads
    extern "js" fn emit(self, eventName: String, origin: URL, targets: Option<JsArray<Dispatcher>>, error: Option<UndiciError>) -> bool;
    // merged from 2 overloads
    extern "js" fn upgrade(self, options: UpgradeOptions, callback: Option<fn(Option<JsValue>, UpgradeData) -> ()>);
    // merged from 4 overloads
    extern "js" fn removeListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 4 overloads
    extern "js" fn addListener(self, eventName: String, callback: fn(URL, JsArray<Dispatcher>) -> ()) -> Dispatcher;
    // merged from 2 overloads
    extern "js" fn connect(self, options: ConnectOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ConnectData<TOpaque>) -> ()>);
    // merged from 4 overloads
    extern "js" fn destroy(self, err: Option<JsValue>, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn request(self, options: RequestOptions<TOpaque>, callback: Option<fn(Option<JsValue>, ResponseData<TOpaque>) -> ()>);
}

impl DisposableTempDir {
    #[getter]
    #[setter]
    extern "js" path: String;

    extern "js" fn remove(self) -> JsPromise<()>;
}

impl Domain {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" version: String;

    extern "js" fn intercept(self, callback: T) -> T;
    extern "js" fn run(self, fn_: fn(JsArray<JsValue>) -> T, args: JsArray<JsValue>) -> T;
    // property getter
    extern "js" fn members(self) -> JsArray<JsValue>;
    // property setter
    extern "js" fn set_members(self, value: JsArray<JsValue>);
    extern "js" fn exit(self);
    extern "js" fn enter(self);
    extern "js" fn remove(self, emitter: JsValue);
    extern "js" fn add(self, emitter: JsValue);
    extern "js" fn bind(self, callback: T) -> T;
}

impl DownloadOptions {
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl DropArgument {
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
}

impl Duplex {
    // merged from 12 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Duplex;
    extern "js" fn new(opts: Option<DuplexOptions>) -> Duplex;
    extern "js" fn toWeb(streamDuplex: Duplex) -> JsValue;
    // property getter
    extern "js" fn allowHalfOpen(self) -> bool;
    // merged from 12 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Duplex;
    extern "js" fn from(src: JsValue) -> Duplex;
    extern "js" fn fromWeb(duplexStream: JsValue, options: Option<JsValue>) -> Duplex;
    // merged from 12 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // merged from 12 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // merged from 12 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Duplex;
    // property setter
    extern "js" fn set_allowHalfOpen(self, value: bool);
    // merged from 12 overloads
    extern "js" fn emit(self, event: String, chunk: Option<JsValue>) -> bool;
    // merged from 12 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Duplex;
}

impl DuplexOptions<T> {
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writableObjectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableHighWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" writableCorked: Option<Option<f64>>;
}

impl ECDH {
    // merged from 2 overloads
    extern "js" fn getPublicKey(self, encoding: Option<()>, format: Option<String>) -> JsValue;
    extern "js" fn new() -> ECDH;
    // merged from 2 overloads
    extern "js" fn getPrivateKey(self, encoding: Option<String>) -> String;
    // merged from 4 overloads
    extern "js" fn computeSecret(self, otherPublicKey: String, inputEncoding: Option<String>, outputEncoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn generateKeys(self, encoding: Option<String>, format: Option<String>) -> String;
    extern "js" fn convertKey(key: JsValue, curve: String, inputEncoding: Option<String>, outputEncoding: Option<String>, format: Option<String>) -> JsValue;
    // merged from 2 overloads
    extern "js" fn setPrivateKey(self, privateKey: String, encoding: Option<String>);
}

impl ECKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
    #[getter]
    #[setter]
    extern "js" paramEncoding: Option<JsValue>;
}

impl ECKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl ED25519KeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl ED448KeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl EcKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
}

impl EcKeyGenParams {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
}

impl EcKeyImportParams {
    #[getter]
    #[setter]
    extern "js" namedCurve: String;
}

impl EcdhKeyDeriveParams {
    #[getter]
    #[setter]
    extern "js" public_: CryptoKey;
}

impl EcdsaParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
}

impl EmitWarningOptions {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" code: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ctor: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" detail: Option<Option<String>>;
}

impl EnableCompileCacheResult {
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" message: Option<String>;
    #[getter]
    #[setter]
    extern "js" directory: Option<String>;
}

impl EnableParameterType {
    #[getter]
    #[setter]
    extern "js" waitForDebuggerOnStart: bool;
}

impl EnableReturnType {
    #[getter]
    #[setter]
    extern "js" debuggerId: String;
}

impl EncapsulatedBits {
    #[getter]
    #[setter]
    extern "js" sharedKey: JsValue;
    #[getter]
    #[setter]
    extern "js" ciphertext: JsValue;
}

impl EncapsulatedKey {
    #[getter]
    #[setter]
    extern "js" sharedKey: CryptoKey;
    #[getter]
    #[setter]
    extern "js" ciphertext: JsValue;
}

impl EncodeIntoResult {
    #[getter]
    #[setter]
    extern "js" read: f64;
    #[getter]
    #[setter]
    extern "js" written: f64;
}

impl EntryPreview {
    #[getter]
    #[setter]
    extern "js" key: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" value: ObjectPreview;
}

impl EnvHttpProxyAgent {
    extern "js" fn new(opts: Option<Options>) -> EnvHttpProxyAgent;
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
}

impl EphemeralKeyInfo {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" size: f64;
}

impl ErrnoException {
    #[getter]
    #[setter]
    extern "js" errno: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" code: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" syscall: Option<Option<String>>;
}

impl Error {
    #[getter]
    #[setter]
    extern "js" cause: JsValue;
}

impl ErrorConstructor {
    #[getter]
    #[setter]
    extern "js" stackTraceLimit: f64;

    extern "js" fn prepareStackTrace(self, err: JsValue, stackTraces: JsArray<CallSite>) -> JsValue;
    extern "js" fn captureStackTrace(self, targetObject: JsValue, constructorOpt: Option<JsFn>);
}

impl ErrorEvent {
    #[getter]
    extern "js" message: String;
    #[getter]
    extern "js" filename: String;
    #[getter]
    extern "js" lineno: f64;
    #[getter]
    extern "js" colno: f64;
    #[getter]
    extern "js" error: JsValue;
}

impl ErrorEventInit {
    #[getter]
    #[setter]
    extern "js" message: Option<String>;
    #[getter]
    #[setter]
    extern "js" filename: Option<String>;
    #[getter]
    #[setter]
    extern "js" lineno: Option<f64>;
    #[getter]
    #[setter]
    extern "js" colno: Option<f64>;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
}

impl EvaluateOnCallFrameParameterType {
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" throwOnSideEffect: Option<Option<bool>>;
}

impl EvaluateOnCallFrameReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl EvaluateParameterType {
    #[getter]
    #[setter]
    extern "js" expression: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" contextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" userGesture: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
}

impl EvaluateReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl Event {
    #[getter]
    extern "js" bubbles: bool;
    #[getter]
    #[setter]
    extern "js" cancelBubble: bool;
    #[getter]
    extern "js" cancelable: bool;
    #[getter]
    extern "js" composed: bool;
    #[getter]
    extern "js" currentTarget: Option<EventTarget>;
    #[getter]
    extern "js" defaultPrevented: bool;
    #[getter]
    extern "js" eventPhase: f64;
    #[getter]
    extern "js" isTrusted: bool;
    #[getter]
    #[setter]
    extern "js" returnValue: bool;
    #[getter]
    extern "js" srcElement: Option<EventTarget>;
    #[getter]
    extern "js" target: Option<EventTarget>;
    #[getter]
    extern "js" timeStamp: f64;
    #[getter]
    extern "js" type_: String;

    extern "js" fn preventDefault(self);
    extern "js" fn stopPropagation(self);
    extern "js" fn initEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>);
    extern "js" fn stopImmediatePropagation(self);
    extern "js" fn composedPath(self) -> (EventTarget);
}

impl EventEmitter<T> {
    extern "js" fn on(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn once(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn addListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn removeListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn off(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn setMaxListeners(self, n: f64) -> EventEmitter;
    extern "js" fn getMaxListeners(self) -> f64;
    extern "js" fn listenerCount(self, eventName: JsValue, listener: Option<JsValue>) -> f64;
    extern "js" fn prependListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn listeners(self, eventName: JsValue) -> JsArray<JsValue>;
    extern "js" fn prependOnceListener(self, eventName: JsValue, listener: JsValue) -> EventEmitter;
    extern "js" fn removeAllListeners(self, eventName: Option<JsValue>) -> EventEmitter;
    extern "js" fn emit(self, eventName: JsValue, args: JsValue) -> bool;
    extern "js" fn eventNames(self) -> JsArray<JsValue>;
    extern "js" fn rawListeners(self, eventName: JsValue) -> JsArray<JsValue>;
}

impl EventEmitterAsyncResource {
    extern "js" fn emitDestroy(self);
    extern "js" fn new(options: Option<EventEmitterAsyncResourceOptions>) -> EventEmitterAsyncResource;
    // property (readonly)
    extern "js" fn asyncResource(self) -> EventEmitterReferencingAsyncResource;
    // property (readonly)
    extern "js" fn asyncId(self) -> f64;
    // property (readonly)
    extern "js" fn triggerAsyncId(self) -> f64;
}

impl EventEmitterAsyncResourceOptions {
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl EventEmitterOptions {
    #[getter]
    #[setter]
    extern "js" captureRejections: Option<Option<bool>>;
}

impl EventEmitterReferencingAsyncResource {
    #[getter]
    extern "js" eventEmitter: EventEmitterAsyncResource;
}

impl EventInit {
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
    #[getter]
    #[setter]
    extern "js" bubbles: Option<bool>;
    #[getter]
    #[setter]
    extern "js" cancelable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" composed: Option<bool>;
}

impl EventListenerObject {
    extern "js" fn handleEvent(self, object: Event);
}

impl EventListenerOptions {
    #[getter]
    #[setter]
    extern "js" capture: Option<bool>;
    #[getter]
    #[setter]
    extern "js" capture: Option<bool>;
}

impl EventLoopMonitorOptions {
    #[getter]
    #[setter]
    extern "js" resolution: Option<Option<f64>>;
}

impl EventLoopUtilization {
    #[getter]
    #[setter]
    extern "js" idle: f64;
    #[getter]
    #[setter]
    extern "js" active: f64;
    #[getter]
    #[setter]
    extern "js" utilization: f64;
}

impl EventSource {
    #[getter]
    extern "js" CLOSED: f64;
    #[getter]
    extern "js" CONNECTING: f64;
    #[getter]
    extern "js" OPEN: f64;
    #[getter]
    #[setter]
    extern "js" onerror: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onmessage: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onopen: Option<JsFn>;
    #[getter]
    extern "js" readyState: f64;
    #[getter]
    extern "js" url: String;
    #[getter]
    extern "js" withCredentials: bool;

    extern "js" fn close(self);
    // merged from 2 overloads
    extern "js" fn removeEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    // merged from 2 overloads
    extern "js" fn addEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
}

impl EventSourceEventMap {
    #[getter]
    #[setter]
    extern "js" error: ErrorEvent;
    #[getter]
    #[setter]
    extern "js" message: MessageEvent;
    #[getter]
    #[setter]
    extern "js" open: Event;
}

impl EventSourceInit {
    #[getter]
    #[setter]
    extern "js" withCredentials: Option<bool>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" node: Option<JsValue>;
}

impl EventTarget {
    extern "js" fn addEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
    extern "js" fn dispatchEvent(self, event: Event) -> bool;
    extern "js" fn removeEventListener(self, type_: String, listener: JsValue, options: Option<JsValue>);
}

impl ExceptionDetails {
    #[getter]
    #[setter]
    extern "js" exceptionId: f64;
    #[getter]
    #[setter]
    extern "js" text: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
    #[getter]
    #[setter]
    extern "js" scriptId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" exception: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl ExceptionRevokedEventDataType {
    #[getter]
    #[setter]
    extern "js" reason: String;
    #[getter]
    #[setter]
    extern "js" exceptionId: f64;
}

impl ExceptionThrownEventDataType {
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: ExceptionDetails;
}

impl ExecException {
    #[getter]
    #[setter]
    extern "js" cmd: Option<String>;
    #[getter]
    #[setter]
    extern "js" killed: Option<bool>;
    #[getter]
    #[setter]
    extern "js" code: Option<f64>;
    #[getter]
    #[setter]
    extern "js" signal: Option<String>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<String>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<String>;
}

impl ExecFileOptions {
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl ExecFileOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<String>;
}

impl ExecFileOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl ExecFileSyncOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;
}

impl ExecFileSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl ExecFileSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
}

impl ExecOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl ExecOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<String>;
}

impl ExecOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl ExecSyncOptions {
    #[getter]
    #[setter]
    extern "js" shell: Option<Option<String>>;
}

impl ExecSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl ExecSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
}

impl ExecutionContextCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" context: ExecutionContextDescription;
}

impl ExecutionContextDescription {
    #[getter]
    #[setter]
    extern "js" id: f64;
    #[getter]
    #[setter]
    extern "js" origin: String;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" auxData: Option<Option<JsValue>>;
}

impl ExecutionContextDestroyedEventDataType {
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
}

impl Express {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" response: Response;
}

impl FSImplementation {
    // function property
    extern "js" fn open(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
    // function property
    extern "js" fn close(self) -> Option<fn(JsArray<JsValue>) -> JsValue>;
}

impl FSWatcher {
    extern "js" fn unref(self) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    extern "js" fn close(self);
    // merged from 4 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
    extern "js" fn ref(self) -> FSWatcher;
    // merged from 4 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> FSWatcher;
}

impl File {
    // property (readonly)
    extern "js" fn name(self) -> String;
    // property (readonly)
    extern "js" fn lastModified(self) -> f64;
    extern "js" fn new(sources: JsArray<JsValue>, fileName: String, options: Option<FileOptions>) -> File;
}

impl FileChangeInfo<T> {
    #[getter]
    #[setter]
    extern "js" eventType: JsValue;
    #[getter]
    #[setter]
    extern "js" filename: Option<T>;
}

impl FileHandle {
    #[getter]
    extern "js" fd: f64;

    // merged from 3 overloads
    extern "js" fn stat(self, opts: Option<StatOptions>) -> JsPromise<Stats>;
    extern "js" fn sync(self) -> JsPromise<()>;
    extern "js" fn readableWebStream(self, options: Option<ReadableWebStreamOptions>) -> ReadableStream;
    extern "js" fn truncate(self, len: Option<f64>) -> JsPromise<()>;
    // merged from 3 overloads
    extern "js" fn write(self, buffer: JsValue, offset: Option<Option<f64>>, length: Option<Option<f64>>, position: Option<Option<f64>>) -> JsPromise<JsValue>;
    extern "js" fn chmod(self, mode: JsValue) -> JsPromise<()>;
    extern "js" fn chown(self, uid: f64, gid: f64) -> JsPromise<()>;
    extern "js" fn datasync(self) -> JsPromise<()>;
    // merged from 3 overloads
    extern "js" fn read(self, buffer: JsValue, offset: Option<Option<f64>>, length: Option<Option<f64>>, position: Option<Option<JsValue>>) -> JsPromise<JsValue>;
    extern "js" fn readLines(self, options: Option<CreateReadStreamOptions>) -> JsValue;
    extern "js" fn createReadStream(self, options: Option<CreateReadStreamOptions>) -> ReadStream;
    extern "js" fn readv(self, buffers: JsValue, position: Option<f64>) -> JsPromise<JsValue>;
    // merged from 3 overloads
    extern "js" fn readFile(self, options: Option<Option<Abortable>>) -> JsPromise<JsValue>;
    extern "js" fn writeFile(self, data: JsValue, options: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn appendFile(self, data: JsValue, options: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn createWriteStream(self, options: Option<CreateWriteStreamOptions>) -> WriteStream;
    extern "js" fn writev(self, buffers: JsValue, position: Option<f64>) -> JsPromise<JsValue>;
    extern "js" fn utimes(self, atime: JsValue, mtime: JsValue) -> JsPromise<()>;
}

impl FileOptions {
    #[getter]
    #[setter]
    extern "js" endings: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
    #[getter]
    #[setter]
    extern "js" lastModified: Option<f64>;
}

impl FileReadOptions<T> {
    #[getter]
    #[setter]
    extern "js" buffer: Option<T>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl FileReadResult<T> {
    #[getter]
    #[setter]
    extern "js" bytesRead: f64;
    #[getter]
    #[setter]
    extern "js" buffer: T;
}

impl FileUrlToPathOptions {
    #[getter]
    #[setter]
    extern "js" windows: Option<Option<bool>>;
}

impl FilterCallsObjectCriteria {
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hash: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" fullUrl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" host: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hash: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" fullUrl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
}

impl FilterCallsOptions {
    #[getter]
    #[setter]
    extern "js" operator: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" operator: Option<JsValue>;
}

impl FinalizeBindingsOptions {
    #[getter]
    #[setter]
    extern "js" memory: Option<Option<JsValue>>;
}

impl FinishedOptions {
    #[getter]
    #[setter]
    extern "js" cleanup: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" error: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
}

impl FlagAndOpenMode {
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" flag: Option<Option<JsValue>>;
}

impl ForkOptions {
    #[getter]
    #[setter]
    extern "js" execPath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdio: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" windowsVerbatimArguments: Option<Option<bool>>;
}

impl FormData {
    extern "js" fn has(self, name: String) -> bool;
    // property getter
    extern "js" fn keys(self) -> fn() -> SpecIterableIterator<String>;
    // property setter
    extern "js" fn set_forEach(self, value: fn(fn(JsValue, String, FormData) -> (), JsValue) -> ());
    extern "js" fn set(self, name: String, value: JsValue, fileName: Option<String>);
    // property setter
    extern "js" fn set_keys(self, value: fn() -> SpecIterableIterator<String>);
    // property getter
    extern "js" fn values(self) -> fn() -> SpecIterableIterator<JsValue>;
    extern "js" fn getAll(self, name: String) -> JsArray<JsValue>;
    extern "js" fn append(self, name: String, value: JsValue, fileName: Option<String>);
    extern "js" fn get(self, name: String) -> Option<JsValue>;
    // property setter
    extern "js" fn set_entries(self, value: fn() -> SpecIterableIterator<(String, JsValue)>);
    // property getter
    extern "js" fn forEach(self) -> fn(fn(JsValue, String, FormData) -> (), JsValue) -> ();
    // property setter
    extern "js" fn set_values(self, value: fn() -> SpecIterableIterator<JsValue>);
    // property getter
    extern "js" fn entries(self) -> fn() -> SpecIterableIterator<(String, JsValue)>;
    extern "js" fn delete(self, name: String);
}

impl FormatInputPathObject {
    #[getter]
    #[setter]
    extern "js" root: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" dir: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" base: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl FunctionCoverage {
    #[getter]
    #[setter]
    extern "js" functionName: String;
    #[getter]
    #[setter]
    extern "js" ranges: JsArray<CoverageRange>;
    #[getter]
    #[setter]
    extern "js" isBlockCoverage: bool;
}

impl FunctionOptions {
    #[getter]
    #[setter]
    extern "js" deterministic: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" directOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useBigIntArguments: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" varargs: Option<Option<bool>>;
}

impl GCOptions {
    #[getter]
    #[setter]
    extern "js" execution: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" flavor: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" filename: Option<Option<String>>;
}

impl GCProfiler {
    extern "js" fn start(self);
    extern "js" fn stop(self) -> GCProfilerResult;
}

impl GCProfilerResult {
    #[getter]
    #[setter]
    extern "js" version: f64;
    #[getter]
    #[setter]
    extern "js" startTime: f64;
    #[getter]
    #[setter]
    extern "js" endTime: f64;
    #[getter]
    #[setter]
    extern "js" statistics: JsArray<JsValue>;
}

impl GeneratePrimeOptions {
    #[getter]
    #[setter]
    extern "js" add: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" rem: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" safe: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl GeneratePrimeOptionsArrayBuffer {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl GeneratePrimeOptionsBigInt {
    #[getter]
    #[setter]
    extern "js" bigint: bool;
}

impl GetBestEffortCoverageReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<ScriptCoverage>;
}

impl GetCallSitesOptions {
    #[getter]
    #[setter]
    extern "js" sourceMap: Option<Option<bool>>;
}

impl GetCategoriesReturnType {
    #[getter]
    #[setter]
    extern "js" categories: JsArray<String>;
}

impl GetDomainsReturnType {
    #[getter]
    #[setter]
    extern "js" domains: JsArray<Domain>;
}

impl GetHeapObjectIdParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
}

impl GetHeapObjectIdReturnType {
    #[getter]
    #[setter]
    extern "js" heapSnapshotObjectId: String;
}

impl GetObjectByHeapObjectIdParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
}

impl GetObjectByHeapObjectIdReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
}

impl GetPossibleBreakpointsParameterType {
    #[getter]
    #[setter]
    extern "js" start: Location;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" restrictToFunction: Option<Option<bool>>;
}

impl GetPossibleBreakpointsReturnType {
    #[getter]
    #[setter]
    extern "js" locations: JsArray<BreakLocation>;
}

impl GetPropertiesParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
    #[getter]
    #[setter]
    extern "js" ownProperties: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" accessorPropertiesOnly: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
}

impl GetPropertiesReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<PropertyDescriptor>;
    #[getter]
    #[setter]
    extern "js" internalProperties: Option<Option<JsArray<InternalPropertyDescriptor>>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl GetRequestPostDataParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl GetRequestPostDataReturnType {
    #[getter]
    #[setter]
    extern "js" postData: String;
}

impl GetResponseBodyParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl GetResponseBodyReturnType {
    #[getter]
    #[setter]
    extern "js" body: String;
    #[getter]
    #[setter]
    extern "js" base64Encoded: bool;
}

impl GetSamplingProfileReturnType {
    #[getter]
    #[setter]
    extern "js" profile: SamplingHeapProfile;
}

impl GetScriptSourceParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
}

impl GetScriptSourceReturnType {
    #[getter]
    #[setter]
    extern "js" scriptSource: String;
}

impl GetStackTraceParameterType {
    #[getter]
    #[setter]
    extern "js" stackTraceId: StackTraceId;
}

impl GetStackTraceReturnType {
    #[getter]
    #[setter]
    extern "js" stackTrace: StackTrace;
}

impl GlobOptionsWithFileTypes {
    #[getter]
    #[setter]
    extern "js" withFileTypes: bool;
}

impl GlobOptionsWithoutFileTypes {
    #[getter]
    #[setter]
    extern "js" withFileTypes: Option<Option<bool>>;
}

impl GlobalLexicalScopeNamesParameterType {
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
}

impl GlobalLexicalScopeNamesReturnType {
    #[getter]
    #[setter]
    extern "js" names: JsArray<String>;
}

impl H2CClient {
    // property setter
    extern "js" fn set_pipelining(self, value: f64);
    extern "js" fn new(url: JsValue, options: Option<Options>) -> H2CClient;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn closed(self) -> bool;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property getter
    extern "js" fn pipelining(self) -> f64;
    // merged from 2 overloads
    extern "js" fn connect(self, options: JsValue, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
}

impl HRTime {
    extern "js" fn bigint(self) -> i64;
}

impl HTTP2ServerCommon {
    extern "js" fn setTimeout(self, msec: Option<f64>, callback: Option<fn() -> ()>) -> HTTP2ServerCommon;
    extern "js" fn updateSettings(self, settings: Settings);
}

impl HTTPParserError {
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl Hash {
    // merged from 2 overloads
    extern "js" fn digest(self, encoding: Option<String>) -> String;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Hash;
    extern "js" fn new() -> Hash;
    extern "js" fn copy(self, options: Option<HashOptions>) -> Hash;
}

impl HashOptions {
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl Headers {
    // property (readonly)
    extern "js" fn delete(self) -> fn(String) -> ();
    extern "js" fn new(init: Option<JsValue>) -> Headers;
    // property (readonly)
    extern "js" fn has(self) -> fn(String) -> bool;
    // property (readonly)
    extern "js" fn values(self) -> fn() -> SpecIterableIterator<String>;
    // property (readonly)
    extern "js" fn getSetCookie(self) -> fn() -> JsArray<String>;
    // property (readonly)
    extern "js" fn forEach(self) -> fn(fn(String, String, Headers) -> (), JsValue) -> ();
    // property (readonly)
    extern "js" fn keys(self) -> fn() -> SpecIterableIterator<String>;
    // property (readonly)
    extern "js" fn set(self) -> fn(String, String) -> ();
    // property (readonly)
    extern "js" fn entries(self) -> fn() -> SpecIterableIterator<(String, String)>;
    // property (readonly)
    extern "js" fn append(self) -> fn(String, String) -> ();
    // property (readonly)
    extern "js" fn get(self) -> fn(String) -> Option<String>;
}

impl HeadersOverflowError {
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl HeadersTimeoutError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl HeapCodeStatistics {
    #[getter]
    #[setter]
    extern "js" code_and_metadata_size: f64;
    #[getter]
    #[setter]
    extern "js" bytecode_and_metadata_size: f64;
    #[getter]
    #[setter]
    extern "js" external_script_source_size: f64;
}

impl HeapInfo {
    #[getter]
    #[setter]
    extern "js" total_heap_size: f64;
    #[getter]
    #[setter]
    extern "js" total_heap_size_executable: f64;
    #[getter]
    #[setter]
    extern "js" total_physical_size: f64;
    #[getter]
    #[setter]
    extern "js" total_available_size: f64;
    #[getter]
    #[setter]
    extern "js" used_heap_size: f64;
    #[getter]
    #[setter]
    extern "js" heap_size_limit: f64;
    #[getter]
    #[setter]
    extern "js" malloced_memory: f64;
    #[getter]
    #[setter]
    extern "js" peak_malloced_memory: f64;
    #[getter]
    #[setter]
    extern "js" does_zap_garbage: f64;
    #[getter]
    #[setter]
    extern "js" number_of_native_contexts: f64;
    #[getter]
    #[setter]
    extern "js" number_of_detached_contexts: f64;
    #[getter]
    #[setter]
    extern "js" total_global_handles_size: f64;
    #[getter]
    #[setter]
    extern "js" used_global_handles_size: f64;
    #[getter]
    #[setter]
    extern "js" external_memory: f64;
}

impl HeapProfileHandle {
    extern "js" fn stop(self) -> JsPromise<String>;
}

impl HeapSnapshotOptions {
    #[getter]
    #[setter]
    extern "js" exposeInternals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exposeNumericValues: Option<Option<bool>>;
}

impl HeapSpaceInfo {
    #[getter]
    #[setter]
    extern "js" space_name: String;
    #[getter]
    #[setter]
    extern "js" space_size: f64;
    #[getter]
    #[setter]
    extern "js" space_used_size: f64;
    #[getter]
    #[setter]
    extern "js" space_available_size: f64;
    #[getter]
    #[setter]
    extern "js" physical_space_size: f64;
}

impl HeapSpaceStatistics {
    #[getter]
    #[setter]
    extern "js" spaceName: String;
    #[getter]
    #[setter]
    extern "js" spaceSize: f64;
    #[getter]
    #[setter]
    extern "js" spaceUsedSize: f64;
    #[getter]
    #[setter]
    extern "js" spaceAvailableSize: f64;
    #[getter]
    #[setter]
    extern "js" physicalSpaceSize: f64;
}

impl HeapStatistics {
    #[getter]
    #[setter]
    extern "js" totalHeapSize: f64;
    #[getter]
    #[setter]
    extern "js" totalHeapSizeExecutable: f64;
    #[getter]
    #[setter]
    extern "js" totalPhysicalSize: f64;
    #[getter]
    #[setter]
    extern "js" totalAvailableSize: f64;
    #[getter]
    #[setter]
    extern "js" totalGlobalHandlesSize: f64;
    #[getter]
    #[setter]
    extern "js" usedGlobalHandlesSize: f64;
    #[getter]
    #[setter]
    extern "js" usedHeapSize: f64;
    #[getter]
    #[setter]
    extern "js" heapSizeLimit: f64;
    #[getter]
    #[setter]
    extern "js" mallocedMemory: f64;
    #[getter]
    #[setter]
    extern "js" externalMemory: f64;
    #[getter]
    #[setter]
    extern "js" peakMallocedMemory: f64;
}

impl HeapStatsUpdateEventDataType {
    #[getter]
    #[setter]
    extern "js" statsUpdate: JsArray<f64>;
}

impl Histogram {
    #[getter]
    extern "js" count: f64;
    #[getter]
    extern "js" countBigInt: i64;
    #[getter]
    extern "js" exceeds: f64;
    #[getter]
    extern "js" exceedsBigInt: i64;
    #[getter]
    extern "js" max: f64;
    #[getter]
    extern "js" maxBigInt: f64;
    #[getter]
    extern "js" mean: f64;
    #[getter]
    extern "js" min: f64;
    #[getter]
    extern "js" minBigInt: i64;
    #[getter]
    extern "js" percentiles: JsValue;
    #[getter]
    extern "js" percentilesBigInt: JsValue;
    #[getter]
    extern "js" stddev: f64;

    extern "js" fn percentile(self, percentile: f64) -> f64;
    extern "js" fn percentileBigInt(self, percentile: f64) -> i64;
    extern "js" fn reset(self);
}

impl HkdfParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" info: JsValue;
    #[getter]
    #[setter]
    extern "js" salt: JsValue;
}

impl Hmac {
    extern "js" fn new() -> Hmac;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Hmac;
    // merged from 2 overloads
    extern "js" fn digest(self, encoding: Option<String>) -> String;
}

impl HmacImportParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
}

impl HmacKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" hash: KeyAlgorithm;
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl HmacKeyGenParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
}

impl HookCallbacks {
    #[getter]
    #[setter]
    extern "js" init: Option<Init>;
    #[getter]
    #[setter]
    extern "js" before: Option<Before>;
    #[getter]
    #[setter]
    extern "js" after: Option<After>;
    #[getter]
    #[setter]
    extern "js" settled: Option<Settled>;

    extern "js" fn promiseResolve(self, asyncId: f64);
    extern "js" fn before(self, asyncId: f64);
    extern "js" fn after(self, asyncId: f64);
    extern "js" fn init(self, asyncId: f64, type_: String, triggerAsyncId: f64, resource: JsValue);
    extern "js" fn destroy(self, asyncId: f64);
}

impl HookOptions {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response> {
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, stream: Option<ServerHttp2Stream>, headers: Option<IncomingHttpHeaders>, flags: Option<f64>) -> bool;
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2SecureServer;
}

impl Http2Server<Http1Request, Http1Response, Http2Request, Http2Response> {
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, stream: Option<ServerHttp2Stream>, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsValue, JsValue) -> ()) -> Http2Server;
}

impl Http2ServerRequest {
    // property (readonly)
    extern "js" fn rawHeaders(self) -> JsArray<String>;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn socket(self) -> JsValue;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // property (readonly)
    extern "js" fn stream(self) -> ServerHttp2Stream;
    // property (readonly)
    extern "js" fn headers(self) -> IncomingHttpHeaders;
    // property (readonly)
    extern "js" fn rawTrailers(self) -> JsArray<String>;
    extern "js" fn new(stream: ServerHttp2Stream, headers: IncomingHttpHeaders, options: ReadableOptions, rawHeaders: JsArray<String>) -> Http2ServerRequest;
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    // property (readonly)
    extern "js" fn authority(self) -> String;
    // property (readonly)
    extern "js" fn complete(self) -> bool;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, hadError: Option<bool>, code: Option<f64>) -> bool;
    // property (readonly)
    extern "js" fn connection(self) -> JsValue;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn httpVersionMinor(self) -> f64;
    // property (readonly)
    extern "js" fn httpVersion(self) -> String;
    // property (readonly)
    extern "js" fn httpVersionMajor(self) -> f64;
    // property (readonly)
    extern "js" fn scheme(self) -> String;
    // property (readonly)
    extern "js" fn trailers(self) -> IncomingHttpHeaders;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(bool, f64) -> ()) -> Http2ServerRequest;
    // property (readonly)
    extern "js" fn method(self) -> String;
    // property getter
    extern "js" fn url(self) -> String;
    // property (readonly)
    extern "js" fn aborted(self) -> bool;
    // property setter
    extern "js" fn set_url(self, value: String);
}

impl Http2ServerResponse<Request> {
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    extern "js" fn writeContinue(self);
    extern "js" fn addTrailers(self, trailers: OutgoingHttpHeaders);
    // merged from 2 overloads
    extern "js" fn writeHead(self, statusCode: f64, statusMessage: String, headers: Option<JsValue>) -> Http2ServerResponse;
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    extern "js" fn new<Request>(stream: ServerHttp2Stream) -> Http2ServerResponse;
    // property getter
    extern "js" fn sendDate(self) -> bool;
    // property (readonly)
    extern "js" fn finished(self) -> bool;
    // property setter
    extern "js" fn set_statusMessage(self, value: String);
    extern "js" fn hasHeader(self, name: String) -> bool;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2ServerResponse;
    // merged from 3 overloads
    extern "js" fn end(self, data: JsValue, encoding: Option<JsValue>, callback: Option<fn() -> ()>) -> Http2ServerResponse;
    // property (readonly)
    extern "js" fn req(self) -> Request;
    extern "js" fn writeEarlyHints(self, hints: JsValue);
    extern "js" fn getHeader(self, name: String) -> String;
    extern "js" fn getHeaders(self) -> OutgoingHttpHeaders;
    // property (readonly)
    extern "js" fn socket(self) -> JsValue;
    extern "js" fn setHeader(self, name: String, value: JsValue);
    // merged from 2 overloads
    extern "js" fn write(self, chunk: JsValue, encoding: JsValue, callback: Option<fn(JsValue) -> ()>) -> bool;
    // property (readonly)
    extern "js" fn stream(self) -> ServerHttp2Stream;
    // property (readonly)
    extern "js" fn connection(self) -> JsValue;
    // property (readonly)
    extern "js" fn headersSent(self) -> bool;
    extern "js" fn removeHeader(self, name: String);
    // property getter
    extern "js" fn statusCode(self) -> f64;
    extern "js" fn appendHeader(self, name: String, value: JsValue);
    extern "js" fn getHeaderNames(self) -> JsArray<String>;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    // property setter
    extern "js" fn set_sendDate(self, value: bool);
    // property getter
    extern "js" fn statusMessage(self) -> String;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, error: Option<JsValue>) -> bool;
    extern "js" fn createPushResponse(self, headers: OutgoingHttpHeaders, callback: fn(Option<JsValue>, Http2ServerResponse) -> ());
}

impl Http2Session {
    #[getter]
    extern "js" alpnProtocol: Option<Option<String>>;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" connecting: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" encrypted: Option<Option<bool>>;
    #[getter]
    extern "js" localSettings: Settings;
    #[getter]
    extern "js" originSet: Option<Option<JsArray<String>>>;
    #[getter]
    extern "js" pendingSettingsAck: bool;
    #[getter]
    extern "js" remoteSettings: Settings;
    #[getter]
    extern "js" socket: JsValue;
    #[getter]
    extern "js" state: SessionState;
    #[getter]
    extern "js" type_: f64;

    // merged from 9 overloads
    extern "js" fn emit(self, event: String, frameType: Option<f64>, errorCode: Option<f64>, streamID: Option<f64>) -> bool;
    extern "js" fn destroy(self, error: Option<JsValue>, code: Option<f64>);
    // merged from 2 overloads
    extern "js" fn ping(self, payload: JsValue, callback: Option<fn(Option<JsValue>, f64, JsValue) -> ()>) -> bool;
    extern "js" fn ref(self);
    extern "js" fn unref(self);
    // merged from 9 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2Session;
    // merged from 9 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn close(self, callback: Option<fn() -> ()>);
    extern "js" fn goaway(self, code: Option<f64>, lastStreamID: Option<f64>, opaqueData: Option<JsValue>);
    // merged from 9 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    extern "js" fn setLocalWindowSize(self, windowSize: f64);
    // merged from 9 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    // merged from 9 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2Session;
    extern "js" fn settings(self, settings: Settings, callback: Option<fn(Option<JsValue>, Settings, f64) -> ()>);
}

impl Http2Stream {
    #[getter]
    extern "js" aborted: bool;
    #[getter]
    extern "js" bufferSize: f64;
    #[getter]
    extern "js" closed: bool;
    #[getter]
    extern "js" destroyed: bool;
    #[getter]
    extern "js" endAfterHeaders: bool;
    #[getter]
    extern "js" id: Option<Option<f64>>;
    #[getter]
    extern "js" pending: bool;
    #[getter]
    extern "js" rstCode: f64;
    #[getter]
    extern "js" sentHeaders: OutgoingHttpHeaders;
    #[getter]
    extern "js" sentInfoHeaders: Option<Option<JsArray<OutgoingHttpHeaders>>>;
    #[getter]
    extern "js" sentTrailers: Option<Option<OutgoingHttpHeaders>>;
    #[getter]
    extern "js" session: Option<Http2Session>;
    #[getter]
    extern "js" state: StreamState;

    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Http2Stream;
    extern "js" fn close(self, code: Option<f64>, callback: Option<fn() -> ()>);
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Http2Stream;
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>);
    extern "js" fn priority(self, options: JsValue);
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // merged from 15 overloads
    extern "js" fn emit(self, event: String, frameType: Option<f64>, errorCode: Option<f64>) -> bool;
    extern "js" fn sendTrailers(self, headers: OutgoingHttpHeaders);
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Http2Stream;
}

impl ILayer {
    #[getter]
    #[setter]
    extern "js" route: Option<IRoute>;
    #[getter]
    #[setter]
    extern "js" name: JsValue;
    #[getter]
    #[setter]
    extern "js" params: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" keys: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" regexp: JsValue;

    // function property
    extern "js" fn handle(self) -> fn(Request, Response, NextFunction) -> JsValue;
}

impl IRoute<Route> {
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" stack: JsArray<ILayer>;
    #[getter]
    #[setter]
    extern "js" all: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" get: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" post: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" put: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" delete: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" patch: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" options: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" head: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" checkout: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" copy: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" lock: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" merge: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" mkactivity: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" mkcol: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" move: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" m-search: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" notify: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" purge: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" report: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" search: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" subscribe: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" trace: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" unlock: IRouterHandler<IRoute, Route>;
    #[getter]
    #[setter]
    extern "js" unsubscribe: IRouterHandler<IRoute, Route>;
}

impl IRouter {
    #[getter]
    #[setter]
    extern "js" all: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" get: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" post: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" put: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" delete: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" patch: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" options: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" head: IRouterMatcher<IRouter, String>;
    #[getter]
    #[setter]
    extern "js" checkout: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" connect: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" copy: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" lock: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" merge: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" mkactivity: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" mkcol: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" move: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" m-search: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" notify: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" propfind: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" proppatch: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" purge: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" report: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" search: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" subscribe: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" trace: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" unlock: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" unsubscribe: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" link: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" unlink: IRouterMatcher<IRouter>;
    #[getter]
    #[setter]
    extern "js" use_: IRouterHandler<IRouter>;
    #[getter]
    #[setter]
    extern "js" stack: JsArray<ILayer>;

    // merged from 2 overloads
    extern "js" fn param(self, name: String, handler: Option<RequestParamHandler>) -> IRouter;
    // merged from 2 overloads
    extern "js" fn route(self, prefix: JsValue) -> JsValue;
}

impl Immediate {
    extern "js" fn _onImmediate(self, args: JsArray<JsValue>);
    extern "js" fn unref(self) -> Immediate;
    extern "js" fn ref(self) -> Immediate;
    extern "js" fn hasRef(self) -> bool;
}

impl ImportAttributes {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl ImportMeta {
    #[getter]
    #[setter]
    extern "js" dirname: String;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" main: bool;

    extern "js" fn resolve(self, specifier: String, parent: Option<JsValue>) -> String;
}

impl IncomingHttpHeaders {
    #[getter]
    #[setter]
    extern "js" :path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" :method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" :authority: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" :scheme: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept-encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept-language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept-patch: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" accept-ranges: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-credentials: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-methods: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-expose-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-max-age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-request-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-request-method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" allow: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" alt-svc: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cache-control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" connection: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-disposition: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-length: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-type: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cookie: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" date: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" etag: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expect: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expires: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" forwarded: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" from: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-modified-since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-none-match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-unmodified-since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" last-modified: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pragma: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" proxy-authenticate: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" proxy-authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public-key-pins: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" retry-after: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-fetch-site: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-fetch-mode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-fetch-user: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-fetch-dest: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-extensions: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-key: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-version: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" set-cookie: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" strict-transport-security: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" tk: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" trailer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" transfer-encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" user-agent: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" vary: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" via: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" warning: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" www-authenticate: Option<Option<String>>;
}

impl IncomingHttpStatusHeader {
    #[getter]
    #[setter]
    extern "js" :status: Option<Option<f64>>;
}

impl IncomingMessage {
    // property getter
    extern "js" fn socket(self) -> Socket;
    // property getter
    extern "js" fn rawHeaders(self) -> JsArray<String>;
    // property getter
    extern "js" fn statusCode(self) -> Option<Option<f64>>;
    // property setter
    extern "js" fn set_httpVersion(self, value: String);
    // property setter
    extern "js" fn set_rawHeaders(self, value: JsArray<String>);
    // property getter
    extern "js" fn trailers(self) -> Dict<String>;
    // property setter
    extern "js" fn set_socket(self, value: Socket);
    // property setter
    extern "js" fn set_headersDistinct(self, value: Dict<JsArray<String>>);
    // property getter
    extern "js" fn httpVersion(self) -> String;
    // property setter
    extern "js" fn set_httpVersionMajor(self, value: f64);
    // property getter
    extern "js" fn headers(self) -> IncomingHttpHeaders;
    // property setter
    extern "js" fn set_rawTrailers(self, value: JsArray<String>);
    // property setter
    extern "js" fn set_statusCode(self, value: Option<Option<f64>>);
    // property getter
    extern "js" fn headersDistinct(self) -> Dict<JsArray<String>>;
    // property getter
    extern "js" fn statusMessage(self) -> Option<Option<String>>;
    // property getter
    extern "js" fn trailersDistinct(self) -> Dict<JsArray<String>>;
    // property getter
    extern "js" fn method(self) -> Option<Option<String>>;
    // property setter
    extern "js" fn set_statusMessage(self, value: Option<Option<String>>);
    // property setter
    extern "js" fn set_httpVersionMinor(self, value: f64);
    extern "js" fn destroy(self, error: Option<JsValue>) -> IncomingMessage;
    // property setter
    extern "js" fn set_url(self, value: Option<Option<String>>);
    // property setter
    extern "js" fn set_connection(self, value: Socket);
    // property getter
    extern "js" fn httpVersionMinor(self) -> f64;
    // property setter
    extern "js" fn set_complete(self, value: bool);
    // property getter
    extern "js" fn aborted(self) -> bool;
    // property getter
    extern "js" fn connection(self) -> Socket;
    // property setter
    extern "js" fn set_trailers(self, value: Dict<String>);
    // property getter
    extern "js" fn complete(self) -> bool;
    // property getter
    extern "js" fn rawTrailers(self) -> JsArray<String>;
    // property setter
    extern "js" fn set_aborted(self, value: bool);
    // property getter
    extern "js" fn url(self) -> Option<Option<String>>;
    extern "js" fn new(socket: Socket) -> IncomingMessage;
    // property getter
    extern "js" fn httpVersionMajor(self) -> f64;
    // property setter
    extern "js" fn set_trailersDistinct(self, value: Dict<JsArray<String>>);
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>) -> IncomingMessage;
    // property setter
    extern "js" fn set_headers(self, value: IncomingHttpHeaders);
    // property setter
    extern "js" fn set_method(self, value: Option<Option<String>>);
}

impl InformationEvent {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusMessage: String;
    #[getter]
    #[setter]
    extern "js" httpVersion: String;
    #[getter]
    #[setter]
    extern "js" httpVersionMajor: f64;
    #[getter]
    #[setter]
    extern "js" httpVersionMinor: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" rawHeaders: JsArray<String>;
}

impl InformationalError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl Initiator {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" stack: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lineNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" requestId: Option<Option<String>>;
}

impl InspectOptions {
    #[getter]
    #[setter]
    extern "js" showHidden: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" depth: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" colors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" customInspect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" showProxy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxArrayLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxStringLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" compact: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sorted: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" getters: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" numericSeparator: Option<Option<bool>>;
}

impl InspectOptionsStylized {
    extern "js" fn stylize(self, text: String, styleType: String) -> String;
}

impl InspectRequestedEventDataType {
    #[getter]
    #[setter]
    extern "js" object: RemoteObject;
    #[getter]
    #[setter]
    extern "js" hints: JsValue;
}

impl InspectorConsole {
    extern "js" fn timeStamp(self, label: Option<JsValue>);
    extern "js" fn warn(self, data: JsArray<JsValue>);
    extern "js" fn clear(self, data: JsArray<JsValue>);
    extern "js" fn dir(self, data: JsArray<JsValue>);
    extern "js" fn trace(self, data: JsArray<JsValue>);
    extern "js" fn groupEnd(self, data: JsArray<JsValue>);
    extern "js" fn timeLog(self, label: Option<JsValue>);
    extern "js" fn profileEnd(self, label: Option<JsValue>);
    extern "js" fn info(self, data: JsArray<JsValue>);
    extern "js" fn time(self, label: Option<JsValue>);
    extern "js" fn countReset(self, label: Option<JsValue>);
    extern "js" fn count(self, label: Option<JsValue>);
    extern "js" fn dirxml(self, data: JsArray<JsValue>);
    extern "js" fn assert(self, value: Option<JsValue>, data: JsArray<JsValue>);
    extern "js" fn log(self, data: JsArray<JsValue>);
    extern "js" fn debug(self, data: JsArray<JsValue>);
    extern "js" fn group(self, data: JsArray<JsValue>);
    extern "js" fn profile(self, label: Option<JsValue>);
    extern "js" fn groupCollapsed(self, data: JsArray<JsValue>);
    extern "js" fn error(self, data: JsArray<JsValue>);
    extern "js" fn table(self, data: JsArray<JsValue>);
}

impl InspectorNotification<T> {
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" params: T;
}

impl Interceptable {
    extern "js" fn cleanMocks(self);
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
}

impl Interface {
    extern "js" fn getPrompt(self) -> String;
    // merged from 9 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    // merged from 9 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // merged from 9 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    extern "js" fn prompt(self, preserveCursor: Option<bool>);
    // property (readonly)
    extern "js" fn line(self) -> String;
    extern "js" fn getCursorPos(self) -> CursorPos;
    extern "js" fn resume(self) -> Interface;
    // merged from 9 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    extern "js" fn pause(self) -> Interface;
    // property (readonly)
    extern "js" fn terminal(self) -> bool;
    // merged from 2 overloads
    extern "js" fn new(input: ReadableStream, output: Option<WritableStream>, completer: Option<JsValue>, terminal: Option<bool>) -> Interface;
    // merged from 2 overloads
    extern "js" fn question(self, query: String, options: Abortable, callback: Option<fn(String) -> ()>);
    extern "js" fn setPrompt(self, prompt: String);
    extern "js" fn close(self);
    // merged from 2 overloads
    extern "js" fn write(self, data: JsValue, key: Option<Key>);
    // merged from 9 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // merged from 9 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Interface;
    // property (readonly)
    extern "js" fn cursor(self) -> f64;
}

impl InternalPropertyDescriptor {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<RemoteObject>>;
}

impl IntervalHistogram {
    extern "js" fn enable(self) -> bool;
    extern "js" fn disable(self) -> bool;
}

impl InvalidArgumentError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl InvalidReturnValueError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl IpcNetConnectOpts {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl IpcSocketConnectOpts {
    #[getter]
    #[setter]
    extern "js" path: String;
}

impl IsDeepStrictEqualOptions {
    #[getter]
    #[setter]
    extern "js" skipPrototype: Option<Option<bool>>;
}

impl JsonWebKey {
    #[getter]
    #[setter]
    extern "js" crv: Option<String>;
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" dp: Option<String>;
    #[getter]
    #[setter]
    extern "js" dq: Option<String>;
    #[getter]
    #[setter]
    extern "js" e: Option<String>;
    #[getter]
    #[setter]
    extern "js" k: Option<String>;
    #[getter]
    #[setter]
    extern "js" kty: Option<String>;
    #[getter]
    #[setter]
    extern "js" n: Option<String>;
    #[getter]
    #[setter]
    extern "js" p: Option<String>;
    #[getter]
    #[setter]
    extern "js" q: Option<String>;
    #[getter]
    #[setter]
    extern "js" qi: Option<String>;
    #[getter]
    #[setter]
    extern "js" x: Option<String>;
    #[getter]
    #[setter]
    extern "js" y: Option<String>;
    #[getter]
    #[setter]
    extern "js" alg: Option<String>;
    #[getter]
    #[setter]
    extern "js" crv: Option<String>;
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" dp: Option<String>;
    #[getter]
    #[setter]
    extern "js" dq: Option<String>;
    #[getter]
    #[setter]
    extern "js" e: Option<String>;
    #[getter]
    #[setter]
    extern "js" ext: Option<bool>;
    #[getter]
    #[setter]
    extern "js" k: Option<String>;
    #[getter]
    #[setter]
    extern "js" key_ops: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" kty: Option<String>;
    #[getter]
    #[setter]
    extern "js" n: Option<String>;
    #[getter]
    #[setter]
    extern "js" oth: Option<JsArray<RsaOtherPrimesInfo>>;
    #[getter]
    #[setter]
    extern "js" p: Option<String>;
    #[getter]
    #[setter]
    extern "js" q: Option<String>;
    #[getter]
    #[setter]
    extern "js" qi: Option<String>;
    #[getter]
    #[setter]
    extern "js" use_: Option<String>;
    #[getter]
    #[setter]
    extern "js" x: Option<String>;
    #[getter]
    #[setter]
    extern "js" y: Option<String>;
}

impl JsonWebKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsonWebKey;
    #[getter]
    #[setter]
    extern "js" format: String;
}

impl JwkKeyExportOptions {
    #[getter]
    #[setter]
    extern "js" format: String;
}

impl Key {
    #[getter]
    #[setter]
    extern "js" sequence: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ctrl: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" meta: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shift: Option<Option<bool>>;
}

impl KeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl KeyExportOptions<T> {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" format: T;
    #[getter]
    #[setter]
    extern "js" cipher: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<JsValue>;
}

impl KeyObject {
    #[getter]
    #[setter]
    extern "js" pem: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;

    extern "js" fn new() -> KeyObject;
    // property setter
    extern "js" fn set_asymmetricKeyDetails(self, value: Option<AsymmetricKeyDetails>);
    extern "js" fn from(key: CryptoKey) -> KeyObject;
    // merged from 3 overloads
    extern "js" fn export_(self, options: KeyExportOptions<String>) -> JsValue;
    extern "js" fn toCryptoKey(self, algorithm: JsValue, extractable: bool, keyUsages: JsArray<JsValue>) -> CryptoKey;
    // property getter
    extern "js" fn symmetricKeySize(self) -> Option<f64>;
    // property getter
    extern "js" fn asymmetricKeyDetails(self) -> Option<AsymmetricKeyDetails>;
    // property getter
    extern "js" fn asymmetricKeyType(self) -> Option<JsValue>;
    // property getter
    extern "js" fn type_(self) -> String;
    extern "js" fn equals(self, otherKeyObject: KeyObject) -> bool;
    // property setter
    extern "js" fn set_type_(self, value: String);
    // property setter
    extern "js" fn set_symmetricKeySize(self, value: Option<f64>);
    // property setter
    extern "js" fn set_asymmetricKeyType(self, value: Option<JsValue>);
}

impl KeyPairKeyObjectResult {
    #[getter]
    #[setter]
    extern "js" publicKey: KeyObject;
    #[getter]
    #[setter]
    extern "js" privateKey: KeyObject;
}

impl KeyPairSyncResult<T1, T2> {
    #[getter]
    #[setter]
    extern "js" publicKey: T1;
    #[getter]
    #[setter]
    extern "js" privateKey: T2;
}

impl KmacImportParams {
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
}

impl KmacKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl KmacKeyGenParams {
    #[getter]
    #[setter]
    extern "js" length: Option<f64>;
}

impl KmacParams {
    #[getter]
    #[setter]
    extern "js" customization: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" length: f64;
}

impl LastSeenObjectIdEventDataType {
    #[getter]
    #[setter]
    extern "js" lastSeenObjectId: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl LcovReporter {
    extern "js" fn new(opts: Option<JsValue>) -> LcovReporter;
}

impl ListenOptions {
    #[getter]
    #[setter]
    extern "js" backlog: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" exclusive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ipv6Only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" reusePort: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" path: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" readableAll: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writableAll: Option<Option<bool>>;
}

impl LoadFnOutput {
    #[getter]
    #[setter]
    extern "js" format: Option<String>;
    #[getter]
    #[setter]
    extern "js" shortCircuit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" source: Option<Option<JsValue>>;
}

impl LoadHookContext {
    #[getter]
    #[setter]
    extern "js" conditions: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" format: Option<String>;
    #[getter]
    #[setter]
    extern "js" importAttributes: ImportAttributes;
}

impl LoadNetworkResourcePageResult {
    #[getter]
    #[setter]
    extern "js" success: bool;
    #[getter]
    #[setter]
    extern "js" stream: Option<Option<JsValue>>;
}

impl LoadNetworkResourceParameterType {
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl LoadNetworkResourceReturnType {
    #[getter]
    #[setter]
    extern "js" resource: LoadNetworkResourcePageResult;
}

impl LoadingFailedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" errorText: String;
}

impl LoadingFinishedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl Location {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
}

impl LocationInfo {
    #[getter]
    #[setter]
    extern "js" column: Option<f64>;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" line: Option<f64>;
}

impl Lock {
    #[getter]
    extern "js" mode: JsValue;
    #[getter]
    extern "js" name: String;
}

impl LockInfo {
    #[getter]
    #[setter]
    extern "js" clientId: String;
    #[getter]
    #[setter]
    extern "js" mode: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl LockManager {
    // merged from 2 overloads
    extern "js" fn request(self, name: String, options: LockOptions, callback: Option<JsValue>) -> JsPromise<JsValue>;
    extern "js" fn query(self) -> JsPromise<LockManagerSnapshot>;
}

impl LockManagerSnapshot {
    #[getter]
    #[setter]
    extern "js" held: JsArray<LockInfo>;
    #[getter]
    #[setter]
    extern "js" pending: JsArray<LockInfo>;
}

impl LockOptions {
    #[getter]
    #[setter]
    extern "js" ifAvailable: Option<bool>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" steal: Option<bool>;
}

impl LookupAddress {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: f64;
}

impl LookupAllOptions {
    #[getter]
    #[setter]
    extern "js" all: bool;
}

impl LookupOneOptions {
    #[getter]
    #[setter]
    extern "js" all: Option<Option<bool>>;
}

impl LookupOptions {
    #[getter]
    #[setter]
    extern "js" family: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" all: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" order: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" verbatim: Option<Option<bool>>;
}

impl MIMEParams {
    extern "js" fn values(self) -> Iterator<String>;
    extern "js" fn entries(self) -> Iterator<(String, String)>;
    extern "js" fn get(self, name: String) -> Option<String>;
    extern "js" fn delete(self, name: String);
    extern "js" fn has(self, name: String) -> bool;
    extern "js" fn keys(self) -> Iterator<String>;
    extern "js" fn set(self, name: String, value: String);
}

impl MIMEType {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: String;
    #[getter]
    #[setter]
    extern "js" parameters: JsValue;
    #[getter]
    #[setter]
    extern "js" essence: String;

    // property getter
    extern "js" fn type_(self) -> String;
    // property setter
    extern "js" fn set_type_(self, value: String);
    // property getter
    extern "js" fn subtype(self) -> String;
    extern "js" fn new(input: JsValue) -> MIMEType;
    // property setter
    extern "js" fn set_subtype(self, value: String);
    extern "js" fn toString(self) -> String;
    // property (readonly)
    extern "js" fn essence(self) -> String;
    // property (readonly)
    extern "js" fn params(self) -> MIMEParams;
}

impl MLDSAKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl MLKEMKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl MakeDirectoryOptions {
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<JsValue>>;
}

impl MarkOptions {
    #[getter]
    #[setter]
    extern "js" detail: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" startTime: Option<Option<f64>>;
}

impl MaxOriginsReachedError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
}

impl MeasureMemoryOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" execution: Option<JsValue>;
}

impl MeasureOptions {
    #[getter]
    #[setter]
    extern "js" detail: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" duration: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" end: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" start: Option<JsValue>;
}

impl MediaType {
    #[getter]
    #[setter]
    extern "js" value: String;
    #[getter]
    #[setter]
    extern "js" quality: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: String;
}

impl MemoryCacheStore {
    extern "js" fn get(self, key: CacheKey) -> JsValue;
    extern "js" fn createWriteStream(self, key: CacheKey, value: CacheValue) -> Option<Writable>;
    extern "js" fn new(opts: Option<MemoryCacheStoreOpts>) -> MemoryCacheStore;
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
}

impl MemoryCacheStoreOpts {
    #[getter]
    #[setter]
    extern "js" maxCount: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxEntrySize: Option<f64>;

    // function property
    extern "js" fn errorCallback(self) -> Option<fn(JsValue) -> ()>;
}

impl MemoryMeasurement {
    #[getter]
    #[setter]
    extern "js" total: JsValue;
}

impl MemoryUsage {
    #[getter]
    #[setter]
    extern "js" rss: f64;
    #[getter]
    #[setter]
    extern "js" heapTotal: f64;
    #[getter]
    #[setter]
    extern "js" heapUsed: f64;
    #[getter]
    #[setter]
    extern "js" external: f64;
    #[getter]
    #[setter]
    extern "js" arrayBuffers: f64;
}

impl MemoryUsageFn {
    extern "js" fn rss(self) -> f64;
}

impl MessageAddedEventDataType {
    #[getter]
    #[setter]
    extern "js" message: ConsoleMessage;
}

impl MessageChannel {
    // property (readonly)
    extern "js" fn port1(self) -> MessagePort;
    // property (readonly)
    extern "js" fn port2(self) -> MessagePort;
}

impl MessageEvent<T> {
    #[getter]
    extern "js" data: T;
    #[getter]
    extern "js" lastEventId: String;
    #[getter]
    extern "js" origin: String;
    #[getter]
    extern "js" ports: JsArray<JsValue>;
    #[getter]
    extern "js" source: Option<JsValue>;

    extern "js" fn initMessageEvent(self, type_: String, bubbles: Option<bool>, cancelable: Option<bool>, data: Option<JsValue>, origin: Option<String>, lastEventId: Option<String>, source: Option<Option<JsValue>>, ports: Option<JsArray<JsValue>>);
}

impl MessageEventInit<T> {
    #[getter]
    #[setter]
    extern "js" data: Option<T>;
    #[getter]
    #[setter]
    extern "js" lastEventId: Option<String>;
    #[getter]
    #[setter]
    extern "js" origin: Option<String>;
    #[getter]
    #[setter]
    extern "js" ports: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" source: Option<Option<JsValue>>;
}

impl MessageOptions {
    #[getter]
    #[setter]
    extern "js" keepOpen: Option<Option<bool>>;
}

impl MessagePort {
    // merged from 4 overloads
    extern "js" fn removeListener(self, event: String, listener: fn(Event) -> (), options: Option<EventListenerOptions>) -> MessagePort;
    extern "js" fn start(self);
    // merged from 4 overloads
    extern "js" fn off(self, event: String, listener: fn(Event) -> (), options: Option<EventListenerOptions>) -> MessagePort;
    // merged from 4 overloads
    extern "js" fn on(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
    extern "js" fn ref(self);
    // merged from 4 overloads
    extern "js" fn emit(self, event: String, ev: Event) -> bool;
    extern "js" fn hasRef(self) -> bool;
    // merged from 4 overloads
    extern "js" fn once(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
    extern "js" fn unref(self);
    extern "js" fn close(self);
    extern "js" fn postMessage(self, value: JsValue, transferList: Option<JsArray<JsValue>>);
    // merged from 4 overloads
    extern "js" fn addListener(self, event: String, listener: fn(Event) -> ()) -> MessagePort;
}

impl MessagingOptions {
    #[getter]
    #[setter]
    extern "js" serialization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" killSignal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl MockAgent<TMockAgentOptions> {
    extern "js" fn new<TMockAgentOptions>(options: Option<TMockAgentOptions>) -> MockAgent;
    extern "js" fn activate(self);
    extern "js" fn getCallHistory(self) -> Option<MockCallHistory>;
    // merged from 4 overloads
    extern "js" fn enableNetConnect(self, host: Option<String>);
    extern "js" fn enableCallHistory(self) -> MockAgent;
    extern "js" fn disableCallHistory(self) -> MockAgent;
    extern "js" fn pendingInterceptors(self) -> JsArray<PendingInterceptor>;
    // merged from 3 overloads
    extern "js" fn get(self, origin: String) -> TInterceptable;
    extern "js" fn clearCallHistory(self);
    extern "js" fn assertNoPendingInterceptors(self, options: Option<JsValue>);
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn deactivate(self);
    extern "js" fn disableNetConnect(self);
}

impl MockCallHistory {
    extern "js" fn filterCallsByOrigin(self, origin: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByProtocol(self, protocol: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByFullUrl(self, fullUrl: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCalls(self, criteria: JsValue, options: Option<FilterCallsOptions>) -> JsArray<MockCallHistoryLog>;
    extern "js" fn calls(self) -> JsArray<MockCallHistoryLog>;
    extern "js" fn firstCall(self) -> Option<MockCallHistoryLog>;
    extern "js" fn nthCall(self, position: f64) -> Option<MockCallHistoryLog>;
    extern "js" fn filterCallsByPort(self, port: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn lastCall(self) -> Option<MockCallHistoryLog>;
    extern "js" fn filterCallsByHost(self, host: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByPath(self, path: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn filterCallsByMethod(self, method: JsValue) -> JsArray<MockCallHistoryLog>;
    extern "js" fn clear(self);
    extern "js" fn new(name: String) -> MockCallHistory;
    extern "js" fn filterCallsByHash(self, hash: JsValue) -> JsArray<MockCallHistoryLog>;
}

impl MockCallHistoryLog {
    extern "js" fn toMap(self) -> JsValue;
    // property getter
    extern "js" fn host(self) -> String;
    // property setter
    extern "js" fn set_body(self, value: Option<String>);
    // property setter
    extern "js" fn set_hash(self, value: String);
    // property getter
    extern "js" fn body(self) -> Option<String>;
    extern "js" fn new(requestInit: DispatchOptions) -> MockCallHistoryLog;
    // property setter
    extern "js" fn set_port(self, value: String);
    // property getter
    extern "js" fn path(self) -> String;
    // property setter
    extern "js" fn set_path(self, value: String);
    // property setter
    extern "js" fn set_searchParams(self, value: JsValue);
    // property getter
    extern "js" fn headers(self) -> Option<JsValue>;
    // property getter
    extern "js" fn method(self) -> String;
    // property setter
    extern "js" fn set_origin(self, value: String);
    // property getter
    extern "js" fn origin(self) -> String;
    // property getter
    extern "js" fn protocol(self) -> String;
    // property setter
    extern "js" fn set_headers(self, value: Option<JsValue>);
    // property setter
    extern "js" fn set_protocol(self, value: String);
    // property getter
    extern "js" fn searchParams(self) -> JsValue;
    // property getter
    extern "js" fn port(self) -> String;
    // property getter
    extern "js" fn fullUrl(self) -> String;
    extern "js" fn toString(self) -> String;
    // property setter
    extern "js" fn set_host(self, value: String);
    // property getter
    extern "js" fn hash(self) -> String;
    // property setter
    extern "js" fn set_fullUrl(self, value: String);
    // property setter
    extern "js" fn set_method(self, value: String);
}

impl MockClient {
    extern "js" fn cleanMocks(self);
    extern "js" fn dispatch(self, options: DispatchOptions, handlers: DispatchHandler) -> bool;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn new(origin: String, options: Options) -> MockClient;
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
}

impl MockDispatch<TData, TError> {
    #[getter]
    #[setter]
    extern "js" times: Option<f64>;
    #[getter]
    #[setter]
    extern "js" persist: bool;
    #[getter]
    #[setter]
    extern "js" consumed: bool;
    #[getter]
    #[setter]
    extern "js" data: MockDispatchData<TData, TError>;
}

impl MockDispatchData<TData, TError> {
    #[getter]
    #[setter]
    extern "js" error: Option<TError>;
    #[getter]
    #[setter]
    extern "js" statusCode: Option<f64>;
    #[getter]
    #[setter]
    extern "js" data: Option<JsValue>;
}

impl MockFunctionCall<F, ReturnType, Args> {
    #[getter]
    #[setter]
    extern "js" arguments: Args;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" result: Option<ReturnType>;
    #[getter]
    #[setter]
    extern "js" stack: JsValue;
    #[getter]
    #[setter]
    extern "js" target: JsValue;
    #[getter]
    #[setter]
    extern "js" this: JsValue;
}

impl MockFunctionContext<F> {
    #[getter]
    extern "js" calls: JsArray<MockFunctionCall<F>>;

    extern "js" fn mockImplementationOnce(self, implementation: F, onCall: Option<f64>);
    extern "js" fn callCount(self) -> f64;
    extern "js" fn resetCalls(self);
    extern "js" fn restore(self);
    extern "js" fn mockImplementation(self, implementation: F);
}

impl MockFunctionOptions {
    #[getter]
    #[setter]
    extern "js" times: Option<Option<f64>>;
}

impl MockInterceptor {
    extern "js" fn defaultReplyTrailers(self, trailers: JsValue) -> MockInterceptor;
    extern "js" fn defaultReplyHeaders(self, headers: IncomingHttpHeaders) -> MockInterceptor;
    extern "js" fn new(options: Options, mockDispatches: JsArray<MockDispatch>) -> MockInterceptor;
    extern "js" fn replyWithError(self, error: TError) -> MockScope;
    extern "js" fn replyContentLength(self) -> MockInterceptor;
    // merged from 2 overloads
    extern "js" fn reply(self, statusCode: f64, data: Option<JsValue>, responseOptions: Option<MockResponseOptions>) -> MockScope<TData>;
}

impl MockMethodOptions {
    #[getter]
    #[setter]
    extern "js" getter: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setter: Option<Option<bool>>;
}

impl MockModuleContext {
    extern "js" fn restore(self);
}

impl MockModuleOptions {
    #[getter]
    #[setter]
    extern "js" cache: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultExport: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" namedExports: Option<Option<JsValue>>;
}

impl MockNotMatchedError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    extern "js" fn new(message: Option<String>) -> MockNotMatchedError;
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl MockPool {
    extern "js" fn new(origin: String, options: Options) -> MockPool;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn intercept(self, options: Options) -> MockInterceptor;
    extern "js" fn cleanMocks(self);
    extern "js" fn dispatch(self, options: DispatchOptions, handlers: DispatchHandler) -> bool;
}

impl MockPropertyContext<PropertyType> {
    // property (readonly)
    extern "js" fn accesses(self) -> JsArray<JsValue>;
    extern "js" fn accessCount(self) -> f64;
    extern "js" fn mockImplementationOnce(self, value: PropertyType, onAccess: Option<f64>);
    extern "js" fn restore(self);
    extern "js" fn resetAccesses(self);
    extern "js" fn mockImplementation(self, value: PropertyType);
}

impl MockResponseCallbackOptions {
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" origin: Option<String>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
}

impl MockResponseOptions {
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" trailers: Option<JsValue>;
}

impl MockScope<TData> {
    extern "js" fn new<TData>(mockDispatch: MockDispatch<TData>) -> MockScope;
    extern "js" fn persist(self) -> MockScope<TData>;
    extern "js" fn delay(self, waitInMs: f64) -> MockScope<TData>;
    extern "js" fn times(self, repeatTimes: f64) -> MockScope<TData>;
}

impl MockTimers {
    extern "js" fn runAll(self);
    extern "js" fn reset(self);
    extern "js" fn tick(self, milliseconds: f64);
    extern "js" fn setTime(self, time: f64);
    extern "js" fn enable(self, options: Option<MockTimersOptions>);
}

impl MockTimersOptions {
    #[getter]
    #[setter]
    extern "js" apis: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" now: Option<JsValue>;
}

impl MockTracker {
    #[getter]
    extern "js" timers: MockTimers;

    // merged from 2 overloads
    extern "js" fn setter(self, object: JsValue, methodName: JsValue, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
    extern "js" fn module(self, specifier: String, options: Option<MockModuleOptions>) -> MockModuleContext;
    // merged from 4 overloads
    extern "js" fn method(self, object: JsValue, methodName: JsValue, implementation: JsValue, options: Option<MockFunctionOptions>) -> JsValue;
    extern "js" fn restoreAll(self);
    extern "js" fn property(self, object: JsValue, property: JsValue, value: Option<JsValue>) -> JsValue;
    extern "js" fn reset(self);
    // merged from 2 overloads
    extern "js" fn fn_(self, original: Option<JsValue>, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
    // merged from 2 overloads
    extern "js" fn getter(self, object: JsValue, methodName: JsValue, implementation: Option<JsValue>, options: Option<MockFunctionOptions>) -> JsValue;
}

impl Module {
    #[getter]
    #[setter]
    extern "js" children: JsArray<Module>;
    #[getter]
    #[setter]
    extern "js" exports: JsValue;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" isPreloading: bool;
    #[getter]
    #[setter]
    extern "js" loaded: bool;
    #[getter]
    #[setter]
    extern "js" parent: Option<Module>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" paths: JsArray<String>;

    extern "js" fn require(self, id: String) -> JsValue;
}

impl ModuleHooks {
    extern "js" fn deregister(self);
}

impl ModuleRequest {
    #[getter]
    #[setter]
    extern "js" specifier: String;
    #[getter]
    #[setter]
    extern "js" attributes: ImportAttributes;
    #[getter]
    #[setter]
    extern "js" phase: JsValue;
}

impl MultiCacheQueryOptions {
    #[getter]
    #[setter]
    extern "js" cacheName: Option<String>;
}

impl MxRecord {
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" exchange: String;
}

impl NaptrRecord {
    #[getter]
    #[setter]
    extern "js" flags: String;
    #[getter]
    #[setter]
    extern "js" service: String;
    #[getter]
    #[setter]
    extern "js" regexp: String;
    #[getter]
    #[setter]
    extern "js" replacement: String;
    #[getter]
    #[setter]
    extern "js" order: f64;
    #[getter]
    #[setter]
    extern "js" preference: f64;
}

impl Navigator {
    #[getter]
    extern "js" hardwareConcurrency: f64;
    #[getter]
    extern "js" language: String;
    #[getter]
    extern "js" languages: JsArray<String>;
    #[getter]
    extern "js" locks: LockManager;
    #[getter]
    extern "js" platform: String;
    #[getter]
    extern "js" userAgent: String;
}

impl NetworkInterfaceBase {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" netmask: String;
    #[getter]
    #[setter]
    extern "js" mac: String;
    #[getter]
    #[setter]
    extern "js" internal: bool;
    #[getter]
    #[setter]
    extern "js" cidr: Option<String>;
    #[getter]
    #[setter]
    extern "js" scopeid: Option<f64>;
}

impl NetworkInterfaceInfoIPv4 {
    #[getter]
    #[setter]
    extern "js" family: String;
}

impl NetworkInterfaceInfoIPv6 {
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" scopeid: f64;
}

impl NodeEventTarget {
    extern "js" fn eventNames(self) -> JsArray<String>;
    extern "js" fn listenerCount(self, type_: String) -> f64;
    extern "js" fn once(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
    extern "js" fn on(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
    extern "js" fn removeListener(self, type_: String, listener: fn(JsValue) -> (), options: Option<EventListenerOptions>) -> NodeEventTarget;
    extern "js" fn emit(self, type_: String, arg: JsValue) -> bool;
    extern "js" fn setMaxListeners(self, n: f64);
    extern "js" fn getMaxListeners(self) -> f64;
    extern "js" fn removeAllListeners(self, type_: Option<String>) -> NodeEventTarget;
    extern "js" fn off(self, type_: String, listener: fn(JsValue) -> (), options: Option<EventListenerOptions>) -> NodeEventTarget;
    extern "js" fn addListener(self, type_: String, listener: fn(JsValue) -> ()) -> NodeEventTarget;
}

impl NodeGCPerformanceDetail {
    #[getter]
    extern "js" kind: f64;
    #[getter]
    extern "js" flags: f64;
}

impl NotSupportedError {
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
}

impl NotifyWhenWaitingForDisconnectParameterType {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl ObjectEncodingOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl ObjectPreview {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" overflow: bool;
    #[getter]
    #[setter]
    extern "js" properties: JsArray<PropertyPreview>;
    #[getter]
    #[setter]
    extern "js" entries: Option<Option<JsArray<EntryPreview>>>;
}

impl OnReadOpts {
    #[getter]
    #[setter]
    extern "js" buffer: JsValue;

    extern "js" fn callback(self, bytesWritten: f64, buffer: JsValue) -> bool;
}

impl OneShotDigestOptions {
    #[getter]
    #[setter]
    extern "js" outputEncoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" outputLength: Option<Option<f64>>;
}

impl OneShotDigestOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" outputEncoding: String;
}

impl OneShotDigestOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" outputEncoding: Option<Option<String>>;
}

impl OpenAsBlobOptions {
    #[getter]
    #[setter]
    extern "js" type_: Option<Option<String>>;
}

impl OpenDirOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" bufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
}

impl Options {
    #[getter]
    #[setter]
    extern "js" httpProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" httpsProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" noProxy: Option<String>;
    #[getter]
    #[setter]
    extern "js" uri: String;
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" token: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<IncomingHttpHeaders>;
    #[getter]
    #[setter]
    extern "js" requestTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTls: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxyTunnel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" snapshotPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxSnapshots: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoFlush: Option<bool>;
    #[getter]
    #[setter]
    extern "js" flushInterval: Option<f64>;
    #[getter]
    #[setter]
    extern "js" matchHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" ignoreHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" excludeHeaders: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" matchBody: Option<bool>;
    #[getter]
    #[setter]
    extern "js" matchQuery: Option<bool>;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" excludeUrls: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" agent: MockAgent;
    #[getter]
    #[setter]
    extern "js" agent: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" ignoreTrailingSlash: Option<bool>;
    #[getter]
    #[setter]
    extern "js" acceptNonStandardSearchParameters: Option<bool>;
    #[getter]
    #[setter]
    extern "js" enableCallHistory: Option<bool>;
    #[getter]
    #[setter]
    extern "js" path: JsValue;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" body: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxOrigins: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" connections: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" clientTtl: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<OptionsInterceptors>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" interceptors: Option<OptionsInterceptors>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" connectTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bodyTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" idleTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxKeepAliveTimeout: Option<()>;
    #[getter]
    #[setter]
    extern "js" keepAliveMaxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutThreshold: Option<f64>;
    #[getter]
    #[setter]
    extern "js" socketPath: Option<String>;
    #[getter]
    #[setter]
    extern "js" pipelining: Option<f64>;
    #[getter]
    #[setter]
    extern "js" tls: Option<()>;
    #[getter]
    #[setter]
    extern "js" strictContentLength: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxCachedSessions: Option<f64>;
    #[getter]
    #[setter]
    extern "js" connect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxRequestsPerClient: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxResponseSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<bool>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" allowH2: Option<bool>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<f64>;
    #[getter]
    #[setter]
    extern "js" hostname: String;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: String;
    #[getter]
    #[setter]
    extern "js" port: String;
    #[getter]
    #[setter]
    extern "js" servername: Option<String>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" httpSocket: Option<Socket>;

    extern "js" fn factory(self, origin: URL, opts: JsValue) -> Dispatcher;
}

impl OptionsInterceptors {
    #[getter]
    #[setter]
    extern "js" Client: JsArray<DispatchInterceptor>;
    #[getter]
    #[setter]
    extern "js" Client: JsArray<DispatchInterceptor>;
}

impl OutgoingHttpHeaders {
    #[getter]
    #[setter]
    extern "js" accept: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept-charset: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept-encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept-language: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" accept-ranges: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-credentials: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-methods: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-allow-origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-expose-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-max-age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-request-headers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" access-control-request-method: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" age: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" allow: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cache-control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cdn-cache-control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" connection: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" content-disposition: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-language: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-length: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" content-location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-security-policy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-security-policy-report-only: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" content-type: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" cookie: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dav: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dnt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" date: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" etag: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expect: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" expires: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" forwarded: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" from: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-modified-since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-none-match: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" if-unmodified-since: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" last-modified: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" link: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" location: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" max-forwards: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" origin: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pragma: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxy-authenticate: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" proxy-authorization: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public-key-pins: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" public-key-pins-report-only: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" range: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" referrer-policy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" refresh: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" retry-after: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-accept: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-extensions: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-key: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-protocol: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sec-websocket-version: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" server: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" set-cookie: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" strict-transport-security: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" te: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" trailer: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" transfer-encoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" user-agent: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" upgrade-insecure-requests: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" vary: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" via: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" warning: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" www-authenticate: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" x-content-type-options: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x-dns-prefetch-control: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x-frame-options: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" x-xss-protection: Option<Option<String>>;
}

impl OutgoingMessage<Request> {
    extern "js" fn setHeaders(self, headers: JsValue) -> OutgoingMessage;
    extern "js" fn getHeaders(self) -> OutgoingHttpHeaders;
    extern "js" fn new<Request>() -> OutgoingMessage;
    extern "js" fn hasHeader(self, name: String) -> bool;
    extern "js" fn getHeader(self, name: String) -> JsValue;
    extern "js" fn removeHeader(self, name: String);
    extern "js" fn flushHeaders(self);
    // property getter
    extern "js" fn shouldKeepAlive(self) -> bool;
    // property setter
    extern "js" fn set_useChunkedEncodingByDefault(self, value: bool);
    // property setter
    extern "js" fn set_sendDate(self, value: bool);
    extern "js" fn setTimeout(self, msecs: f64, callback: Option<fn() -> ()>) -> OutgoingMessage;
    // property getter
    extern "js" fn finished(self) -> bool;
    extern "js" fn setHeader(self, name: String, value: JsValue) -> OutgoingMessage;
    extern "js" fn getHeaderNames(self) -> JsArray<String>;
    // property setter
    extern "js" fn set_chunkedEncoding(self, value: bool);
    extern "js" fn addTrailers(self, headers: JsValue);
    extern "js" fn appendHeader(self, name: String, value: JsValue) -> OutgoingMessage;
    // property setter
    extern "js" fn set_shouldKeepAlive(self, value: bool);
    // property getter
    extern "js" fn sendDate(self) -> bool;
    // property (readonly)
    extern "js" fn connection(self) -> Option<Socket>;
    // property (readonly)
    extern "js" fn socket(self) -> Option<Socket>;
    // property (readonly)
    extern "js" fn headersSent(self) -> bool;
    // property (readonly)
    extern "js" fn req(self) -> Request;
    // property getter
    extern "js" fn chunkedEncoding(self) -> bool;
    // property getter
    extern "js" fn useChunkedEncodingByDefault(self) -> bool;
    // property setter
    extern "js" fn set_finished(self, value: bool);
}

impl PSKCallbackNegotation {
    #[getter]
    #[setter]
    extern "js" psk: JsValue;
    #[getter]
    #[setter]
    extern "js" identity: String;
}

impl ParseArgsConfig {
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" options: Option<Option<ParseArgsOptionsConfig>>;
    #[getter]
    #[setter]
    extern "js" strict: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowPositionals: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" allowNegative: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" tokens: Option<Option<bool>>;
}

impl ParseArgsOptionDescriptor {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" multiple: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" short: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" default_: Option<JsValue>;
}

impl ParseOptions {
    #[getter]
    #[setter]
    extern "js" maxKeys: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" decodeURIComponent: Option<Option<fn(String) -> String>>;
}

impl ParsedPath {
    #[getter]
    #[setter]
    extern "js" root: String;
    #[getter]
    #[setter]
    extern "js" dir: String;
    #[getter]
    #[setter]
    extern "js" base: String;
    #[getter]
    #[setter]
    extern "js" ext: String;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl PathToFileUrlOptions {
    #[getter]
    #[setter]
    extern "js" windows: Option<Option<bool>>;
}

impl PauseOnAsyncCallParameterType {
    #[getter]
    #[setter]
    extern "js" parentStackTraceId: StackTraceId;
}

impl PausedEventDataType {
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" reason: String;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" hitBreakpoints: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
    #[getter]
    #[setter]
    extern "js" asyncCallStackTraceId: Option<Option<StackTraceId>>;
}

impl Pbkdf2Params {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
    #[getter]
    #[setter]
    extern "js" iterations: f64;
    #[getter]
    #[setter]
    extern "js" salt: JsValue;
}

impl PeerCertificate {
    #[getter]
    #[setter]
    extern "js" ca: bool;
    #[getter]
    #[setter]
    extern "js" raw: JsValue;
    #[getter]
    #[setter]
    extern "js" subject: Certificate;
    #[getter]
    #[setter]
    extern "js" issuer: Certificate;
    #[getter]
    #[setter]
    extern "js" valid_from: String;
    #[getter]
    #[setter]
    extern "js" valid_to: String;
    #[getter]
    #[setter]
    extern "js" serialNumber: String;
    #[getter]
    #[setter]
    extern "js" fingerprint: String;
    #[getter]
    #[setter]
    extern "js" fingerprint256: String;
    #[getter]
    #[setter]
    extern "js" fingerprint512: String;
    #[getter]
    #[setter]
    extern "js" ext_key_usage: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" subjectaltname: Option<String>;
    #[getter]
    #[setter]
    extern "js" infoAccess: Option<Dict<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" bits: Option<f64>;
    #[getter]
    #[setter]
    extern "js" exponent: Option<String>;
    #[getter]
    #[setter]
    extern "js" modulus: Option<String>;
    #[getter]
    #[setter]
    extern "js" pubkey: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" asn1Curve: Option<String>;
    #[getter]
    #[setter]
    extern "js" nistCurve: Option<String>;
}

impl PendingInterceptor {
    #[getter]
    #[setter]
    extern "js" origin: String;
}

impl PendingInterceptorsFormatter {
    extern "js" fn format(self, pendingInterceptors: JsArray<PendingInterceptor>) -> String;
}

impl Performance {
    #[getter]
    #[setter]
    extern "js" eventLoopUtilization: fn(EventLoopUtilization, EventLoopUtilization) -> EventLoopUtilization;
    #[getter]
    extern "js" nodeTiming: PerformanceNodeTiming;
    #[getter]
    extern "js" timeOrigin: f64;

    extern "js" fn mark(self, name: String, options: Option<MarkOptions>) -> PerformanceMark;
    extern "js" fn timerify(self, fn_: JsValue, options: Option<TimerifyOptions>) -> JsValue;
    extern "js" fn toJSON(self) -> JsValue;
    extern "js" fn clearResourceTimings(self, name: Option<String>);
    extern "js" fn getEntriesByName(self, name: String, type_: Option<String>) -> JsArray<PerformanceEntry>;
    extern "js" fn setResourceTimingBufferSize(self, maxSize: f64);
    // merged from 2 overloads
    extern "js" fn measure(self, name: String, startMark: Option<String>, endMark: Option<String>) -> PerformanceMeasure;
    extern "js" fn clearMarks(self, name: Option<String>);
    extern "js" fn getEntriesByType(self, type_: String) -> JsArray<PerformanceEntry>;
    extern "js" fn clearMeasures(self, name: Option<String>);
    extern "js" fn getEntries(self) -> JsArray<PerformanceEntry>;
    extern "js" fn markResourceTiming(self, timingInfo: JsValue, requestedUrl: String, initiatorType: String, global: JsValue, cacheMode: String, bodyInfo: JsValue, responseStatus: f64, deliveryType: Option<String>) -> PerformanceResourceTiming;
    extern "js" fn now(self) -> f64;
}

impl PerformanceEntry {
    // property (readonly)
    extern "js" fn startTime(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn duration(self) -> f64;
    extern "js" fn new() -> PerformanceEntry;
    // property (readonly)
    extern "js" fn name(self) -> String;
    extern "js" fn toJSON(self) -> JsValue;
}

impl PerformanceMark {
    // property (readonly)
    extern "js" fn duration(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn detail(self) -> JsValue;
}

impl PerformanceMeasure {
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn detail(self) -> JsValue;
}

impl PerformanceNodeTiming {
    // property (readonly)
    extern "js" fn v8Start(self) -> f64;
    // property (readonly)
    extern "js" fn loopExit(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn loopStart(self) -> f64;
    // property (readonly)
    extern "js" fn uvMetricsInfo(self) -> UVMetrics;
    // property (readonly)
    extern "js" fn environment(self) -> f64;
    // property (readonly)
    extern "js" fn bootstrapComplete(self) -> f64;
    // property (readonly)
    extern "js" fn idleTime(self) -> f64;
    // property (readonly)
    extern "js" fn nodeStart(self) -> f64;
}

impl PerformanceObserver {
    extern "js" fn new(callback: fn(PerformanceObserverEntryList, PerformanceObserver) -> ()) -> PerformanceObserver;
    extern "js" fn disconnect(self);
    extern "js" fn takeRecords(self) -> JsArray<PerformanceEntry>;
    extern "js" fn observe(self, options: JsValue);
}

impl PerformanceObserverEntryList {
    extern "js" fn getEntriesByType(self, type_: String) -> JsArray<PerformanceEntry>;
    extern "js" fn getEntries(self) -> JsArray<PerformanceEntry>;
    extern "js" fn getEntriesByName(self, name: String, type_: Option<String>) -> JsArray<PerformanceEntry>;
}

impl PerformanceResourceTiming {
    extern "js" fn new() -> PerformanceResourceTiming;
    // property (readonly)
    extern "js" fn domainLookupEnd(self) -> f64;
    // property (readonly)
    extern "js" fn connectStart(self) -> f64;
    // property (readonly)
    extern "js" fn fetchStart(self) -> f64;
    // property (readonly)
    extern "js" fn secureConnectionStart(self) -> f64;
    // property (readonly)
    extern "js" fn encodedBodySize(self) -> f64;
    // property (readonly)
    extern "js" fn workerStart(self) -> f64;
    // property (readonly)
    extern "js" fn responseEnd(self) -> f64;
    // property (readonly)
    extern "js" fn redirectStart(self) -> f64;
    // property (readonly)
    extern "js" fn connectEnd(self) -> f64;
    // property (readonly)
    extern "js" fn transferSize(self) -> f64;
    extern "js" fn toJSON(self) -> JsValue;
    // property (readonly)
    extern "js" fn redirectEnd(self) -> f64;
    // property (readonly)
    extern "js" fn entryType(self) -> String;
    // property (readonly)
    extern "js" fn decodedBodySize(self) -> f64;
    // property (readonly)
    extern "js" fn requestStart(self) -> f64;
    // property (readonly)
    extern "js" fn domainLookupStart(self) -> f64;
}

impl Pipe {
    extern "js" fn close(self);
    extern "js" fn unref(self);
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn ref(self);
}

impl PipelineHandlerData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl PipelineOptions<TOpaque> {
    #[getter]
    #[setter]
    extern "js" objectMode: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<bool>;
}

impl PlatformPath {
    #[getter]
    extern "js" sep: String;
    #[getter]
    extern "js" delimiter: String;
    #[getter]
    extern "js" posix: PlatformPath;
    #[getter]
    extern "js" win32: PlatformPath;

    extern "js" fn resolve(self, paths: JsArray<String>) -> String;
    extern "js" fn matchesGlob(self, path: String, pattern: String) -> bool;
    extern "js" fn basename(self, path: String, suffix: Option<String>) -> String;
    extern "js" fn join(self, paths: JsArray<String>) -> String;
    extern "js" fn relative(self, from: String, to: String) -> String;
    extern "js" fn parse(self, path: String) -> ParsedPath;
    extern "js" fn extname(self, path: String) -> String;
    extern "js" fn toNamespacedPath(self, path: String) -> String;
    extern "js" fn format(self, pathObject: FormatInputPathObject) -> String;
    extern "js" fn isAbsolute(self, path: String) -> bool;
    extern "js" fn dirname(self, path: String) -> String;
    extern "js" fn normalize(self, path: String) -> String;
}

impl Pool {
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn new(url: JsValue, options: Option<Options>) -> Pool;
    // property setter
    extern "js" fn set_closed(self, value: bool);
    // property getter
    extern "js" fn closed(self) -> bool;
    // property (readonly)
    extern "js" fn stats(self) -> JsValue;
    // merged from 2 overloads
    extern "js" fn connect(self, options: JsValue, callback: Option<fn(Option<JsValue>, ConnectData) -> ()>);
}

impl PoolStats {
    // property getter
    extern "js" fn queued(self) -> f64;
    // property setter
    extern "js" fn set_queued(self, value: f64);
    // property getter
    extern "js" fn running(self) -> f64;
    // property setter
    extern "js" fn set_size(self, value: f64);
    // property setter
    extern "js" fn set_pending(self, value: f64);
    // property setter
    extern "js" fn set_running(self, value: f64);
    // property setter
    extern "js" fn set_free(self, value: f64);
    // property getter
    extern "js" fn free(self) -> f64;
    // property setter
    extern "js" fn set_connected(self, value: f64);
    // property getter
    extern "js" fn connected(self) -> f64;
    extern "js" fn new(pool: Pool) -> PoolStats;
    // property getter
    extern "js" fn pending(self) -> f64;
    // property getter
    extern "js" fn size(self) -> f64;
}

impl PositionTickInfo {
    #[getter]
    #[setter]
    extern "js" line: f64;
    #[getter]
    #[setter]
    extern "js" ticks: f64;
}

impl PrivateKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl Process {
    #[getter]
    #[setter]
    extern "js" stdout: WriteStream;
    #[getter]
    #[setter]
    extern "js" stderr: WriteStream;
    #[getter]
    #[setter]
    extern "js" stdin: ReadStream;
    #[getter]
    #[setter]
    extern "js" argv: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" argv0: String;
    #[getter]
    #[setter]
    extern "js" execArgv: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" execPath: String;
    #[getter]
    #[setter]
    extern "js" debugPort: f64;
    #[getter]
    #[setter]
    extern "js" env: ProcessEnv;
    #[getter]
    #[setter]
    extern "js" exitCode: JsValue;
    #[getter]
    #[setter]
    extern "js" finalization: JsValue;
    #[getter]
    extern "js" sourceMapsEnabled: bool;
    #[getter]
    extern "js" version: String;
    #[getter]
    extern "js" versions: ProcessVersions;
    #[getter]
    extern "js" config: ProcessConfig;
    #[getter]
    extern "js" pid: f64;
    #[getter]
    extern "js" ppid: f64;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    extern "js" arch: String;
    #[getter]
    extern "js" platform: String;
    #[getter]
    #[setter]
    extern "js" mainModule: Option<Module>;
    #[getter]
    #[setter]
    extern "js" memoryUsage: MemoryUsageFn;
    #[getter]
    #[setter]
    extern "js" permission: ProcessPermission;
    #[getter]
    extern "js" release: ProcessRelease;
    #[getter]
    extern "js" features: ProcessFeatures;
    #[getter]
    #[setter]
    extern "js" hrtime: HRTime;
    #[getter]
    #[setter]
    extern "js" channel: Option<Control>;
    #[getter]
    #[setter]
    extern "js" connected: bool;
    #[getter]
    #[setter]
    extern "js" allowedNodeEnvironmentFlags: JsValue;
    #[getter]
    #[setter]
    extern "js" report: ProcessReport;
    #[getter]
    #[setter]
    extern "js" throwDeprecation: bool;
    #[getter]
    #[setter]
    extern "js" traceDeprecation: bool;

    extern "js" fn hasUncaughtExceptionCaptureCallback(self) -> bool;
    extern "js" fn dlopen(self, module: JsValue, filename: String, flags: Option<f64>);
    // merged from 13 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn loadEnvFile(self, path: Option<JsValue>);
    extern "js" fn resourceUsage(self) -> ResourceUsage;
    extern "js" fn chdir(self, directory: String);
    // merged from 13 overloads
    extern "js" fn addListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn cwd(self) -> String;
    // function property
    extern "js" fn seteuid(self) -> Option<fn(JsValue) -> ()>;
    // function property
    extern "js" fn setgid(self) -> Option<fn(JsValue) -> ()>;
    extern "js" fn uptime(self) -> f64;
    extern "js" fn disconnect(self);
    // function property
    extern "js" fn getgid(self) -> Option<fn() -> f64>;
    // function property
    extern "js" fn getgroups(self) -> Option<fn() -> JsArray<f64>>;
    extern "js" fn setSourceMapsEnabled(self, value: bool);
    extern "js" fn ref(self, maybeRefable: JsValue);
    extern "js" fn cpuUsage(self, previousValue: Option<CpuUsage>) -> CpuUsage;
    extern "js" fn nextTick(self, callback: JsFn, args: JsArray<JsValue>);
    extern "js" fn unref(self, maybeRefable: JsValue);
    extern "js" fn constrainedMemory(self) -> f64;
    // function property
    extern "js" fn getegid(self) -> Option<fn() -> f64>;
    extern "js" fn threadCpuUsage(self, previousValue: Option<CpuUsage>) -> CpuUsage;
    extern "js" fn abort(self);
    extern "js" fn availableMemory(self) -> f64;
    // merged from 4 overloads
    extern "js" fn emitWarning(self, warning: JsValue, type_: Option<String>, code: Option<String>, ctor: Option<JsFn>);
    // function property
    extern "js" fn setegid(self) -> Option<fn(JsValue) -> ()>;
    // merged from 2 overloads
    extern "js" fn umask(self, mask: Option<JsValue>) -> f64;
    // function property
    extern "js" fn geteuid(self) -> Option<fn() -> f64>;
    extern "js" fn execve(self, file: String, args: Option<JsArray<String>>, env: Option<ProcessEnv>);
    // merged from 13 overloads
    extern "js" fn emit(self, event: String, type_: Option<String>, promise: Option<JsPromise<JsValue>>, value: Option<JsValue>) -> Process;
    // merged from 13 overloads
    extern "js" fn listeners(self, event: String) -> JsArray<fn(f64) -> ()>;
    // merged from 13 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn setUncaughtExceptionCaptureCallback(self, cb: Option<fn(JsValue) -> ()>);
    extern "js" fn send(self, message: JsValue, sendHandle: Option<JsValue>, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // merged from 14 overloads
    extern "js" fn on(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn kill(self, pid: f64, signal: Option<JsValue>) -> bool;
    // merged from 2 overloads
    extern "js" fn getBuiltinModule(self, id: JsValue) -> JsValue;
    extern "js" fn getActiveResourcesInfo(self) -> JsArray<String>;
    // function property
    extern "js" fn setgroups(self) -> Option<fn(JsArray<JsValue>) -> ()>;
    // function property
    extern "js" fn getuid(self) -> Option<fn() -> f64>;
    // merged from 14 overloads
    extern "js" fn once(self, event: String, listener: fn(f64) -> ()) -> Process;
    extern "js" fn exit(self, code: Option<JsValue>);
    // function property
    extern "js" fn setuid(self) -> Option<fn(JsValue) -> ()>;
}

impl ProcessConfig {
    #[getter]
    extern "js" target_defaults: JsValue;
    #[getter]
    extern "js" variables: JsValue;
}

impl ProcessEnv {
    #[getter]
    #[setter]
    extern "js" TZ: Option<Option<String>>;
}

impl ProcessEnvOptions {
    #[getter]
    #[setter]
    extern "js" uid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" gid: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<ProcessEnv>>;
}

impl ProcessFeatures {
    #[getter]
    extern "js" cached_builtins: bool;
    #[getter]
    extern "js" debug: bool;
    #[getter]
    extern "js" inspector: bool;
    #[getter]
    extern "js" ipv6: bool;
    #[getter]
    extern "js" require_module: bool;
    #[getter]
    extern "js" tls: bool;
    #[getter]
    extern "js" tls_alpn: bool;
    #[getter]
    extern "js" tls_ocsp: bool;
    #[getter]
    extern "js" tls_sni: bool;
    #[getter]
    extern "js" typescript: JsValue;
    #[getter]
    extern "js" uv: bool;
}

impl ProcessPermission {
    extern "js" fn has(self, scope: String, reference: Option<String>) -> bool;
}

impl ProcessRelease {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" sourceUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" headersUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" libUrl: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" lts: Option<Option<String>>;
}

impl ProcessReport {
    #[getter]
    #[setter]
    extern "js" compact: bool;
    #[getter]
    #[setter]
    extern "js" directory: String;
    #[getter]
    #[setter]
    extern "js" filename: String;
    #[getter]
    #[setter]
    extern "js" reportOnFatalError: bool;
    #[getter]
    #[setter]
    extern "js" reportOnSignal: bool;
    #[getter]
    #[setter]
    extern "js" reportOnUncaughtException: bool;
    #[getter]
    #[setter]
    extern "js" signal: String;

    // merged from 2 overloads
    extern "js" fn writeReport(self, fileName: Option<String>, err: Option<JsValue>) -> String;
    extern "js" fn getReport(self, err: Option<JsValue>) -> JsValue;
}

impl ProcessVersions {
    #[getter]
    #[setter]
    extern "js" http_parser: String;
    #[getter]
    #[setter]
    extern "js" node: String;
    #[getter]
    #[setter]
    extern "js" v8: String;
    #[getter]
    #[setter]
    extern "js" ares: String;
    #[getter]
    #[setter]
    extern "js" uv: String;
    #[getter]
    #[setter]
    extern "js" zlib: String;
    #[getter]
    #[setter]
    extern "js" modules: String;
    #[getter]
    #[setter]
    extern "js" openssl: String;
}

impl Profile {
    #[getter]
    #[setter]
    extern "js" nodes: JsArray<ProfileNode>;
    #[getter]
    #[setter]
    extern "js" startTime: f64;
    #[getter]
    #[setter]
    extern "js" endTime: f64;
    #[getter]
    #[setter]
    extern "js" samples: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" timeDeltas: Option<Option<JsArray<f64>>>;
}

impl ProfileNode {
    #[getter]
    #[setter]
    extern "js" id: f64;
    #[getter]
    #[setter]
    extern "js" callFrame: CallFrame;
    #[getter]
    #[setter]
    extern "js" hitCount: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" children: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" deoptReason: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" positionTicks: Option<Option<JsArray<PositionTickInfo>>>;
}

impl PromiseHooks {
    // function property
    extern "js" fn onInit(self) -> fn(Init) -> JsFn;
    // function property
    extern "js" fn onBefore(self) -> fn(Before) -> JsFn;
    // function property
    extern "js" fn onSettled(self) -> fn(Settled) -> JsFn;
    // function property
    extern "js" fn createHook(self) -> fn(HookCallbacks) -> JsFn;
    // function property
    extern "js" fn onAfter(self) -> fn(After) -> JsFn;
}

impl PromiseWithChild<T> {
    #[getter]
    #[setter]
    extern "js" child: ChildProcess;
}

impl PropertyDescriptor {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" get: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" set: Option<Option<RemoteObject>>;
    #[getter]
    #[setter]
    extern "js" configurable: bool;
    #[getter]
    #[setter]
    extern "js" enumerable: bool;
    #[getter]
    #[setter]
    extern "js" wasThrown: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isOwn: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" symbol: Option<Option<RemoteObject>>;
}

impl PropertyPreview {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" value: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" valuePreview: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
}

impl ProxyAgent {
    extern "js" fn dispatch(self, options: DispatchOptions, handler: DispatchHandler) -> bool;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn new(options: JsValue) -> ProxyAgent;
}

impl ProxyEnv {
    #[getter]
    #[setter]
    extern "js" HTTP_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" HTTPS_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" NO_PROXY: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" http_proxy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" https_proxy: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" no_proxy: Option<Option<String>>;
}

impl PublicKeyInput {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" format: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl PxfObject {
    #[getter]
    #[setter]
    extern "js" buf: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
}

impl QueryObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" prototypeObjectId: String;
}

impl QueryObjectsReturnType {
    #[getter]
    #[setter]
    extern "js" objects: RemoteObject;
}

impl QueuingStrategy<T> {
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" size: Option<QueuingStrategySize<T>>;
}

impl QueuingStrategyInit {
    #[getter]
    #[setter]
    extern "js" highWaterMark: f64;
}

impl REPLCommand {
    #[getter]
    #[setter]
    extern "js" help: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" action: JsFn;
}

impl REPLServer {
    // property (readonly)
    extern "js" fn useColors(self) -> bool;
    extern "js" fn clearBufferedCommand(self);
    // property (readonly)
    extern "js" fn output(self) -> WritableStream;
    // merged from 10 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    // property (readonly)
    extern "js" fn writer(self) -> JsFn;
    // merged from 2 overloads
    extern "js" fn setupHistory(self, historyPath: String, callback: fn(Option<JsValue>, REPLServer) -> ());
    // property (readonly)
    extern "js" fn context(self) -> Context;
    // merged from 10 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn underscoreAssigned(self) -> bool;
    extern "js" fn new() -> REPLServer;
    // property (readonly)
    extern "js" fn replMode(self) -> JsValue;
    // property (readonly)
    extern "js" fn useGlobal(self) -> bool;
    extern "js" fn defineCommand(self, keyword: String, cmd: JsValue);
    // merged from 10 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn inputStream(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn last(self) -> JsValue;
    // property (readonly)
    extern "js" fn lastError(self) -> JsValue;
    // property (readonly)
    extern "js" fn completer(self) -> JsValue;
    // property (readonly)
    extern "js" fn ignoreUndefined(self) -> bool;
    // property (readonly)
    extern "js" fn input(self) -> ReadableStream;
    // property (readonly)
    extern "js" fn underscoreErrAssigned(self) -> bool;
    // merged from 10 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // property (readonly)
    extern "js" fn commands(self) -> ReadOnlyDict<REPLCommand>;
    // property (readonly)
    extern "js" fn editorMode(self) -> bool;
    // property (readonly)
    extern "js" fn outputStream(self) -> WritableStream;
    // property (readonly)
    extern "js" fn eval(self) -> JsFn;
    // merged from 10 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    // merged from 10 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> REPLServer;
    extern "js" fn displayPrompt(self, preserveCursor: Option<bool>);
}

impl REPLServerSetupHistoryOptions {
    #[getter]
    #[setter]
    extern "js" filePath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" size: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" removeHistoryDuplicates: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onHistoryFileLoaded: Option<Option<fn(Option<JsValue>, REPLServer) -> ()>>;
}

impl RSAKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
}

impl RSAKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl RSAPSSKeyPairKeyObjectOptions {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<String>>;
}

impl RSAPSSKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" mgf1HashAlgorithm: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl RandomUUIDOptions {
    #[getter]
    #[setter]
    extern "js" disableEntropyCache: Option<Option<bool>>;
}

impl ReadLineOptions {
    #[getter]
    #[setter]
    extern "js" completer: Option<Option<fn(String) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" input: ReadableStream;
    #[getter]
    #[setter]
    extern "js" output: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" completer: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" terminal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" history: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" historySize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" removeHistoryDuplicates: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" prompt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crlfDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" escapeCodeTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" tabSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl ReadOptions {
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<JsValue>>;
}

impl ReadOptionsWithBuffer<T> {
    #[getter]
    #[setter]
    extern "js" buffer: Option<Option<T>>;
}

impl ReadParameterType {
    #[getter]
    #[setter]
    extern "js" handle: String;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" size: Option<Option<f64>>;
}

impl ReadReturnType {
    #[getter]
    #[setter]
    extern "js" data: String;
    #[getter]
    #[setter]
    extern "js" eof: bool;
}

impl ReadStream {
    extern "js" fn close(self, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // property getter
    extern "js" fn bytesRead(self) -> f64;
    // property setter
    extern "js" fn set_bytesRead(self, value: f64);
    extern "js" fn prependListener(self, event: K, listener: JsValue) -> ReadStream;
    extern "js" fn prependOnceListener(self, event: K, listener: JsValue) -> ReadStream;
    // property setter
    extern "js" fn set_pending(self, value: bool);
    // property setter
    extern "js" fn set_path(self, value: JsValue);
    // property getter
    extern "js" fn pending(self) -> bool;
    extern "js" fn on(self, event: K, listener: JsValue) -> ReadStream;
    extern "js" fn once(self, event: K, listener: JsValue) -> ReadStream;
    // property getter
    extern "js" fn path(self) -> JsValue;
    extern "js" fn addListener(self, event: K, listener: JsValue) -> ReadStream;
}

impl ReadStreamOptions {
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<CreateReadStreamFSImplementation>>;
    #[getter]
    #[setter]
    extern "js" end: Option<Option<f64>>;
}

impl ReadVResult<T> {
    #[getter]
    #[setter]
    extern "js" bytesRead: f64;
    #[getter]
    #[setter]
    extern "js" buffers: T;
}

impl Readable {
    extern "js" fn push(self, chunk: JsValue, encoding: Option<JsValue>) -> bool;
    // merged from 8 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<JsValue>);
    // property (readonly)
    extern "js" fn readableLength(self) -> f64;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    extern "js" fn destroy(self, error: Option<JsValue>) -> Readable;
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Readable;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Readable;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn some(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    extern "js" fn flatMap(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // property (readonly)
    extern "js" fn readableHighWaterMark(self) -> f64;
    extern "js" fn pause(self) -> Readable;
    // property setter
    extern "js" fn set_readable(self, value: bool);
    extern "js" fn wrap(self, stream: ReadableStream) -> Readable;
    extern "js" fn forEach(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<()>;
    // property (readonly)
    extern "js" fn readableEncoding(self) -> Option<JsValue>;
    extern "js" fn toArray(self, options: Option<JsValue>) -> JsPromise<JsArray<JsValue>>;
    extern "js" fn fromWeb(readableStream: ReadableStream, options: Option<JsValue>) -> Readable;
    extern "js" fn asIndexedPairs(self, options: Option<JsValue>) -> Readable;
    extern "js" fn resume(self) -> Readable;
    // property getter
    extern "js" fn readable(self) -> bool;
    extern "js" fn isDisturbed(stream: JsValue) -> bool;
    // property (readonly)
    extern "js" fn closed(self) -> bool;
    extern "js" fn setEncoding(self, encoding: JsValue) -> Readable;
    // property (readonly)
    extern "js" fn readableObjectMode(self) -> bool;
    extern "js" fn isPaused(self) -> bool;
    extern "js" fn _read(self, size: f64);
    extern "js" fn iterator(self, options: Option<JsValue>) -> AsyncIterator<JsValue>;
    extern "js" fn map(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    extern "js" fn every(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> JsPromise<bool>;
    extern "js" fn toWeb(streamReadable: Readable, options: Option<JsValue>) -> ReadableStream;
    extern "js" fn take(self, limit: f64, options: Option<JsValue>) -> Readable;
    // merged from 2 overloads
    extern "js" fn reduce(self, fn_: fn(JsValue, JsValue, JsValue) -> T, initial: Option<()>, options: Option<JsValue>) -> JsPromise<T>;
    // property (readonly)
    extern "js" fn readableEnded(self) -> bool;
    // property (readonly)
    extern "js" fn readableAborted(self) -> bool;
    // property (readonly)
    extern "js" fn readableFlowing(self) -> Option<bool>;
    extern "js" fn new(opts: Option<ReadableOptions>) -> Readable;
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Readable;
    extern "js" fn drop(self, limit: f64, options: Option<JsValue>) -> Readable;
    // merged from 8 overloads
    extern "js" fn emit(self, event: String, chunk: Option<JsValue>) -> bool;
    // property (readonly)
    extern "js" fn readableDidRead(self) -> bool;
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    extern "js" fn filter(self, fn_: fn(JsValue, JsValue) -> JsValue, options: Option<ArrayOptions>) -> Readable;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    extern "js" fn from(iterable: JsValue, options: Option<ReadableOptions>) -> Readable;
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Readable;
    // property (readonly)
    extern "js" fn errored(self) -> Option<JsValue>;
    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> Readable;
    // merged from 2 overloads
    extern "js" fn find(self, fn_: fn(JsValue, JsValue) -> bool, options: Option<ArrayOptions>) -> JsPromise<Option<T>>;
}

impl ReadableByteStreamController {
    #[getter]
    extern "js" byobRequest: ();
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn close(self);
    extern "js" fn enqueue(self, chunk: JsValue);
    extern "js" fn error(self, error: Option<JsValue>);
}

impl ReadableOptions<T> {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" read: Option<Option<JsFn>>;
}

impl ReadableStream {
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" readable: bool;

    extern "js" fn unpipe(self, destination: Option<WritableStream>) -> ReadableStream;
    extern "js" fn unshift(self, chunk: JsValue, encoding: Option<String>);
    extern "js" fn read(self, size: Option<f64>) -> JsValue;
    extern "js" fn setEncoding(self, encoding: String) -> ReadableStream;
    extern "js" fn isPaused(self) -> bool;
    extern "js" fn pipe(self, destination: JsValue, options: Option<JsValue>) -> JsValue;
    extern "js" fn wrap(self, oldStream: ReadableStream) -> ReadableStream;
    extern "js" fn resume(self) -> ReadableStream;
    extern "js" fn pause(self) -> ReadableStream;
}

impl ReadableStreamBYOBReader {
    extern "js" fn releaseLock(self);
    extern "js" fn read(self, view: JsValue, options: Option<JsValue>) -> JsPromise<JsValue>;
}

impl ReadableStreamBYOBRequest {
    #[getter]
    extern "js" view: Option<JsValue>;

    extern "js" fn respond(self, bytesWritten: f64);
    extern "js" fn respondWithNewView(self, view: JsValue);
}

impl ReadableStreamDefaultController<R> {
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn error(self, e: Option<JsValue>);
    extern "js" fn enqueue(self, chunk: Option<R>);
    extern "js" fn close(self);
}

impl ReadableStreamDefaultReader<R> {
    extern "js" fn releaseLock(self);
    extern "js" fn read(self) -> JsPromise<JsValue>;
}

impl ReadableStreamGenericReader {
    #[getter]
    extern "js" closed: JsPromise<()>;

    extern "js" fn cancel(self, reason: Option<JsValue>) -> JsPromise<()>;
}

impl ReadableStreamGetReaderOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
}

impl ReadableStreamReadDoneResult<T> {
    #[getter]
    #[setter]
    extern "js" done: bool;
    #[getter]
    #[setter]
    extern "js" value: Option<T>;
}

impl ReadableStreamReadValueResult<T> {
    #[getter]
    #[setter]
    extern "js" done: bool;
    #[getter]
    #[setter]
    extern "js" value: T;
}

impl ReadableWebStreamOptions {
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
}

impl ReadableWritablePair<R, W> {
    #[getter]
    #[setter]
    extern "js" readable: ReadableStream<R>;
    #[getter]
    #[setter]
    extern "js" writable: WritableStream<W>;
}

impl Readline {
    extern "js" fn rollback(self) -> Readline;
    extern "js" fn new(stream: WritableStream, options: Option<JsValue>) -> Readline;
    extern "js" fn moveCursor(self, dx: f64, dy: f64) -> Readline;
    extern "js" fn clearLine(self, dir: JsValue) -> Readline;
    extern "js" fn clearScreenDown(self) -> Readline;
    extern "js" fn commit(self) -> JsPromise<()>;
    extern "js" fn cursorTo(self, x: f64, y: Option<f64>) -> Readline;
}

impl ReceivedMessageFromWorkerEventDataType {
    #[getter]
    #[setter]
    extern "js" sessionId: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl RecordWithTtl {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" ttl: f64;
}

impl RecordableHistogram {
    extern "js" fn record(self, val: JsValue);
    extern "js" fn recordDelta(self);
    extern "js" fn add(self, other: RecordableHistogram);
}

impl Recoverable {
    // property setter
    extern "js" fn set_err(self, value: JsValue);
    // property getter
    extern "js" fn err(self) -> JsValue;
    extern "js" fn new(err: JsValue) -> Recoverable;
}

impl RedirectHandler {
    extern "js" fn new(dispatch: JsValue, maxRedirections: f64, opts: DispatchOptions, handler: DispatchHandler, redirectionLimitReached: bool) -> RedirectHandler;
}

impl RefCounted {
    extern "js" fn unref(self) -> RefCounted;
    extern "js" fn ref(self) -> RefCounted;
}

impl RegisterHooksOptions {
    #[getter]
    #[setter]
    extern "js" load: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" resolve: Option<Option<JsValue>>;
}

impl RegisterOptions<Data> {
    #[getter]
    #[setter]
    extern "js" parentURL: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" data: Option<Option<Data>>;
    #[getter]
    #[setter]
    extern "js" transferList: Option<Option<JsArray<JsValue>>>;
}

impl ReleaseObjectGroupParameterType {
    #[getter]
    #[setter]
    extern "js" objectGroup: String;
}

impl ReleaseObjectParameterType {
    #[getter]
    #[setter]
    extern "js" objectId: String;
}

impl RemoteInfo {
    #[getter]
    #[setter]
    extern "js" address: String;
    #[getter]
    #[setter]
    extern "js" family: String;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" size: f64;
}

impl RemoteObject {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" subtype: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" className: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" value: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" unserializableValue: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" objectId: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" preview: Option<Option<ObjectPreview>>;
    #[getter]
    #[setter]
    extern "js" customPreview: Option<Option<CustomPreview>>;
}

impl RemoveBreakpointParameterType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
}

impl ReplOptions {
    #[getter]
    #[setter]
    extern "js" prompt: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" input: Option<Option<ReadableStream>>;
    #[getter]
    #[setter]
    extern "js" output: Option<Option<WritableStream>>;
    #[getter]
    #[setter]
    extern "js" terminal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" eval: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" preview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useColors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" useGlobal: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ignoreUndefined: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writer: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" completer: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" replMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" breakEvalOnSigint: Option<Option<bool>>;
}

impl ReportHeapSnapshotProgressEventDataType {
    #[getter]
    #[setter]
    extern "js" done: f64;
    #[getter]
    #[setter]
    extern "js" total: f64;
    #[getter]
    #[setter]
    extern "js" finished: Option<Option<bool>>;
}

impl Request {
    #[getter]
    #[setter]
    extern "js" accepted: JsArray<MediaType>;
    #[getter]
    extern "js" protocol: String;
    #[getter]
    extern "js" secure: bool;
    #[getter]
    extern "js" ip: Option<String>;
    #[getter]
    extern "js" ips: JsArray<String>;
    #[getter]
    extern "js" subdomains: JsArray<String>;
    #[getter]
    extern "js" path: String;
    #[getter]
    extern "js" hostname: String;
    #[getter]
    extern "js" host: String;
    #[getter]
    extern "js" fresh: bool;
    #[getter]
    extern "js" stale: bool;
    #[getter]
    extern "js" xhr: bool;
    #[getter]
    #[setter]
    extern "js" body: ReqBody;
    #[getter]
    #[setter]
    extern "js" cookies: JsValue;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" params: P;
    #[getter]
    #[setter]
    extern "js" query: ReqQuery;
    #[getter]
    #[setter]
    extern "js" route: JsValue;
    #[getter]
    #[setter]
    extern "js" signedCookies: JsValue;
    #[getter]
    #[setter]
    extern "js" originalUrl: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" baseUrl: String;
    #[getter]
    #[setter]
    extern "js" app: Application;
    #[getter]
    #[setter]
    extern "js" res: Option<Option<Response<ResBody, LocalsObj>>>;
    #[getter]
    #[setter]
    extern "js" next: Option<Option<NextFunction>>;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" method: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
    #[getter]
    #[setter]
    extern "js" hasPostData: bool;
    #[getter]
    #[setter]
    extern "js" origin: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" completed: bool;
    #[getter]
    #[setter]
    extern "js" method: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" headers: JsValue;

    extern "js" fn new(input: JsValue, init: Option<RequestInit>) -> Request;
    // property (readonly)
    extern "js" fn keepalive(self) -> bool;
    // property (readonly)
    extern "js" fn integrity(self) -> String;
    // property (readonly)
    extern "js" fn destination(self) -> String;
    // property (readonly)
    extern "js" fn referrerPolicy(self) -> String;
    // property (readonly)
    extern "js" fn credentials(self) -> String;
    // property (readonly)
    extern "js" fn clone(self) -> fn() -> Request;
    // property (readonly)
    extern "js" fn method(self) -> String;
    // property (readonly)
    extern "js" fn url(self) -> String;
    // property (readonly)
    extern "js" fn signal(self) -> JsValue;
    // property (readonly)
    extern "js" fn headers(self) -> Headers;
    // property (readonly)
    extern "js" fn referrer(self) -> String;
    // property (readonly)
    extern "js" fn cache(self) -> String;
    // property (readonly)
    extern "js" fn mode(self) -> String;
    // property (readonly)
    extern "js" fn redirect(self) -> String;
    // property (readonly)
    extern "js" fn duplex(self) -> String;
}

impl RequestAbortedError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl RequestBodyChunkReceivedMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" chunk: Buffer;
}

impl RequestBodyChunkSentMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" chunk: JsValue;
}

impl RequestBodySentMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
}

impl RequestContentLengthMismatchError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl RequestCreateMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
}

impl RequestErrorMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" error: JsValue;
}

impl RequestHandlerConstructor<R> {
    #[getter]
    #[setter]
    extern "js" mime: JsValue;
}

impl RequestHeadersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" response: Response;
}

impl RequestInit {
    #[getter]
    #[setter]
    extern "js" body: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" cache: Option<String>;
    #[getter]
    #[setter]
    extern "js" credentials: Option<String>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" duplex: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" integrity: Option<String>;
    #[getter]
    #[setter]
    extern "js" keepalive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirect: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" referrer: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrerPolicy: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" window: Option<()>;
    #[getter]
    #[setter]
    extern "js" body: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" cache: Option<String>;
    #[getter]
    #[setter]
    extern "js" credentials: Option<String>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" duplex: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" integrity: Option<String>;
    #[getter]
    #[setter]
    extern "js" keepalive: Option<bool>;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" mode: Option<String>;
    #[getter]
    #[setter]
    extern "js" redirect: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrer: Option<String>;
    #[getter]
    #[setter]
    extern "js" referrerPolicy: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" window: Option<()>;
}

impl RequestOptions<TOpaque> {
    #[getter]
    #[setter]
    extern "js" opaque: Option<TOpaque>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;
    #[getter]
    #[setter]
    extern "js" checkServerIdentity: Option<Option<fn(String, DetailedPeerCertificate) -> Option<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" rejectUnauthorized: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" servername: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" opaque: Option<TOpaque>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<f64>;

    // function property
    extern "js" fn onInfo(self) -> Option<fn(JsValue) -> ()>;
}

impl RequestRetryError {
    // property getter
    extern "js" fn headers(self) -> JsValue;
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // property getter
    extern "js" fn data(self) -> JsValue;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_data(self, value: JsValue);
    extern "js" fn new(message: String, statusCode: f64, headers: Option<JsValue>, body: Option<JsValue>) -> RequestRetryError;
    // property getter
    extern "js" fn statusCode(self) -> f64;
    // property setter
    extern "js" fn set_headers(self, value: JsValue);
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl RequestTrailersMessage {
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" trailers: JsArray<Buffer>;
}

impl RequestWillBeSentEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" request: Request;
    #[getter]
    #[setter]
    extern "js" initiator: Initiator;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" wallTime: f64;
}

impl Require {
    #[getter]
    #[setter]
    extern "js" cache: Dict<Module>;
    #[getter]
    #[setter]
    extern "js" extensions: RequireExtensions;
    #[getter]
    #[setter]
    extern "js" main: Option<Module>;
    #[getter]
    #[setter]
    extern "js" resolve: RequireResolve;
}

impl RequireExtensions {
    // function property
    extern "js" fn .node(self) -> fn(Module, String) -> JsValue;
    // function property
    extern "js" fn .js(self) -> fn(Module, String) -> JsValue;
    // function property
    extern "js" fn .json(self) -> fn(Module, String) -> JsValue;
}

impl RequireResolve {
    extern "js" fn paths(self, request: String) -> Option<JsArray<String>>;
}

impl RequireResolveOptions {
    #[getter]
    #[setter]
    extern "js" paths: Option<Option<JsArray<String>>>;
}

impl ResolveFnOutput {
    #[getter]
    #[setter]
    extern "js" format: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" importAttributes: Option<Option<ImportAttributes>>;
    #[getter]
    #[setter]
    extern "js" shortCircuit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl ResolveHookContext {
    #[getter]
    #[setter]
    extern "js" conditions: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" importAttributes: ImportAttributes;
    #[getter]
    #[setter]
    extern "js" parentURL: Option<String>;
}

impl ResolveOptions {
    #[getter]
    #[setter]
    extern "js" ttl: bool;
}

impl ResolveWithTtlOptions {
    #[getter]
    #[setter]
    extern "js" ttl: bool;
}

impl Resolver {
    // property getter
    extern "js" fn resolveNaptr(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveNaptr(self, value: JsValue);
    // property setter
    extern "js" fn set_resolvePtr(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveSrv(self, value: JsValue);
    // property getter
    extern "js" fn getServers(self) -> JsValue;
    // property getter
    extern "js" fn resolveTlsa(self) -> JsValue;
    // property getter
    extern "js" fn resolveMx(self) -> JsValue;
    // property setter
    extern "js" fn set_reverse(self, value: JsValue);
    // property setter
    extern "js" fn set_setServers(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveCname(self, value: JsValue);
    // property getter
    extern "js" fn resolve6(self) -> JsValue;
    extern "js" fn new(options: Option<ResolverOptions>) -> Resolver;
    // property getter
    extern "js" fn resolveSrv(self) -> JsValue;
    extern "js" fn cancel(self);
    // property setter
    extern "js" fn set_getServers(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveTxt(self, value: JsValue);
    // property setter
    extern "js" fn set_resolve(self, value: JsValue);
    // property getter
    extern "js" fn resolveAny(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveMx(self, value: JsValue);
    // property getter
    extern "js" fn resolve(self) -> JsValue;
    // property setter
    extern "js" fn set_resolve4(self, value: JsValue);
    // property setter
    extern "js" fn set_resolveAny(self, value: JsValue);
    // property getter
    extern "js" fn resolveCname(self) -> JsValue;
    // property getter
    extern "js" fn resolveSoa(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveCaa(self, value: JsValue);
    // property getter
    extern "js" fn resolvePtr(self) -> JsValue;
    // property getter
    extern "js" fn setServers(self) -> JsValue;
    // property getter
    extern "js" fn reverse(self) -> JsValue;
    // property getter
    extern "js" fn resolveNs(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveTlsa(self, value: JsValue);
    extern "js" fn setLocalAddress(self, ipv4: Option<String>, ipv6: Option<String>);
    // property setter
    extern "js" fn set_resolveSoa(self, value: JsValue);
    // property getter
    extern "js" fn resolveTxt(self) -> JsValue;
    // property setter
    extern "js" fn set_resolve6(self, value: JsValue);
    // property getter
    extern "js" fn resolve4(self) -> JsValue;
    // property setter
    extern "js" fn set_resolveNs(self, value: JsValue);
    // property getter
    extern "js" fn resolveCaa(self) -> JsValue;
}

impl ResolverOptions {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" tries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxTimeout: Option<Option<f64>>;
}

impl ResourceLimits {
    #[getter]
    #[setter]
    extern "js" maxYoungGenerationSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOldGenerationSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" codeRangeSizeMb: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackSizeMb: Option<Option<f64>>;
}

impl ResourceUsage {
    #[getter]
    #[setter]
    extern "js" fsRead: f64;
    #[getter]
    #[setter]
    extern "js" fsWrite: f64;
    #[getter]
    #[setter]
    extern "js" involuntaryContextSwitches: f64;
    #[getter]
    #[setter]
    extern "js" ipcReceived: f64;
    #[getter]
    #[setter]
    extern "js" ipcSent: f64;
    #[getter]
    #[setter]
    extern "js" majorPageFault: f64;
    #[getter]
    #[setter]
    extern "js" maxRSS: f64;
    #[getter]
    #[setter]
    extern "js" minorPageFault: f64;
    #[getter]
    #[setter]
    extern "js" sharedMemorySize: f64;
    #[getter]
    #[setter]
    extern "js" signalsCount: f64;
    #[getter]
    #[setter]
    extern "js" swappedOut: f64;
    #[getter]
    #[setter]
    extern "js" systemCPUTime: f64;
    #[getter]
    #[setter]
    extern "js" unsharedDataSize: f64;
    #[getter]
    #[setter]
    extern "js" unsharedStackSize: f64;
    #[getter]
    #[setter]
    extern "js" userCPUTime: f64;
    #[getter]
    #[setter]
    extern "js" voluntaryContextSwitches: f64;
}

impl Response {
    #[getter]
    #[setter]
    extern "js" send: fn(ResBody) -> JsValue;
    #[getter]
    #[setter]
    extern "js" json: fn(ResBody) -> JsValue;
    #[getter]
    #[setter]
    extern "js" jsonp: fn(ResBody) -> JsValue;
    #[getter]
    #[setter]
    extern "js" headersSent: bool;
    #[getter]
    #[setter]
    extern "js" locals: LocalsObj;
    #[getter]
    #[setter]
    extern "js" charset: String;
    #[getter]
    #[setter]
    extern "js" app: Application;
    #[getter]
    #[setter]
    extern "js" req: Request;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
    #[getter]
    #[setter]
    extern "js" mimeType: String;
    #[getter]
    #[setter]
    extern "js" charset: String;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: JsArray<Buffer>;

    // property (readonly)
    extern "js" fn clone(self) -> fn() -> Response;
    // property (readonly)
    extern "js" fn redirected(self) -> bool;
    // property (readonly)
    extern "js" fn status(self) -> f64;
    // property (readonly)
    extern "js" fn statusText(self) -> String;
    // property (readonly)
    extern "js" fn ok(self) -> bool;
    extern "js" fn new(body: Option<JsValue>, init: Option<ResponseInit>) -> Response;
    // property (readonly)
    extern "js" fn type_(self) -> String;
    // property (readonly)
    extern "js" fn url(self) -> String;
    // property (readonly)
    extern "js" fn headers(self) -> Headers;
    extern "js" fn error() -> Response;
    extern "js" fn json(data: JsValue, init: Option<ResponseInit>) -> Response;
    extern "js" fn redirect(url: JsValue, status: f64) -> Response;
}

impl ResponseContentLengthMismatchError {
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
}

impl ResponseData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" body: BodyReadable;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl ResponseError {
    // property getter
    extern "js" fn code(self) -> String;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn statusCode(self) -> f64;
    extern "js" fn new(message: String, code: f64, options: JsValue) -> ResponseError;
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    // property getter
    extern "js" fn body(self) -> JsValue;
    // property setter
    extern "js" fn set_body(self, value: JsValue);
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_headers(self, value: JsValue);
    // property getter
    extern "js" fn headers(self) -> JsValue;
}

impl ResponseExceededMaxSizeError {
    // property setter
    extern "js" fn set_code(self, value: String);
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn code(self) -> String;
}

impl ResponseInit {
    #[getter]
    extern "js" status: Option<f64>;
    #[getter]
    extern "js" statusText: Option<String>;
    #[getter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    extern "js" status: Option<f64>;
    #[getter]
    extern "js" statusText: Option<String>;
    #[getter]
    extern "js" headers: Option<JsValue>;
}

impl ResponseReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" response: Response;
}

impl RestartFrameParameterType {
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
}

impl RestartFrameReturnType {
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
}

impl RetryAgent {
    extern "js" fn new(dispatcher: Dispatcher, options: Option<RetryOptions>) -> RetryAgent;
}

impl RetryHandler {
    extern "js" fn new(options: DispatchOptions, retryHandlers: RetryHandlers) -> RetryHandler;
}

impl RetryHandlers {
    #[getter]
    #[setter]
    extern "js" dispatch: JsValue;
    #[getter]
    #[setter]
    extern "js" handler: DispatchHandler;
}

impl RetryOptions {
    #[getter]
    #[setter]
    extern "js" throwOnError: Option<bool>;
    #[getter]
    #[setter]
    extern "js" retry: Option<fn(JsValue, JsValue, fn(Option<JsValue>) -> ()) -> ()>;
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" minTimeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" timeoutFactor: Option<f64>;
    #[getter]
    #[setter]
    extern "js" retryAfter: Option<bool>;
    #[getter]
    #[setter]
    extern "js" methods: Option<JsArray<JsValue>>;
    #[getter]
    #[setter]
    extern "js" errorCodes: Option<JsArray<String>>;
    #[getter]
    #[setter]
    extern "js" statusCodes: Option<JsArray<f64>>;
}

impl RmDirOptions {
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" retryDelay: Option<Option<f64>>;
}

impl RmOptions {
    #[getter]
    #[setter]
    extern "js" force: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxRetries: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" retryDelay: Option<Option<f64>>;
}

impl RouterOptions {
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mergeParams: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" strict: Option<Option<bool>>;
}

impl RsaHashedImportParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
}

impl RsaHashedKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" hash: KeyAlgorithm;
}

impl RsaHashedKeyGenParams {
    #[getter]
    #[setter]
    extern "js" hash: JsValue;
}

impl RsaKeyAlgorithm {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
}

impl RsaKeyGenParams {
    #[getter]
    #[setter]
    extern "js" modulusLength: f64;
    #[getter]
    #[setter]
    extern "js" publicExponent: JsValue;
}

impl RsaOaepParams {
    #[getter]
    #[setter]
    extern "js" label: Option<JsValue>;
}

impl RsaOtherPrimesInfo {
    #[getter]
    #[setter]
    extern "js" d: Option<String>;
    #[getter]
    #[setter]
    extern "js" r: Option<String>;
    #[getter]
    #[setter]
    extern "js" t: Option<String>;
}

impl RsaPrivateKey {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" oaepHash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" oaepLabel: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
}

impl RsaPssParams {
    #[getter]
    #[setter]
    extern "js" saltLength: f64;
}

impl RsaPublicKey {
    #[getter]
    #[setter]
    extern "js" key: JsValue;
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
}

impl RunOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cwd: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" files: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" forceExit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" globPatterns: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" inspectPort: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" isolation: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setup: Option<Option<fn(TestsStream) -> JsValue>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" argv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" testNamePatterns: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" testSkipPatterns: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" watch: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" shard: Option<Option<TestShard>>;
    #[getter]
    #[setter]
    extern "js" rerunFailuresFilePath: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" coverage: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" coverageExcludeGlobs: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" coverageIncludeGlobs: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" lineCoverage: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" branchCoverage: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" functionCoverage: Option<Option<f64>>;
}

impl RunScriptParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" executionContextId: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectGroup: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" silent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" includeCommandLineAPI: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" returnByValue: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatePreview: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" awaitPromise: Option<Option<bool>>;
}

impl RunScriptReturnType {
    #[getter]
    #[setter]
    extern "js" result: RemoteObject;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl RunningCodeInNewContextOptions {
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl RunningCodeOptions {
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl RunningScriptInNewContextOptions {
    #[getter]
    #[setter]
    extern "js" contextName: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextOrigin: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" contextCodeGeneration: Option<Option<JsValue>>;
}

impl RunningScriptOptions {
    #[getter]
    #[setter]
    extern "js" displayErrors: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" breakOnSigint: Option<Option<bool>>;
}

impl SLHDSAKeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl SQLTagStore {
    #[getter]
    extern "js" capacity: f64;
    #[getter]
    extern "js" db: DatabaseSync;

    extern "js" fn size(self) -> f64;
    extern "js" fn run(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> StatementResultingChanges;
    extern "js" fn clear(self);
    extern "js" fn get(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> Option<JsValue>;
    extern "js" fn all(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> JsArray<JsValue>;
    extern "js" fn iterate(self, stringElements: JsValue, boundParameters: JsArray<JsValue>) -> Iterator<JsValue>;
}

impl SamplingHeapProfile {
    #[getter]
    #[setter]
    extern "js" head: SamplingHeapProfileNode;
}

impl SamplingHeapProfileNode {
    #[getter]
    #[setter]
    extern "js" callFrame: CallFrame;
    #[getter]
    #[setter]
    extern "js" selfSize: f64;
    #[getter]
    #[setter]
    extern "js" children: JsArray<SamplingHeapProfileNode>;
}

impl Scheduler {
    extern "js" fn wait(self, delay: f64, options: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn yield(self) -> JsPromise<()>;
}

impl Scope {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" object: RemoteObject;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" startLocation: Option<Option<Location>>;
    #[getter]
    #[setter]
    extern "js" endLocation: Option<Option<Location>>;
}

impl Script {
    // property setter
    extern "js" fn set_cachedData(self, value: Option<JsValue>);
    // property getter
    extern "js" fn sourceMapURL(self) -> Option<String>;
    extern "js" fn createCachedData(self) -> JsValue;
    // property getter
    extern "js" fn cachedDataProduced(self) -> Option<bool>;
    extern "js" fn runInNewContext(self, contextObject: Option<JsValue>, options: Option<RunningScriptInNewContextOptions>) -> JsValue;
    extern "js" fn new(code: String, options: Option<JsValue>) -> Script;
    // property getter
    extern "js" fn cachedDataRejected(self) -> Option<bool>;
    // property setter
    extern "js" fn set_cachedDataRejected(self, value: Option<bool>);
    // property setter
    extern "js" fn set_sourceMapURL(self, value: Option<String>);
    // property setter
    extern "js" fn set_cachedDataProduced(self, value: Option<bool>);
    // property getter
    extern "js" fn cachedData(self) -> Option<JsValue>;
    extern "js" fn runInThisContext(self, options: Option<RunningScriptOptions>) -> JsValue;
    extern "js" fn runInContext(self, contextifiedObject: Context, options: Option<RunningScriptOptions>) -> JsValue;
}

impl ScriptCoverage {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" functions: JsArray<FunctionCoverage>;
}

impl ScriptFailedToParseEventDataType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" startLine: f64;
    #[getter]
    #[setter]
    extern "js" startColumn: f64;
    #[getter]
    #[setter]
    extern "js" endLine: f64;
    #[getter]
    #[setter]
    extern "js" endColumn: f64;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" executionContextAuxData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" sourceMapURL: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hasSourceURL: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isModule: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
}

impl ScriptOptions {
    #[getter]
    #[setter]
    extern "js" cachedData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" produceCachedData: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<JsValue>;
}

impl ScriptParsedEventDataType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" startLine: f64;
    #[getter]
    #[setter]
    extern "js" startColumn: f64;
    #[getter]
    #[setter]
    extern "js" endLine: f64;
    #[getter]
    #[setter]
    extern "js" endColumn: f64;
    #[getter]
    #[setter]
    extern "js" executionContextId: f64;
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" executionContextAuxData: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" isLiveEdit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" sourceMapURL: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hasSourceURL: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isModule: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stackTrace: Option<Option<StackTrace>>;
}

impl ScriptPosition {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl ScryptOptions {
    #[getter]
    #[setter]
    extern "js" cost: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" parallelization: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" N: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" r: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" p: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxmem: Option<Option<f64>>;
}

impl SearchInContentParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" query: String;
    #[getter]
    #[setter]
    extern "js" caseSensitive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" isRegex: Option<Option<bool>>;
}

impl SearchInContentReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<SearchMatch>;
}

impl SearchMatch {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" lineContent: String;
}

impl SecureContext {
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl SecureContextOptions {
    #[getter]
    #[setter]
    extern "js" ALPNCallback: Option<Option<fn(JsValue) -> Option<String>>>;
    #[getter]
    #[setter]
    extern "js" allowPartialTrustChain: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ca: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" cert: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sigalgs: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ciphers: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" clientCertEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" crl: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dhparam: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" ecdhCurve: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" honorCipherOrder: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" key: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" privateKeyEngine: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" privateKeyIdentifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" maxVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" minVersion: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" passphrase: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pfx: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" secureOptions: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" secureProtocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" sessionIdContext: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
}

impl SecureHeapUsage {
    #[getter]
    #[setter]
    extern "js" total: f64;
    #[getter]
    #[setter]
    extern "js" min: f64;
    #[getter]
    #[setter]
    extern "js" used: f64;
    #[getter]
    #[setter]
    extern "js" utilization: f64;
}

impl SecureProxyConnectionError {
    extern "js" fn new(cause: Option<JsValue>, message: Option<String>, options: Option<JsValue>) -> SecureProxyConnectionError;
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
    // property setter
    extern "js" fn set_code(self, value: String);
}

impl SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
    #[getter]
    #[setter]
    extern "js" allowHTTP1: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" origins: Option<Option<JsArray<String>>>;
}

impl SendFileOptions {
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl SendMessageToWorkerParameterType {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" sessionId: String;
}

impl Serializer {
    extern "js" fn writeHeader(self);
    extern "js" fn writeRawBytes(self, buffer: JsValue);
    extern "js" fn writeDouble(self, value: f64);
    extern "js" fn transferArrayBuffer(self, id: f64, arrayBuffer: JsValue);
    extern "js" fn writeUint64(self, hi: f64, lo: f64);
    extern "js" fn releaseBuffer(self) -> JsValue;
    extern "js" fn writeValue(self, val: JsValue) -> bool;
    extern "js" fn writeUint32(self, value: f64);
}

impl ServeStaticOptions<R> {
    #[getter]
    #[setter]
    extern "js" acceptRanges: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" cacheControl: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" dotfiles: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" etag: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" extensions: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" fallthrough: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" immutable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" index: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" lastModified: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxAge: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" setHeaders: Option<Option<fn(R, String, JsValue) -> JsValue>>;
}

impl Server<Request, Response> {
    // merged from 12 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 12 overloads
    extern "js" fn emit(self, event: String, req: Option<JsValue>, socket: Option<Duplex>, head: Option<JsValue>) -> bool;
    // property getter
    extern "js" fn keepAliveTimeout(self) -> f64;
    // property getter
    extern "js" fn requestTimeout(self) -> f64;
    // property setter
    extern "js" fn set_maxRequestsPerSocket(self, value: Option<f64>);
    extern "js" fn closeAllConnections(self);
    // property getter
    extern "js" fn maxHeadersCount(self) -> Option<f64>;
    // property setter
    extern "js" fn set_keepAliveTimeout(self, value: f64);
    // property setter
    extern "js" fn set_timeout(self, value: f64);
    // property getter
    extern "js" fn timeout(self) -> f64;
    // merged from 12 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // property getter
    extern "js" fn headersTimeout(self) -> f64;
    // property getter
    extern "js" fn maxRequestsPerSocket(self) -> Option<f64>;
    // merged from 12 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 12 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // property setter
    extern "js" fn set_requestTimeout(self, value: f64);
    // property setter
    extern "js" fn set_headersTimeout(self, value: f64);
    // merged from 2 overloads
    extern "js" fn setTimeout(self, msecs: Option<f64>, callback: Option<fn(Socket) -> ()>) -> Server;
    // merged from 12 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Server;
    // merged from 2 overloads
    extern "js" fn new<Request, Response>(options: ServerOptions<Request, Response>, requestListener: Option<fn(JsValue, JsValue) -> ()>) -> Server;
    // property getter
    extern "js" fn keepAliveTimeoutBuffer(self) -> f64;
    extern "js" fn closeIdleConnections(self);
    // property setter
    extern "js" fn set_maxHeadersCount(self, value: Option<f64>);
    // property setter
    extern "js" fn set_keepAliveTimeoutBuffer(self, value: f64);
}

impl ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response> {
    #[getter]
    extern "js" server: JsValue;

    // merged from 3 overloads
    extern "js" fn emit(self, event: String, stream: ServerHttp2Stream, headers: Option<IncomingHttpHeaders>, flags: Option<f64>, rawHeaders: Option<JsArray<String>>) -> bool;
    // merged from 3 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>, JsValue) -> ()) -> ServerHttp2Session;
    // merged from 3 overloads
    extern "js" fn on(self, event: String, listener: fn(ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>, JsValue) -> ()) -> ServerHttp2Session;
    extern "js" fn altsvc(self, alt: String, originOrStream: JsValue);
    // merged from 3 overloads
    extern "js" fn once(self, event: String, listener: fn(ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>, JsValue) -> ()) -> ServerHttp2Session;
    extern "js" fn origin(self, origins: JsArray<JsValue>);
    // merged from 3 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>, JsValue) -> ()) -> ServerHttp2Session;
    // merged from 3 overloads
    extern "js" fn addListener(self, event: String, listener: fn(ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>, JsValue) -> ()) -> ServerHttp2Session;
}

impl ServerHttp2Stream {
    #[getter]
    extern "js" headersSent: bool;
    #[getter]
    extern "js" pushAllowed: bool;

    extern "js" fn respondWithFD(self, fd: JsValue, headers: Option<OutgoingHttpHeaders>, options: Option<ServerStreamFileResponseOptions>);
    extern "js" fn respondWithFile(self, path: String, headers: Option<OutgoingHttpHeaders>, options: Option<ServerStreamFileResponseOptionsWithError>);
    extern "js" fn respond(self, headers: Option<JsValue>, options: Option<ServerStreamResponseOptions>);
    extern "js" fn additionalHeaders(self, headers: OutgoingHttpHeaders);
    // merged from 2 overloads
    extern "js" fn pushStream(self, headers: OutgoingHttpHeaders, options: Option<JsValue>, callback: Option<fn(Option<JsValue>, ServerHttp2Stream, OutgoingHttpHeaders) -> ()>);
}

impl ServerOptions<Request, Response> {
    #[getter]
    #[setter]
    extern "js" IncomingMessage: Option<Option<Request>>;
    #[getter]
    #[setter]
    extern "js" ServerResponse: Option<Option<Response>>;
    #[getter]
    #[setter]
    extern "js" requestTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" joinDuplicateHeaders: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" keepAliveTimeoutBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" connectionsCheckingInterval: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" headersTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" insecureHTTPParser: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" requireHostHeader: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" uniqueHeaders: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" shouldUpgradeCallback: Option<Option<fn(JsValue) -> bool>>;
    #[getter]
    #[setter]
    extern "js" rejectNonStandardBodyWrites: Option<Option<bool>>;
}

impl ServerOpts {
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" pauseOnConnect: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockList: Option<Option<BlockList>>;
}

impl ServerResponse<Request> {
    extern "js" fn assignSocket(self, socket: Socket);
    // property setter
    extern "js" fn set_strictContentLength(self, value: bool);
    // property getter
    extern "js" fn strictContentLength(self) -> bool;
    // property getter
    extern "js" fn statusCode(self) -> f64;
    // property getter
    extern "js" fn statusMessage(self) -> String;
    // property setter
    extern "js" fn set_statusMessage(self, value: String);
    // property setter
    extern "js" fn set_statusCode(self, value: f64);
    extern "js" fn new<Request>(req: Request) -> ServerResponse;
    extern "js" fn detachSocket(self, socket: Socket);
    extern "js" fn writeContinue(self, callback: Option<fn() -> ()>);
    // merged from 2 overloads
    extern "js" fn writeHead(self, statusCode: f64, statusMessage: Option<String>, headers: Option<JsValue>) -> ServerResponse;
    extern "js" fn writeProcessing(self, callback: Option<fn() -> ()>);
    extern "js" fn writeEarlyHints(self, hints: JsValue, callback: Option<fn() -> ()>);
}

impl ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
    #[getter]
    #[setter]
    extern "js" streamResetBurst: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" streamResetRate: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" Http1IncomingMessage: Option<Option<Http1Request>>;
    #[getter]
    #[setter]
    extern "js" Http1ServerResponse: Option<Option<Http1Response>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerRequest: Option<Option<Http2Request>>;
    #[getter]
    #[setter]
    extern "js" Http2ServerResponse: Option<Option<Http2Response>>;
}

impl ServerStreamFileResponseOptions {
    #[getter]
    #[setter]
    extern "js" statCheck: Option<Option<fn(Stats, OutgoingHttpHeaders, StatOptions) -> ()>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
}

impl ServerStreamFileResponseOptionsWithError {
    #[getter]
    #[setter]
    extern "js" onError: Option<Option<fn(ErrnoException) -> ()>>;
}

impl ServerStreamResponseOptions {
    #[getter]
    #[setter]
    extern "js" endStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" waitForTrailers: Option<Option<bool>>;
}

impl Session {
    extern "js" fn connect(self);
    extern "js" fn disconnect(self);
    extern "js" fn new() -> Session;
    extern "js" fn connectToMainThread(self);
}

impl SessionOptions {
    #[getter]
    #[setter]
    extern "js" maxDeflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSettings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSessionMemory: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListPairs: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxOutstandingPings: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxSendHeaderBlockLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" paddingStrategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" peerMaxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" settings: Option<Option<Settings>>;
    #[getter]
    #[setter]
    extern "js" remoteCustomSettings: Option<Option<JsArray<f64>>>;
    #[getter]
    #[setter]
    extern "js" unknownProtocolTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strictFieldWhitespaceValidation: Option<Option<bool>>;
}

impl SessionState {
    #[getter]
    #[setter]
    extern "js" effectiveLocalWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" effectiveRecvDataLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" nextStreamID: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" localWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lastProcStreamID: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" remoteWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" outboundQueueSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" deflateDynamicTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" inflateDynamicTableSize: Option<Option<f64>>;
}

impl SetAsyncCallStackDepthParameterType {
    #[getter]
    #[setter]
    extern "js" maxDepth: f64;
}

impl SetAutoAttachParameterType {
    #[getter]
    #[setter]
    extern "js" autoAttach: bool;
    #[getter]
    #[setter]
    extern "js" waitForDebuggerOnStart: bool;
}

impl SetBlackboxPatternsParameterType {
    #[getter]
    #[setter]
    extern "js" patterns: JsArray<String>;
}

impl SetBlackboxedRangesParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" positions: JsArray<ScriptPosition>;
}

impl SetBreakpointByUrlParameterType {
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" url: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" urlRegex: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" scriptHash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" columnNumber: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" condition: Option<Option<String>>;
}

impl SetBreakpointByUrlReturnType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" locations: JsArray<Location>;
}

impl SetBreakpointParameterType {
    #[getter]
    #[setter]
    extern "js" location: Location;
    #[getter]
    #[setter]
    extern "js" condition: Option<Option<String>>;
}

impl SetBreakpointReturnType {
    #[getter]
    #[setter]
    extern "js" breakpointId: String;
    #[getter]
    #[setter]
    extern "js" actualLocation: Location;
}

impl SetBreakpointsActiveParameterType {
    #[getter]
    #[setter]
    extern "js" active: bool;
}

impl SetCustomObjectFormatterEnabledParameterType {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
}

impl SetPauseOnExceptionsParameterType {
    #[getter]
    #[setter]
    extern "js" state: String;
}

impl SetReturnValueParameterType {
    #[getter]
    #[setter]
    extern "js" newValue: CallArgument;
}

impl SetSamplingIntervalParameterType {
    #[getter]
    #[setter]
    extern "js" interval: f64;
}

impl SetScriptSourceParameterType {
    #[getter]
    #[setter]
    extern "js" scriptId: String;
    #[getter]
    #[setter]
    extern "js" scriptSource: String;
    #[getter]
    #[setter]
    extern "js" dryRun: Option<Option<bool>>;
}

impl SetScriptSourceReturnType {
    #[getter]
    #[setter]
    extern "js" callFrames: Option<Option<JsArray<CallFrame>>>;
    #[getter]
    #[setter]
    extern "js" stackChanged: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTrace: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" asyncStackTraceId: Option<Option<StackTraceId>>;
    #[getter]
    #[setter]
    extern "js" exceptionDetails: Option<Option<ExceptionDetails>>;
}

impl SetSkipAllPausesParameterType {
    #[getter]
    #[setter]
    extern "js" skip: bool;
}

impl SetSourceMapsSupportOptions {
    #[getter]
    #[setter]
    extern "js" nodeModules: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" generatedCode: Option<Option<bool>>;
}

impl SetVariableValueParameterType {
    #[getter]
    #[setter]
    extern "js" scopeNumber: f64;
    #[getter]
    #[setter]
    extern "js" variableName: String;
    #[getter]
    #[setter]
    extern "js" newValue: CallArgument;
    #[getter]
    #[setter]
    extern "js" callFrameId: String;
}

impl Settings {
    #[getter]
    #[setter]
    extern "js" headerTableSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" enablePush: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" initialWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxFrameSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxConcurrentStreams: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxHeaderListSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" enableConnectProtocol: Option<Option<bool>>;
}

impl Sign {
    extern "js" fn new() -> Sign;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Sign;
    // merged from 2 overloads
    extern "js" fn sign(self, privateKey: JsValue, outputFormat: Option<String>) -> String;
}

impl SignKeyObjectInput {
    #[getter]
    #[setter]
    extern "js" key: KeyObject;
}

impl SigningOptions {
    #[getter]
    #[setter]
    extern "js" padding: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" saltLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dsaEncoding: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<JsValue>;
}

impl Snapshot {
    #[getter]
    #[setter]
    extern "js" request: JsValue;
    #[getter]
    #[setter]
    extern "js" responses: JsArray<JsValue>;
    #[getter]
    #[setter]
    extern "js" callCount: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: String;
}

impl SnapshotAgent {
    extern "js" fn clearSnapshots(self);
    extern "js" fn getRecorder(self) -> SnapshotRecorder;
    extern "js" fn loadSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn new(options: Option<Options>) -> SnapshotAgent;
    extern "js" fn getMode(self) -> String;
    extern "js" fn saveSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn deleteSnapshot(self, requestOpts: JsValue) -> bool;
    extern "js" fn resetCallCounts(self);
    extern "js" fn getSnapshotInfo(self, requestOpts: JsValue) -> Option<SnapshotInfo>;
    extern "js" fn replaceSnapshots(self, snapshotData: JsArray<SnapshotData>);
}

impl SnapshotData {
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" snapshot: Snapshot;
}

impl SnapshotInfo {
    #[getter]
    #[setter]
    extern "js" hash: String;
    #[getter]
    #[setter]
    extern "js" request: JsValue;
    #[getter]
    #[setter]
    extern "js" responseCount: f64;
    #[getter]
    #[setter]
    extern "js" callCount: f64;
    #[getter]
    #[setter]
    extern "js" timestamp: String;
}

impl SnapshotRecorder {
    extern "js" fn clear(self);
    extern "js" fn record(self, requestOpts: JsValue, response: JsValue) -> JsPromise<()>;
    extern "js" fn getSnapshots(self) -> JsArray<Snapshot>;
    extern "js" fn resetCallCounts(self);
    extern "js" fn deleteSnapshot(self, requestOpts: JsValue) -> bool;
    extern "js" fn loadSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn destroy(self);
    extern "js" fn replaceSnapshots(self, snapshotData: JsArray<SnapshotData>);
    extern "js" fn new(options: Option<Options>) -> SnapshotRecorder;
    extern "js" fn saveSnapshots(self, filePath: Option<String>) -> JsPromise<()>;
    extern "js" fn size(self) -> f64;
    extern "js" fn getSnapshotInfo(self, requestOpts: JsValue) -> Option<SnapshotInfo>;
    extern "js" fn findSnapshot(self, requestOpts: JsValue) -> Option<Snapshot>;
}

impl SoaRecord {
    #[getter]
    #[setter]
    extern "js" nsname: String;
    #[getter]
    #[setter]
    extern "js" hostmaster: String;
    #[getter]
    #[setter]
    extern "js" serial: f64;
    #[getter]
    #[setter]
    extern "js" refresh: f64;
    #[getter]
    #[setter]
    extern "js" retry: f64;
    #[getter]
    #[setter]
    extern "js" expire: f64;
    #[getter]
    #[setter]
    extern "js" minttl: f64;
}

impl Socket {
    #[getter]
    #[setter]
    extern "js" isTTY: Option<Option<bool>>;

    extern "js" fn setSendBufferSize(self, size: f64);
    // merged from 6 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn close(self, callback: Option<fn() -> ()>) -> Socket;
    // merged from 6 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn addMembership(self, multicastAddress: String, multicastInterface: Option<String>);
    extern "js" fn address(self) -> AddressInfo;
    // merged from 6 overloads
    extern "js" fn send(self, msg: JsValue, offset: f64, length: Option<f64>, port: Option<f64>, address: Option<String>, callback: Option<fn(Option<JsValue>, f64) -> ()>);
    extern "js" fn setRecvBufferSize(self, size: f64);
    extern "js" fn dropSourceSpecificMembership(self, sourceAddress: String, groupAddress: String, multicastInterface: Option<String>);
    extern "js" fn setMulticastLoopback(self, flag: bool) -> bool;
    extern "js" fn remoteAddress(self) -> AddressInfo;
    extern "js" fn addSourceSpecificMembership(self, sourceAddress: String, groupAddress: String, multicastInterface: Option<String>);
    extern "js" fn setTTL(self, ttl: f64) -> f64;
    // merged from 6 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn getSendQueueCount(self) -> f64;
    extern "js" fn unref(self) -> Socket;
    // merged from 6 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn setMulticastTTL(self, ttl: f64) -> f64;
    // merged from 4 overloads
    extern "js" fn bind(self, port: Option<f64>, address: Option<String>, callback: Option<fn() -> ()>) -> Socket;
    extern "js" fn disconnect(self);
    extern "js" fn getRecvBufferSize(self) -> f64;
    extern "js" fn getSendQueueSize(self) -> f64;
    // merged from 6 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Socket;
    extern "js" fn setBroadcast(self, flag: bool);
    // merged from 2 overloads
    extern "js" fn connect(self, port: f64, address: Option<String>, callback: Option<fn() -> ()>);
    // merged from 6 overloads
    extern "js" fn emit(self, event: String, msg: Option<JsValue>, rinfo: Option<RemoteInfo>) -> bool;
    extern "js" fn ref(self) -> Socket;
    extern "js" fn getSendBufferSize(self) -> f64;
    extern "js" fn setMulticastInterface(self, multicastInterface: String);
    extern "js" fn dropMembership(self, multicastAddress: String, multicastInterface: Option<String>);
}

impl SocketAddress {
    // property (readonly)
    extern "js" fn address(self) -> String;
    // property (readonly)
    extern "js" fn flowlabel(self) -> f64;
    // property (readonly)
    extern "js" fn port(self) -> f64;
    // property (readonly)
    extern "js" fn family(self) -> String;
    extern "js" fn new(options: SocketAddressInitOptions) -> SocketAddress;
    extern "js" fn parse(input: String) -> Option<SocketAddress>;
}

impl SocketAddressInitOptions {
    #[getter]
    #[setter]
    extern "js" address: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" flowlabel: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" port: Option<Option<f64>>;
}

impl SocketConstructorOpts {
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" allowHalfOpen: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" onread: Option<Option<OnReadOpts>>;
    #[getter]
    #[setter]
    extern "js" readable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" writable: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl SocketError {
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_socket(self, value: Option<SocketInfo>);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn name(self) -> String;
    // property getter
    extern "js" fn socket(self) -> Option<SocketInfo>;
    // property getter
    extern "js" fn code(self) -> String;
}

impl SocketInfo {
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesWritten: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesRead: Option<f64>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteAddress: Option<String>;
    #[getter]
    #[setter]
    extern "js" remotePort: Option<f64>;
    #[getter]
    #[setter]
    extern "js" remoteFamily: Option<String>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesWritten: Option<f64>;
    #[getter]
    #[setter]
    extern "js" bytesRead: Option<f64>;
}

impl SocketOptions {
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" reuseAddr: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" reusePort: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" ipv6Only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recvBufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sendBufferSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOneOptions, fn(Option<ErrnoException>, String, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" receiveBlockList: Option<Option<BlockList>>;
    #[getter]
    #[setter]
    extern "js" sendBlockList: Option<Option<BlockList>>;
}

impl SourceMap {
    extern "js" fn findOrigin(self, lineNumber: f64, columnNumber: f64) -> JsValue;
    extern "js" fn new(payload: SourceMapPayload, options: Option<SourceMapConstructorOptions>) -> SourceMap;
    // property (readonly)
    extern "js" fn payload(self) -> SourceMapPayload;
    extern "js" fn findEntry(self, lineOffset: f64, columnOffset: f64) -> JsValue;
}

impl SourceMapConstructorOptions {
    #[getter]
    #[setter]
    extern "js" lineLengths: Option<Option<JsArray<f64>>>;
}

impl SourceMapPayload {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" version: f64;
    #[getter]
    #[setter]
    extern "js" sources: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" sourcesContent: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" names: JsArray<String>;
    #[getter]
    #[setter]
    extern "js" mappings: String;
    #[getter]
    #[setter]
    extern "js" sourceRoot: String;
}

impl SourceMapping {
    #[getter]
    #[setter]
    extern "js" generatedLine: f64;
    #[getter]
    #[setter]
    extern "js" generatedColumn: f64;
    #[getter]
    #[setter]
    extern "js" originalSource: String;
    #[getter]
    #[setter]
    extern "js" originalLine: f64;
    #[getter]
    #[setter]
    extern "js" originalColumn: f64;
}

impl SourceMapsSupport {
    #[getter]
    #[setter]
    extern "js" enabled: bool;
    #[getter]
    #[setter]
    extern "js" nodeModules: bool;
    #[getter]
    #[setter]
    extern "js" generatedCode: bool;
}

impl SourceOrigin {
    #[getter]
    #[setter]
    extern "js" name: Option<String>;
    #[getter]
    #[setter]
    extern "js" fileName: String;
    #[getter]
    #[setter]
    extern "js" lineNumber: f64;
    #[getter]
    #[setter]
    extern "js" columnNumber: f64;
}

impl SourceTextModule {
    extern "js" fn hasTopLevelAwait(self) -> bool;
    // property (readonly)
    extern "js" fn moduleRequests(self) -> JsArray<ModuleRequest>;
    // property (readonly)
    extern "js" fn dependencySpecifiers(self) -> JsArray<String>;
    extern "js" fn linkRequests(self, modules: JsArray<Module>);
    extern "js" fn hasAsyncGraph(self) -> bool;
    extern "js" fn instantiate(self);
    extern "js" fn new(code: String, options: Option<SourceTextModuleOptions>) -> SourceTextModule;
}

impl SourceTextModuleOptions {
    #[getter]
    #[setter]
    extern "js" identifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<Context>>;
    #[getter]
    #[setter]
    extern "js" initializeImportMeta: Option<Option<fn(ImportMeta, SourceTextModule) -> ()>>;
    #[getter]
    #[setter]
    extern "js" importModuleDynamically: Option<Option<fn(String, JsValue, ImportAttributes, JsValue) -> JsValue>>;
}

impl SpawnOptions {
    #[getter]
    #[setter]
    extern "js" detached: Option<Option<bool>>;
}

impl SpawnOptionsWithStdioTuple<Stdin, Stdout, Stderr> {
    #[getter]
    #[setter]
    extern "js" stdio: (Stdin, Stdout, Stderr);
}

impl SpawnOptionsWithoutStdio {
    #[getter]
    #[setter]
    extern "js" stdio: Option<JsValue>;
}

impl SpawnSyncOptions {
    #[getter]
    #[setter]
    extern "js" input: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" maxBuffer: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
}

impl SpawnSyncOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<String>>;
}

impl SpawnSyncOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: JsValue;
}

impl SpawnSyncReturns<T> {
    #[getter]
    #[setter]
    extern "js" pid: f64;
    #[getter]
    #[setter]
    extern "js" output: JsArray<Option<T>>;
    #[getter]
    #[setter]
    extern "js" stdout: T;
    #[getter]
    #[setter]
    extern "js" stderr: T;
    #[getter]
    #[setter]
    extern "js" status: Option<f64>;
    #[getter]
    #[setter]
    extern "js" signal: Option<String>;
    #[getter]
    #[setter]
    extern "js" error: Option<JsValue>;
}

impl SpecIterator<T, TReturn, TNext> {
    extern "js" fn next(self, args: JsValue) -> JsValue;
}

impl SpecReporter {
    extern "js" fn new() -> SpecReporter;
}

impl SqliteCacheStore {
    extern "js" fn get(self, key: CacheKey) -> JsValue;
    extern "js" fn createWriteStream(self, key: CacheKey, value: CacheValue) -> Option<Writable>;
    extern "js" fn delete(self, key: CacheKey) -> JsValue;
    extern "js" fn new(opts: Option<SqliteCacheStoreOpts>) -> SqliteCacheStore;
    extern "js" fn close(self);
}

impl SqliteCacheStoreOpts {
    #[getter]
    #[setter]
    extern "js" location: Option<String>;
    #[getter]
    #[setter]
    extern "js" maxCount: Option<f64>;
    #[getter]
    #[setter]
    extern "js" maxEntrySize: Option<f64>;
}

impl SrvRecord {
    #[getter]
    #[setter]
    extern "js" priority: f64;
    #[getter]
    #[setter]
    extern "js" weight: f64;
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" name: String;
}

impl StackTrace {
    #[getter]
    #[setter]
    extern "js" description: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" callFrames: JsArray<CallFrame>;
    #[getter]
    #[setter]
    extern "js" parent: Option<Option<StackTrace>>;
    #[getter]
    #[setter]
    extern "js" parentId: Option<Option<StackTraceId>>;
}

impl StackTraceId {
    #[getter]
    #[setter]
    extern "js" id: String;
    #[getter]
    #[setter]
    extern "js" debuggerId: Option<Option<String>>;
}

impl StartParameterType {
    #[getter]
    #[setter]
    extern "js" traceConfig: TraceConfig;
}

impl StartPreciseCoverageParameterType {
    #[getter]
    #[setter]
    extern "js" callCount: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" detailed: Option<Option<bool>>;
}

impl StartSamplingParameterType {
    #[getter]
    #[setter]
    extern "js" samplingInterval: Option<Option<f64>>;
}

impl StartTrackingHeapObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" trackAllocations: Option<Option<bool>>;
}

impl StatFsOptions {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl StatOptions {
    #[getter]
    #[setter]
    extern "js" offset: f64;
    #[getter]
    #[setter]
    extern "js" length: f64;
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
}

impl StatSyncOptions {
    #[getter]
    #[setter]
    extern "js" throwIfNoEntry: Option<Option<bool>>;
}

impl StatWatcher {
    extern "js" fn ref(self) -> StatWatcher;
    extern "js" fn unref(self) -> StatWatcher;
}

impl StatementColumnMetadata {
    #[getter]
    #[setter]
    extern "js" column: Option<String>;
    #[getter]
    #[setter]
    extern "js" database: Option<String>;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" table: Option<String>;
    #[getter]
    #[setter]
    extern "js" type_: Option<String>;
}

impl StatementResultingChanges {
    #[getter]
    #[setter]
    extern "js" changes: JsValue;
    #[getter]
    #[setter]
    extern "js" lastInsertRowid: JsValue;
}

impl StatementSync {
    // property (readonly)
    extern "js" fn expandedSQL(self) -> String;
    // merged from 2 overloads
    extern "js" fn get(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> Option<JsValue>;
    // merged from 2 overloads
    extern "js" fn all(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> JsArray<JsValue>;
    extern "js" fn setAllowBareNamedParameters(self, enabled: bool);
    extern "js" fn columns(self) -> JsArray<StatementColumnMetadata>;
    // merged from 2 overloads
    extern "js" fn run(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> StatementResultingChanges;
    // property (readonly)
    extern "js" fn sourceSQL(self) -> String;
    extern "js" fn setAllowUnknownNamedParameters(self, enabled: bool);
    extern "js" fn setReturnArrays(self, enabled: bool);
    extern "js" fn setReadBigInts(self, enabled: bool);
    extern "js" fn new() -> StatementSync;
    // merged from 2 overloads
    extern "js" fn iterate(self, namedParameters: JsValue, anonymousParameters: Option<JsArray<JsValue>>) -> Iterator<JsValue>;
}

impl StaticEventEmitterIteratorOptions {
    #[getter]
    #[setter]
    extern "js" close: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lowWaterMark: Option<Option<f64>>;
}

impl StaticEventEmitterOptions {
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
}

impl Stats {
    extern "js" fn new() -> Stats;
}

impl StatsBase<T> {
    #[getter]
    #[setter]
    extern "js" dev: T;
    #[getter]
    #[setter]
    extern "js" ino: T;
    #[getter]
    #[setter]
    extern "js" mode: T;
    #[getter]
    #[setter]
    extern "js" nlink: T;
    #[getter]
    #[setter]
    extern "js" uid: T;
    #[getter]
    #[setter]
    extern "js" gid: T;
    #[getter]
    #[setter]
    extern "js" rdev: T;
    #[getter]
    #[setter]
    extern "js" size: T;
    #[getter]
    #[setter]
    extern "js" blksize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" atimeMs: T;
    #[getter]
    #[setter]
    extern "js" mtimeMs: T;
    #[getter]
    #[setter]
    extern "js" ctimeMs: T;
    #[getter]
    #[setter]
    extern "js" birthtimeMs: T;
    #[getter]
    #[setter]
    extern "js" atime: JsValue;
    #[getter]
    #[setter]
    extern "js" mtime: JsValue;
    #[getter]
    #[setter]
    extern "js" ctime: JsValue;
    #[getter]
    #[setter]
    extern "js" birthtime: JsValue;

    extern "js" fn isFIFO(self) -> bool;
    extern "js" fn isSocket(self) -> bool;
    extern "js" fn isCharacterDevice(self) -> bool;
    extern "js" fn isFile(self) -> bool;
    extern "js" fn isBlockDevice(self) -> bool;
    extern "js" fn isDirectory(self) -> bool;
    extern "js" fn isSymbolicLink(self) -> bool;
}

impl StatsFsBase<T> {
    #[getter]
    #[setter]
    extern "js" type_: T;
    #[getter]
    #[setter]
    extern "js" bsize: T;
    #[getter]
    #[setter]
    extern "js" blocks: T;
    #[getter]
    #[setter]
    extern "js" bfree: T;
    #[getter]
    #[setter]
    extern "js" bavail: T;
    #[getter]
    #[setter]
    extern "js" files: T;
    #[getter]
    #[setter]
    extern "js" ffree: T;
}

impl StepIntoParameterType {
    #[getter]
    #[setter]
    extern "js" breakOnAsyncCall: Option<Option<bool>>;
}

impl StopReturnType {
    #[getter]
    #[setter]
    extern "js" profile: Profile;
}

impl StopSamplingReturnType {
    #[getter]
    #[setter]
    extern "js" profile: SamplingHeapProfile;
}

impl StopTrackingHeapObjectsParameterType {
    #[getter]
    #[setter]
    extern "js" reportProgress: Option<Option<bool>>;
}

impl Storage {
    #[getter]
    extern "js" length: f64;

    extern "js" fn key(self, index: f64) -> Option<String>;
    extern "js" fn clear(self);
    extern "js" fn removeItem(self, key: String);
    extern "js" fn getItem(self, key: String) -> Option<String>;
    extern "js" fn setItem(self, key: String, value: String);
}

impl Stream {
    extern "js" fn pipe(self, destination: T, options: Option<JsValue>) -> T;
    extern "js" fn compose(self, stream: JsValue, options: Option<JsValue>) -> T;
}

impl StreamData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" trailers: JsValue;
}

impl StreamFactoryData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
    #[getter]
    #[setter]
    extern "js" statusCode: f64;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" context: JsValue;
}

impl StreamOptions {
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" objectMode: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" construct: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" destroy: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" autoDestroy: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" flags: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" mode: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" emitClose: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" start: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" highWaterMark: Option<Option<f64>>;
}

impl StreamPipeOptions {
    #[getter]
    #[setter]
    extern "js" preventAbort: Option<bool>;
    #[getter]
    #[setter]
    extern "js" preventCancel: Option<bool>;
    #[getter]
    #[setter]
    extern "js" preventClose: Option<bool>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
}

impl StreamResourceContentParameterType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
}

impl StreamResourceContentReturnType {
    #[getter]
    #[setter]
    extern "js" bufferedData: String;
}

impl StreamState {
    #[getter]
    #[setter]
    extern "js" localWindowSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" state: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" localClose: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" remoteClose: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sumDependencyWeight: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" weight: Option<Option<f64>>;
}

impl StringDecoder {
    extern "js" fn write(self, buffer: JsValue) -> String;
    extern "js" fn end(self, buffer: Option<JsValue>) -> String;
    extern "js" fn new(encoding: Option<JsValue>) -> StringDecoder;
}

impl StringifyOptions {
    #[getter]
    #[setter]
    extern "js" encodeURIComponent: Option<Option<fn(String) -> String>>;
}

impl StripTypeScriptTypesOptions {
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" sourceMap: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" sourceUrl: Option<Option<String>>;
}

impl StyleTextOptions {
    #[getter]
    #[setter]
    extern "js" validateStream: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stream: Option<Option<WritableStream>>;
}

impl SubtleCrypto {
    extern "js" fn sign(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    extern "js" fn encrypt(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    extern "js" fn decapsulateBits(self, decapsulationAlgorithm: JsValue, decapsulationKey: CryptoKey, ciphertext: JsValue) -> JsPromise<JsValue>;
    extern "js" fn encapsulateKey(self, encapsulationAlgorithm: JsValue, encapsulationKey: CryptoKey, sharedKeyAlgorithm: JsValue, extractable: bool, usages: JsArray<String>) -> JsPromise<EncapsulatedKey>;
    extern "js" fn decapsulateKey(self, decapsulationAlgorithm: JsValue, decapsulationKey: CryptoKey, ciphertext: JsValue, sharedKeyAlgorithm: JsValue, extractable: bool, usages: JsArray<String>) -> JsPromise<CryptoKey>;
    extern "js" fn unwrapKey(self, format: String, wrappedKey: JsValue, unwrappingKey: CryptoKey, unwrapAlgorithm: JsValue, unwrappedKeyAlgorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    // merged from 2 overloads
    extern "js" fn exportKey(self, format: String, key: CryptoKey) -> JsPromise<JsonWebKey>;
    extern "js" fn deriveKey(self, algorithm: JsValue, baseKey: CryptoKey, derivedKeyAlgorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    // merged from 2 overloads
    extern "js" fn deriveBits(self, algorithm: EcdhKeyDeriveParams, baseKey: CryptoKey, length: Option<Option<f64>>) -> JsPromise<JsValue>;
    extern "js" fn digest(self, algorithm: JsValue, data: JsValue) -> JsPromise<JsValue>;
    extern "js" fn verify(self, algorithm: JsValue, key: CryptoKey, signature: JsValue, data: JsValue) -> JsPromise<bool>;
    // merged from 3 overloads
    extern "js" fn generateKey(self, algorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKeyPair>;
    extern "js" fn decrypt(self, algorithm: JsValue, key: CryptoKey, data: JsValue) -> JsPromise<JsValue>;
    // merged from 2 overloads
    extern "js" fn importKey(self, format: String, keyData: JsonWebKey, algorithm: JsValue, extractable: bool, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
    extern "js" fn encapsulateBits(self, encapsulationAlgorithm: JsValue, encapsulationKey: CryptoKey) -> JsPromise<EncapsulatedBits>;
    extern "js" fn wrapKey(self, format: String, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: JsValue) -> JsPromise<JsValue>;
    extern "js" fn getPublicKey(self, key: CryptoKey, keyUsages: JsArray<String>) -> JsPromise<CryptoKey>;
}

impl SuiteContext {
    #[getter]
    extern "js" filePath: Option<String>;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" signal: JsValue;
}

impl SyntheticModule {
    extern "js" fn new(exportNames: JsArray<String>, evaluateCallback: JsFn, options: Option<SyntheticModuleOptions>) -> SyntheticModule;
    extern "js" fn setExport(self, name: String, value: JsValue);
}

impl SyntheticModuleOptions {
    #[getter]
    #[setter]
    extern "js" identifier: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" context: Option<Option<Context>>;
}

impl TLSSocket {
    extern "js" fn getPeerX509Certificate(self) -> Option<X509Certificate>;
    // property setter
    extern "js" fn set_encrypted(self, value: bool);
    extern "js" fn getX509Certificate(self) -> Option<X509Certificate>;
    // property setter
    extern "js" fn set_authorized(self, value: bool);
    extern "js" fn getCertificate(self) -> JsValue;
    extern "js" fn getSharedSigalgs(self) -> JsArray<String>;
    // property getter
    extern "js" fn authorizationError(self) -> JsValue;
    extern "js" fn renegotiate(self, options: JsValue, callback: fn(Option<JsValue>) -> ()) -> Option<bool>;
    // merged from 5 overloads
    extern "js" fn emit(self, event: JsValue, args: Option<JsArray<JsValue>>) -> bool;
    extern "js" fn getEphemeralKeyInfo(self) -> JsValue;
    extern "js" fn disableRenegotiation(self);
    extern "js" fn new(socket: JsValue, options: Option<TLSSocketOptions>) -> TLSSocket;
    extern "js" fn exportKeyingMaterial(self, length: f64, label: String, context: Buffer) -> JsValue;
    extern "js" fn getCipher(self) -> CipherNameAndProtocol;
    extern "js" fn isSessionReused(self) -> bool;
    extern "js" fn getSession(self) -> Option<JsValue>;
    extern "js" fn getFinished(self) -> Option<JsValue>;
    // merged from 5 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // merged from 5 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // property getter
    extern "js" fn encrypted(self) -> bool;
    extern "js" fn getProtocol(self) -> Option<String>;
    extern "js" fn enableTrace(self);
    // property setter
    extern "js" fn set_alpnProtocol(self, value: JsValue);
    // property getter
    extern "js" fn alpnProtocol(self) -> JsValue;
    extern "js" fn getTLSTicket(self) -> Option<JsValue>;
    // merged from 5 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // property getter
    extern "js" fn authorized(self) -> bool;
    // property setter
    extern "js" fn set_authorizationError(self, value: JsValue);
    extern "js" fn getPeerFinished(self) -> Option<JsValue>;
    // merged from 5 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
    // merged from 3 overloads
    extern "js" fn getPeerCertificate(self, detailed: bool) -> DetailedPeerCertificate;
    extern "js" fn setMaxSendFragment(self, size: f64) -> bool;
    extern "js" fn setKeyCert(self, context: JsValue);
    // merged from 5 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> TLSSocket;
}

impl TLSSocketOptions {
    #[getter]
    #[setter]
    extern "js" isServer: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" server: Option<Option<Server>>;
    #[getter]
    #[setter]
    extern "js" session: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" requestOCSP: Option<Option<bool>>;
}

impl TakeHeapSnapshotParameterType {
    #[getter]
    #[setter]
    extern "js" reportProgress: Option<Option<bool>>;
}

impl TakePreciseCoverageReturnType {
    #[getter]
    #[setter]
    extern "js" result: JsArray<ScriptCoverage>;
}

impl TargetCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" targetInfo: TargetInfo;
}

impl TargetInfo {
    #[getter]
    #[setter]
    extern "js" targetId: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" attached: bool;
    #[getter]
    #[setter]
    extern "js" canAccessOpener: bool;
}

impl TcpNetConnectOpts {
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl TcpSocketConnectOpts {
    #[getter]
    #[setter]
    extern "js" port: f64;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localAddress: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" localPort: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" hints: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" family: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" lookup: Option<Option<fn(String, LookupOptions, fn(Option<ErrnoException>, JsValue, f64) -> ()) -> ()>>;
    #[getter]
    #[setter]
    extern "js" noDelay: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAlive: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" keepAliveInitialDelay: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamily: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" autoSelectFamilyAttemptTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" blockList: Option<Option<BlockList>>;
}

impl TestComplete {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
}

impl TestContext {
    #[getter]
    extern "js" assert: TestContextAssert;
    #[getter]
    extern "js" attempt: f64;
    #[getter]
    extern "js" filePath: Option<String>;
    #[getter]
    extern "js" fullName: String;
    #[getter]
    extern "js" name: String;
    #[getter]
    extern "js" signal: JsValue;
    #[getter]
    #[setter]
    extern "js" test: JsValue;
    #[getter]
    extern "js" mock: MockTracker;

    extern "js" fn beforeEach(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn todo(self, message: Option<String>);
    extern "js" fn plan(self, count: f64, options: Option<TestContextPlanOptions>);
    extern "js" fn waitFor(self, condition: fn() -> JsValue, options: Option<TestContextWaitForOptions>) -> JsPromise<JsValue>;
    extern "js" fn after(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn skip(self, message: Option<String>);
    extern "js" fn runOnly(self, shouldRunOnlyTests: bool);
    extern "js" fn afterEach(self, fn_: Option<JsValue>, options: Option<HookOptions>);
    extern "js" fn diagnostic(self, message: String);
    extern "js" fn before(self, fn_: Option<JsValue>, options: Option<HookOptions>);
}

impl TestContextAssert {
    extern "js" fn fileSnapshot(self, value: JsValue, path: String, options: Option<AssertSnapshotOptions>);
    extern "js" fn snapshot(self, value: JsValue, options: Option<AssertSnapshotOptions>);
}

impl TestContextPlanOptions {
    #[getter]
    #[setter]
    extern "js" wait: Option<JsValue>;
}

impl TestContextWaitForOptions {
    #[getter]
    #[setter]
    extern "js" interval: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
}

impl TestCoverage {
    #[getter]
    #[setter]
    extern "js" summary: JsValue;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
}

impl TestDequeue {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl TestDiagnostic {
    #[getter]
    #[setter]
    extern "js" message: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" level: String;
}

impl TestEnqueue {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl TestFail {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
}

impl TestOptions {
    #[getter]
    #[setter]
    extern "js" concurrency: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" only: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" signal: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" timeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" plan: Option<Option<f64>>;
}

impl TestPass {
    #[getter]
    #[setter]
    extern "js" details: JsValue;
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" testNumber: f64;
    #[getter]
    #[setter]
    extern "js" todo: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" skip: Option<JsValue>;
}

impl TestPlan {
    #[getter]
    #[setter]
    extern "js" nesting: f64;
    #[getter]
    #[setter]
    extern "js" count: f64;
}

impl TestShard {
    #[getter]
    #[setter]
    extern "js" index: f64;
    #[getter]
    #[setter]
    extern "js" total: f64;
}

impl TestStart {
    #[getter]
    #[setter]
    extern "js" name: String;
    #[getter]
    #[setter]
    extern "js" nesting: f64;
}

impl TestStderr {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl TestStdout {
    #[getter]
    #[setter]
    extern "js" file: String;
    #[getter]
    #[setter]
    extern "js" message: String;
}

impl TestSummary {
    #[getter]
    #[setter]
    extern "js" counts: JsValue;
    #[getter]
    #[setter]
    extern "js" duration_ms: f64;
    #[getter]
    #[setter]
    extern "js" file: Option<String>;
    #[getter]
    #[setter]
    extern "js" success: bool;
}

impl TestsStream {
    // merged from 15 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn addListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn once(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn emit(self, event: String, data: Option<TestCoverage>) -> bool;
    // merged from 15 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
    // merged from 15 overloads
    extern "js" fn on(self, event: String, listener: fn(TestCoverage) -> ()) -> TestsStream;
}

impl TextDecoder {
    // property (readonly)
    extern "js" fn fatal(self) -> bool;
    extern "js" fn new(encoding: Option<String>, options: Option<JsValue>) -> TextDecoder;
    // property (readonly)
    extern "js" fn encoding(self) -> String;
    // property (readonly)
    extern "js" fn ignoreBOM(self) -> bool;
    extern "js" fn decode(self, input: Option<JsValue>, options: Option<JsValue>) -> String;
}

impl TextDecoderOptions {
    #[getter]
    #[setter]
    extern "js" fatal: Option<bool>;
    #[getter]
    #[setter]
    extern "js" ignoreBOM: Option<bool>;
}

impl TextDecoderStream {
    #[getter]
    extern "js" encoding: String;
    #[getter]
    extern "js" fatal: bool;
    #[getter]
    extern "js" ignoreBOM: bool;
    #[getter]
    extern "js" readable: ReadableStream<String>;
    #[getter]
    extern "js" writable: WritableStream<JsValue>;
}

impl TextEncoder {
    extern "js" fn encodeInto(self, src: String, dest: JsValue) -> EncodeIntoResult;
    // property (readonly)
    extern "js" fn encoding(self) -> String;
    extern "js" fn encode(self, input: Option<String>) -> JsValue;
}

impl TextEncoderStream {
    #[getter]
    extern "js" encoding: String;
    #[getter]
    extern "js" readable: ReadableStream<JsValue>;
    #[getter]
    extern "js" writable: WritableStream<String>;
}

impl Timeout {
    extern "js" fn refresh(self) -> Timeout;
    extern "js" fn close(self) -> Timeout;
    extern "js" fn ref(self) -> Timeout;
    extern "js" fn unref(self) -> Timeout;
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn _onTimeout(self, args: JsArray<JsValue>);
}

impl Timer {
    extern "js" fn hasRef(self) -> bool;
    extern "js" fn refresh(self) -> Timer;
}

impl TimerOptions {
    #[getter]
    #[setter]
    extern "js" ref: Option<Option<bool>>;
}

impl TimerifyOptions {
    #[getter]
    #[setter]
    extern "js" histogram: Option<Option<RecordableHistogram>>;
}

impl TlsOptions {
    #[getter]
    #[setter]
    extern "js" handshakeTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" sessionTimeout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" ticketKeys: Option<Option<Buffer>>;
    #[getter]
    #[setter]
    extern "js" pskCallback: Option<Option<fn(TLSSocket, String) -> Option<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" pskIdentityHint: Option<Option<String>>;
}

impl TlsaRecord {
    #[getter]
    #[setter]
    extern "js" certUsage: f64;
    #[getter]
    #[setter]
    extern "js" selector: f64;
    #[getter]
    #[setter]
    extern "js" match_: f64;
    #[getter]
    #[setter]
    extern "js" data: JsValue;
}

impl TraceConfig {
    #[getter]
    #[setter]
    extern "js" recordMode: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" includedCategories: JsArray<String>;
}

impl Tracing {
    #[getter]
    extern "js" categories: String;
    #[getter]
    extern "js" enabled: bool;

    extern "js" fn enable(self);
    extern "js" fn disable(self);
}

impl TracingChannel<StoreType, ContextType> {
    // property getter
    extern "js" fn asyncStart(self) -> Channel<StoreType, ContextType>;
    // property (readonly)
    extern "js" fn hasSubscribers(self) -> bool;
    // property setter
    extern "js" fn set_asyncStart(self, value: Channel<StoreType, ContextType>);
    // property getter
    extern "js" fn end(self) -> Channel<StoreType, ContextType>;
    // property setter
    extern "js" fn set_asyncEnd(self, value: Channel<StoreType, ContextType>);
    // property setter
    extern "js" fn set_start(self, value: Channel<StoreType, ContextType>);
    // property getter
    extern "js" fn start(self) -> Channel<StoreType, ContextType>;
    extern "js" fn tracePromise(self, fn_: JsFn, context: Option<ContextType>, thisArg: Option<ThisArg>, args: Args) -> JsPromise<Result>;
    extern "js" fn traceCallback(self, fn_: JsFn, position: Option<f64>, context: Option<ContextType>, thisArg: Option<ThisArg>, args: Args) -> Result;
    // property setter
    extern "js" fn set_end(self, value: Channel<StoreType, ContextType>);
    extern "js" fn subscribe(self, subscribers: TracingChannelSubscribers<ContextType>);
    // property getter
    extern "js" fn asyncEnd(self) -> Channel<StoreType, ContextType>;
    // property getter
    extern "js" fn error(self) -> Channel<StoreType, ContextType>;
    extern "js" fn unsubscribe(self, subscribers: TracingChannelSubscribers<ContextType>);
    // property setter
    extern "js" fn set_error(self, value: Channel<StoreType, ContextType>);
    extern "js" fn traceSync(self, fn_: JsFn, context: Option<ContextType>, thisArg: Option<ThisArg>, args: Args) -> Result;
}

impl TracingChannelCollection<StoreType, ContextType> {
    #[getter]
    #[setter]
    extern "js" start: Channel<StoreType, ContextType>;
    #[getter]
    #[setter]
    extern "js" end: Channel<StoreType, ContextType>;
    #[getter]
    #[setter]
    extern "js" asyncStart: Channel<StoreType, ContextType>;
    #[getter]
    #[setter]
    extern "js" asyncEnd: Channel<StoreType, ContextType>;
    #[getter]
    #[setter]
    extern "js" error: Channel<StoreType, ContextType>;
}

impl TracingChannelSubscribers<ContextType> {
    // function property
    extern "js" fn end(self) -> fn(ContextType) -> ();
    // function property
    extern "js" fn asyncStart(self) -> fn(ContextType) -> ();
    // function property
    extern "js" fn error(self) -> fn(ContextType) -> ();
    // function property
    extern "js" fn asyncEnd(self) -> fn(ContextType) -> ();
    // function property
    extern "js" fn start(self) -> fn(ContextType) -> ();
}

impl Transform {
    extern "js" fn new(opts: Option<TransformOptions>) -> Transform;
    extern "js" fn _transform(self, chunk: JsValue, encoding: JsValue, callback: fn(Option<JsValue>, JsValue) -> ());
    extern "js" fn _flush(self, callback: fn(Option<JsValue>, JsValue) -> ());
}

impl TransformOptions<T> {
    #[getter]
    #[setter]
    extern "js" transform: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<JsFn>>;
}

impl TransformStream<I, O> {
    #[getter]
    extern "js" readable: ReadableStream<O>;
    #[getter]
    extern "js" writable: WritableStream<I>;
}

impl TransformStreamDefaultController<O> {
    #[getter]
    extern "js" desiredSize: Option<f64>;

    extern "js" fn terminate(self);
    extern "js" fn enqueue(self, chunk: Option<O>);
    extern "js" fn error(self, reason: Option<JsValue>);
}

impl Transformer<I, O> {
    #[getter]
    #[setter]
    extern "js" flush: Option<TransformerFlushCallback<O>>;
    #[getter]
    #[setter]
    extern "js" readableType: Option<()>;
    #[getter]
    #[setter]
    extern "js" start: Option<TransformerStartCallback<O>>;
    #[getter]
    #[setter]
    extern "js" transform: Option<TransformerTransformCallback<I, O>>;
    #[getter]
    #[setter]
    extern "js" cancel: Option<TransformerCancelCallback>;
    #[getter]
    #[setter]
    extern "js" writableType: Option<()>;
}

impl URL {
    extern "js" fn canParse(input: String, base: Option<String>) -> bool;
    // property (readonly)
    extern "js" fn origin(self) -> String;
    // property setter
    extern "js" fn set_port(self, value: String);
    // property getter
    extern "js" fn username(self) -> String;
    // property getter
    extern "js" fn pathname(self) -> String;
    // property setter
    extern "js" fn set_password(self, value: String);
    extern "js" fn parse(input: String, base: Option<String>) -> Option<URL>;
    // property setter
    extern "js" fn set_href(self, value: String);
    // property getter
    extern "js" fn protocol(self) -> String;
    extern "js" fn new(input: JsValue, base: Option<JsValue>) -> URL;
    // property getter
    extern "js" fn hash(self) -> String;
    extern "js" fn toString(self) -> String;
    // property getter
    extern "js" fn password(self) -> String;
    extern "js" fn toJSON(self) -> String;
    // property getter
    extern "js" fn search(self) -> String;
    // property setter
    extern "js" fn set_pathname(self, value: String);
    // property setter
    extern "js" fn set_search(self, value: String);
    // property setter
    extern "js" fn set_hash(self, value: String);
    // property getter
    extern "js" fn hostname(self) -> String;
    // property setter
    extern "js" fn set_protocol(self, value: String);
    // property getter
    extern "js" fn port(self) -> String;
    extern "js" fn revokeObjectURL(id: String);
    // property (readonly)
    extern "js" fn searchParams(self) -> URLSearchParams;
    // property getter
    extern "js" fn host(self) -> String;
    extern "js" fn createObjectURL(blob: JsValue) -> String;
    // property getter
    extern "js" fn href(self) -> String;
    // property setter
    extern "js" fn set_hostname(self, value: String);
    // property setter
    extern "js" fn set_username(self, value: String);
    // property setter
    extern "js" fn set_host(self, value: String);
}

impl URLFormatOptions {
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" fragment: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" search: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" unicode: Option<Option<bool>>;
}

impl URLPattern {
    // property (readonly)
    extern "js" fn protocol(self) -> String;
    extern "js" fn test(self, input: Option<JsValue>, baseURL: Option<String>) -> bool;
    // property (readonly)
    extern "js" fn pathname(self) -> String;
    // property (readonly)
    extern "js" fn hasRegExpGroups(self) -> bool;
    extern "js" fn exec(self, input: Option<JsValue>, baseURL: Option<String>) -> Option<URLPatternResult>;
    // merged from 2 overloads
    extern "js" fn new(input: JsValue, baseURL: String, options: Option<URLPatternOptions>) -> URLPattern;
    // property (readonly)
    extern "js" fn password(self) -> String;
    // property (readonly)
    extern "js" fn username(self) -> String;
    // property (readonly)
    extern "js" fn port(self) -> String;
    // property (readonly)
    extern "js" fn hash(self) -> String;
    // property (readonly)
    extern "js" fn hostname(self) -> String;
    // property (readonly)
    extern "js" fn search(self) -> String;
}

impl URLPatternComponentResult {
    #[getter]
    #[setter]
    extern "js" input: String;
    #[getter]
    #[setter]
    extern "js" groups: JsValue;
}

impl URLPatternInit {
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" username: Option<String>;
    #[getter]
    #[setter]
    extern "js" password: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" baseURL: Option<String>;
}

impl URLPatternOptions {
    #[getter]
    #[setter]
    extern "js" ignoreCase: Option<bool>;
}

impl URLPatternResult {
    #[getter]
    #[setter]
    extern "js" inputs: JsArray<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" username: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" password: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" hostname: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" port: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" pathname: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" search: URLPatternComponentResult;
    #[getter]
    #[setter]
    extern "js" hash: URLPatternComponentResult;
}

impl URLSearchParams {
    extern "js" fn new(init: Option<JsValue>) -> URLSearchParams;
    extern "js" fn getAll(self, name: String) -> JsArray<String>;
    extern "js" fn toString(self) -> String;
    extern "js" fn values(self) -> URLSearchParamsIterator<String>;
    extern "js" fn forEach(self, fn_: JsFn, thisArg: Option<TThis>);
    extern "js" fn entries(self) -> URLSearchParamsIterator<(String, String)>;
    extern "js" fn append(self, name: String, value: String);
    extern "js" fn has(self, name: String, value: Option<String>) -> bool;
    extern "js" fn set(self, name: String, value: String);
    extern "js" fn keys(self) -> URLSearchParamsIterator<String>;
    extern "js" fn delete(self, name: String, value: Option<String>);
    extern "js" fn get(self, name: String) -> Option<String>;
    // property (readonly)
    extern "js" fn size(self) -> f64;
    extern "js" fn sort(self);
}

impl UVMetrics {
    #[getter]
    extern "js" loopCount: f64;
    #[getter]
    extern "js" events: f64;
    #[getter]
    extern "js" eventsWaiting: f64;
}

impl UnderlyingByteSource {
    #[getter]
    #[setter]
    extern "js" autoAllocateChunkSize: Option<f64>;
    #[getter]
    #[setter]
    extern "js" cancel: Option<ReadableStreamErrorCallback>;
    #[getter]
    #[setter]
    extern "js" pull: Option<ReadableByteStreamControllerCallback>;
    #[getter]
    #[setter]
    extern "js" start: Option<ReadableByteStreamControllerCallback>;
    #[getter]
    #[setter]
    extern "js" type_: String;
}

impl UnderlyingSink<W> {
    #[getter]
    #[setter]
    extern "js" abort: Option<UnderlyingSinkAbortCallback>;
    #[getter]
    #[setter]
    extern "js" close: Option<UnderlyingSinkCloseCallback>;
    #[getter]
    #[setter]
    extern "js" start: Option<UnderlyingSinkStartCallback>;
    #[getter]
    #[setter]
    extern "js" type_: Option<()>;
    #[getter]
    #[setter]
    extern "js" write: Option<UnderlyingSinkWriteCallback<W>>;
}

impl UnderlyingSource<R> {
    #[getter]
    #[setter]
    extern "js" cancel: Option<UnderlyingSourceCancelCallback>;
    #[getter]
    #[setter]
    extern "js" pull: Option<UnderlyingSourcePullCallback<R>>;
    #[getter]
    #[setter]
    extern "js" start: Option<UnderlyingSourceStartCallback<R>>;
    #[getter]
    #[setter]
    extern "js" type_: Option<()>;
}

impl UndiciError {
    // property getter
    extern "js" fn name(self) -> String;
    // property setter
    extern "js" fn set_name(self, value: String);
    // property setter
    extern "js" fn set_code(self, value: String);
    // property getter
    extern "js" fn code(self) -> String;
}

impl UpgradeData<TOpaque> {
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
    #[getter]
    #[setter]
    extern "js" headers: IncomingHttpHeaders;
    #[getter]
    #[setter]
    extern "js" socket: Duplex;
    #[getter]
    #[setter]
    extern "js" opaque: TOpaque;
}

impl UpgradeOptions {
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" path: String;
    #[getter]
    #[setter]
    extern "js" method: Option<String>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" redirectionLimitReached: Option<bool>;
    #[getter]
    #[setter]
    extern "js" responseHeaders: Option<Option<String>>;
}

impl Url {
    #[getter]
    #[setter]
    extern "js" auth: Option<String>;
    #[getter]
    #[setter]
    extern "js" hash: Option<String>;
    #[getter]
    #[setter]
    extern "js" host: Option<String>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<String>;
    #[getter]
    #[setter]
    extern "js" href: String;
    #[getter]
    #[setter]
    extern "js" path: Option<String>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<String>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<String>;
    #[getter]
    #[setter]
    extern "js" search: Option<String>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<bool>;
    #[getter]
    #[setter]
    extern "js" port: Option<String>;
    #[getter]
    #[setter]
    extern "js" query: JsValue;
}

impl UrlObject {
    #[getter]
    #[setter]
    extern "js" auth: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hash: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" host: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" hostname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" href: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" pathname: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" protocol: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" search: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" slashes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" port: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" query: Option<JsValue>;
}

impl UrlWithParsedQuery {
    #[getter]
    #[setter]
    extern "js" query: ParsedUrlQuery;
}

impl UrlWithStringQuery {
    #[getter]
    #[setter]
    extern "js" query: Option<String>;
}

impl UserInfo<T> {
    #[getter]
    #[setter]
    extern "js" username: T;
    #[getter]
    #[setter]
    extern "js" uid: f64;
    #[getter]
    #[setter]
    extern "js" gid: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<T>;
    #[getter]
    #[setter]
    extern "js" homedir: T;
}

impl UserInfoOptions {
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
}

impl UserInfoOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: String;
}

impl UserInfoOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl Utf8Stream {
    // merged from 8 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    extern "js" fn reopen(self, file: JsValue);
    // merged from 8 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn periodicFlush(self) -> f64;
    extern "js" fn new(options: Utf8StreamOptions) -> Utf8Stream;
    // property (readonly)
    extern "js" fn mkdir(self) -> bool;
    // property (readonly)
    extern "js" fn sync(self) -> bool;
    // property (readonly)
    extern "js" fn writing(self) -> bool;
    extern "js" fn destroy(self);
    // merged from 8 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // property (readonly)
    extern "js" fn append(self) -> bool;
    // property (readonly)
    extern "js" fn contentMode(self) -> String;
    extern "js" fn write(self, data: JsValue) -> bool;
    // property (readonly)
    extern "js" fn maxLength(self) -> f64;
    // property (readonly)
    extern "js" fn fsync(self) -> bool;
    // property (readonly)
    extern "js" fn file(self) -> String;
    // property (readonly)
    extern "js" fn fd(self) -> f64;
    extern "js" fn end(self);
    // property (readonly)
    extern "js" fn minLength(self) -> f64;
    extern "js" fn flush(self, callback: fn(Option<JsValue>) -> ());
    // property (readonly)
    extern "js" fn mode(self) -> JsValue;
    // merged from 8 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    // merged from 8 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Utf8Stream;
    extern "js" fn flushSync(self);
}

impl Utf8StreamOptions {
    #[getter]
    #[setter]
    extern "js" append: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" contentMode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dest: Option<Option<String>>;
    #[getter]
    #[setter]
    extern "js" fd: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" fsync: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" maxWrite: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" minLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" mkdir: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" mode: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" periodicFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" retryEAGAIN: Option<Option<fn(Option<JsValue>, f64, f64) -> bool>>;
    #[getter]
    #[setter]
    extern "js" sync: Option<Option<bool>>;
}

impl Verify {
    // merged from 2 overloads
    extern "js" fn verify(self, object: JsValue, signature: String, signature_format: Option<String>) -> bool;
    extern "js" fn new() -> Verify;
    // merged from 2 overloads
    extern "js" fn update(self, data: String, inputEncoding: Option<JsValue>) -> Verify;
}

impl VerifyKeyObjectInput {
    #[getter]
    #[setter]
    extern "js" key: KeyObject;
}

impl WASI {
    extern "js" fn initialize(self, instance: JsValue);
    // property (readonly)
    extern "js" fn wasiImport(self) -> Dict<JsValue>;
    extern "js" fn new(options: Option<WASIOptions>) -> WASI;
    extern "js" fn getImportObject(self) -> JsValue;
    extern "js" fn start(self, instance: JsValue) -> f64;
    extern "js" fn finalizeBindings(self, instance: JsValue, options: Option<FinalizeBindingsOptions>);
}

impl WASIOptions {
    #[getter]
    #[setter]
    extern "js" args: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" env: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" preopens: Option<Option<Dict<String>>>;
    #[getter]
    #[setter]
    extern "js" returnOnExit: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdin: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" version: String;
}

impl WatchFileOptions {
    #[getter]
    #[setter]
    extern "js" bigint: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" interval: Option<Option<f64>>;
}

impl WatchOptions {
    #[getter]
    #[setter]
    extern "js" maxQueue: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" overflow: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" persistent: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" recursive: Option<Option<bool>>;
}

impl WatchOptionsWithBufferEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: String;
    #[getter]
    #[setter]
    extern "js" encoding: String;
}

impl WatchOptionsWithStringEncoding {
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" encoding: Option<Option<JsValue>>;
}

impl WebSocket {
    #[getter]
    #[setter]
    extern "js" binaryType: String;
    #[getter]
    extern "js" bufferedAmount: f64;
    #[getter]
    extern "js" extensions: String;
    #[getter]
    #[setter]
    extern "js" onclose: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onerror: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onmessage: Option<JsFn>;
    #[getter]
    #[setter]
    extern "js" onopen: Option<JsFn>;
    #[getter]
    extern "js" protocol: String;
    #[getter]
    extern "js" readyState: f64;
    #[getter]
    extern "js" url: String;
    #[getter]
    extern "js" CLOSED: f64;
    #[getter]
    extern "js" CLOSING: f64;
    #[getter]
    extern "js" CONNECTING: f64;
    #[getter]
    extern "js" OPEN: f64;

    extern "js" fn close(self, code: Option<f64>, reason: Option<String>);
    // merged from 2 overloads
    extern "js" fn addEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
    extern "js" fn send(self, data: JsValue);
    // merged from 2 overloads
    extern "js" fn removeEventListener(self, type_: JsValue, listener: JsFn, options: Option<JsValue>);
}

impl WebSocketCloseInfo {
    #[getter]
    #[setter]
    extern "js" closeCode: f64;
    #[getter]
    #[setter]
    extern "js" reason: String;
}

impl WebSocketClosedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
}

impl WebSocketCreatedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" url: String;
    #[getter]
    #[setter]
    extern "js" initiator: Initiator;
}

impl WebSocketEventMap {
    #[getter]
    #[setter]
    extern "js" close: CloseEvent;
    #[getter]
    #[setter]
    extern "js" error: ErrorEvent;
    #[getter]
    #[setter]
    extern "js" message: MessageEvent;
    #[getter]
    #[setter]
    extern "js" open: Event;
}

impl WebSocketHandshakeResponseReceivedEventDataType {
    #[getter]
    #[setter]
    extern "js" requestId: String;
    #[getter]
    #[setter]
    extern "js" timestamp: f64;
    #[getter]
    #[setter]
    extern "js" response: WebSocketResponse;
}

impl WebSocketInit {
    #[getter]
    #[setter]
    extern "js" protocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" dispatcher: Option<Dispatcher>;
    #[getter]
    #[setter]
    extern "js" headers: Option<JsValue>;
}

impl WebSocketResponse {
    #[getter]
    #[setter]
    extern "js" status: f64;
    #[getter]
    #[setter]
    extern "js" statusText: String;
    #[getter]
    #[setter]
    extern "js" headers: Headers;
}

impl WebSocketStream {
    #[getter]
    #[setter]
    extern "js" closed: JsPromise<WebSocketCloseInfo>;
    #[getter]
    #[setter]
    extern "js" opened: JsPromise<JsValue>;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl WebSocketStreamOptions {
    #[getter]
    #[setter]
    extern "js" protocols: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" signal: Option<JsValue>;
}

impl Worker {
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // property setter
    extern "js" fn set_process(self, value: ChildProcess);
    extern "js" fn destroy(self, signal: Option<String>);
    extern "js" fn disconnect(self) -> Worker;
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, code: Option<f64>, signal: Option<String>) -> bool;
    // property setter
    extern "js" fn set_id(self, value: f64);
    extern "js" fn isDead(self) -> bool;
    // property getter
    extern "js" fn exitedAfterDisconnect(self) -> bool;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // property getter
    extern "js" fn id(self) -> f64;
    extern "js" fn isConnected(self) -> bool;
    extern "js" fn kill(self, signal: Option<String>);
    // property setter
    extern "js" fn set_exitedAfterDisconnect(self, value: bool);
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // merged from 3 overloads
    extern "js" fn send(self, message: JsValue, sendHandle: JsValue, options: Option<MessageOptions>, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // property getter
    extern "js" fn process(self) -> ChildProcess;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn(JsArray<JsValue>) -> ()) -> Worker;
}

impl WorkerInfo {
    #[getter]
    #[setter]
    extern "js" workerId: String;
    #[getter]
    #[setter]
    extern "js" type_: String;
    #[getter]
    #[setter]
    extern "js" title: String;
    #[getter]
    #[setter]
    extern "js" url: String;
}

impl WorkerOptions {
    #[getter]
    #[setter]
    extern "js" argv: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" env: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" eval: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" workerData: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" stdin: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stdout: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" stderr: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" execArgv: Option<Option<JsArray<String>>>;
    #[getter]
    #[setter]
    extern "js" resourceLimits: Option<Option<ResourceLimits>>;
    #[getter]
    #[setter]
    extern "js" transferList: Option<Option<JsArray<JsValue>>>;
    #[getter]
    #[setter]
    extern "js" trackUnmanagedFds: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" name: Option<Option<String>>;
}

impl WorkerPerformance {
    #[getter]
    #[setter]
    extern "js" eventLoopUtilization: JsValue;
}

impl Writable {
    // property (readonly)
    extern "js" fn errored(self) -> Option<JsValue>;
    extern "js" fn uncork(self);
    extern "js" fn setDefaultEncoding(self, encoding: JsValue) -> Writable;
    extern "js" fn _write(self, chunk: JsValue, encoding: JsValue, callback: fn(Option<JsValue>) -> ());
    // property (readonly)
    extern "js" fn writableCorked(self) -> f64;
    // merged from 7 overloads
    extern "js" fn prependOnceListener(self, event: String, listener: fn() -> ()) -> Writable;
    // property getter
    extern "js" fn destroyed(self) -> bool;
    // property (readonly)
    extern "js" fn writableHighWaterMark(self) -> f64;
    extern "js" fn _final(self, callback: fn(Option<JsValue>) -> ());
    // merged from 7 overloads
    extern "js" fn addListener(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 7 overloads
    extern "js" fn prependListener(self, event: String, listener: fn() -> ()) -> Writable;
    // merged from 2 overloads
    extern "js" fn write(self, chunk: JsValue, encoding: JsValue, callback: Option<fn(Option<JsValue>) -> ()>) -> bool;
    extern "js" fn _destroy(self, error: Option<JsValue>, callback: fn(Option<JsValue>) -> ());
    extern "js" fn cork(self);
    // merged from 7 overloads
    extern "js" fn emit(self, event: String, err: Option<JsValue>) -> bool;
    // property (readonly)
    extern "js" fn writableNeedDrain(self) -> bool;
    // property (readonly)
    extern "js" fn writableAborted(self) -> bool;
    // merged from 7 overloads
    extern "js" fn removeListener(self, event: String, listener: fn() -> ()) -> Writable;
    // property setter
    extern "js" fn set_destroyed(self, value: bool);
    // merged from 7 overloads
    extern "js" fn on(self, event: String, listener: fn() -> ()) -> Writable;
    extern "js" fn _construct(self, callback: fn(Option<JsValue>) -> ());
    // merged from 7 overloads
    extern "js" fn once(self, event: String, listener: fn() -> ()) -> Writable;
    extern "js" fn fromWeb(writableStream: WritableStream, options: Option<JsValue>) -> Writable;
    extern "js" fn _writev(self, chunks: JsArray<JsValue>, callback: fn(Option<JsValue>) -> ());
    // property (readonly)
    extern "js" fn writableFinished(self) -> bool;
    // property (readonly)
    extern "js" fn writableLength(self) -> f64;
    // merged from 3 overloads
    extern "js" fn end(self, chunk: JsValue, encoding: Option<JsValue>, cb: Option<fn() -> ()>) -> Writable;
    // property (readonly)
    extern "js" fn writableEnded(self) -> bool;
    // property (readonly)
    extern "js" fn writable(self) -> bool;
    extern "js" fn new(opts: Option<WritableOptions>) -> Writable;
    extern "js" fn destroy(self, error: Option<JsValue>) -> Writable;
    extern "js" fn toWeb(streamWritable: Writable) -> WritableStream;
    // property (readonly)
    extern "js" fn closed(self) -> bool;
    // property (readonly)
    extern "js" fn writableObjectMode(self) -> bool;
}

impl WritableOptions<T> {
    #[getter]
    #[setter]
    extern "js" decodeStrings: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" defaultEncoding: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" write: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" writev: Option<Option<JsFn>>;
    #[getter]
    #[setter]
    extern "js" final: Option<Option<JsFn>>;
}

impl WritableStream {
    #[getter]
    extern "js" locked: bool;
    #[getter]
    #[setter]
    extern "js" writable: bool;

    // merged from 2 overloads
    extern "js" fn write(self, str: String, encoding: Option<String>, cb: Option<fn(Option<JsValue>) -> ()>) -> bool;
    // merged from 3 overloads
    extern "js" fn end(self, str: String, encoding: Option<String>, cb: Option<fn() -> ()>) -> WritableStream;
}

impl WritableStreamDefaultController {
    extern "js" fn error(self, e: Option<JsValue>);
}

impl WritableStreamDefaultWriter<W> {
    #[getter]
    extern "js" closed: JsPromise<()>;
    #[getter]
    extern "js" desiredSize: Option<f64>;
    #[getter]
    extern "js" ready: JsPromise<()>;

    extern "js" fn abort(self, reason: Option<JsValue>) -> JsPromise<()>;
    extern "js" fn write(self, chunk: Option<W>) -> JsPromise<()>;
    extern "js" fn close(self) -> JsPromise<()>;
    extern "js" fn releaseLock(self);
}

impl WriteOptions {
    #[getter]
    #[setter]
    extern "js" offset: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" length: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" position: Option<Option<f64>>;
}

impl WriteStream {
    extern "js" fn close(self, callback: Option<fn(Option<ErrnoException>) -> ()>);
    // property getter
    extern "js" fn bytesWritten(self) -> f64;
    // property setter
    extern "js" fn set_bytesWritten(self, value: f64);
    // property setter
    extern "js" fn set_pending(self, value: bool);
    extern "js" fn once(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn prependListener(self, event: K, listener: JsValue) -> WriteStream;
    extern "js" fn prependOnceListener(self, event: K, listener: JsValue) -> WriteStream;
    // property getter
    extern "js" fn path(self) -> JsValue;
    // property setter
    extern "js" fn set_path(self, value: JsValue);
    extern "js" fn on(self, event: K, listener: JsValue) -> WriteStream;
    // property getter
    extern "js" fn pending(self) -> bool;
    extern "js" fn addListener(self, event: K, listener: JsValue) -> WriteStream;
}

impl WriteStreamOptions {
    #[getter]
    #[setter]
    extern "js" fs: Option<Option<CreateWriteStreamFSImplementation>>;
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<bool>>;
}

impl WriteVResult<T> {
    #[getter]
    #[setter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" buffers: T;
}

impl X25519KeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl X448KeyPairOptions<PubF, PrivF> {
    #[getter]
    #[setter]
    extern "js" publicKeyEncoding: JsValue;
    #[getter]
    #[setter]
    extern "js" privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF>;
}

impl X509Certificate {
    // property (readonly)
    extern "js" fn fingerprint512(self) -> String;
    extern "js" fn new(buffer: JsValue) -> X509Certificate;
    // property (readonly)
    extern "js" fn signatureAlgorithmOid(self) -> String;
    // property (readonly)
    extern "js" fn serialNumber(self) -> String;
    extern "js" fn checkHost(self, name: String, options: Option<X509CheckOptions>) -> Option<String>;
    // property (readonly)
    extern "js" fn validToDate(self) -> JsValue;
    // property (readonly)
    extern "js" fn signatureAlgorithm(self) -> Option<String>;
    // property (readonly)
    extern "js" fn keyUsage(self) -> JsArray<String>;
    extern "js" fn verify(self, publicKey: KeyObject) -> bool;
    // property (readonly)
    extern "js" fn validTo(self) -> String;
    // property (readonly)
    extern "js" fn issuerCertificate(self) -> Option<X509Certificate>;
    extern "js" fn checkEmail(self, email: String, options: Option<JsValue>) -> Option<String>;
    // property (readonly)
    extern "js" fn subject(self) -> String;
    // property (readonly)
    extern "js" fn subjectAltName(self) -> Option<String>;
    extern "js" fn toString(self) -> String;
    // property (readonly)
    extern "js" fn raw(self) -> JsValue;
    // property (readonly)
    extern "js" fn publicKey(self) -> KeyObject;
    extern "js" fn toJSON(self) -> String;
    extern "js" fn toLegacyObject(self) -> PeerCertificate;
    extern "js" fn checkIssued(self, otherCert: X509Certificate) -> bool;
    // property (readonly)
    extern "js" fn fingerprint(self) -> String;
    extern "js" fn checkPrivateKey(self, privateKey: KeyObject) -> bool;
    // property (readonly)
    extern "js" fn infoAccess(self) -> Option<String>;
    extern "js" fn checkIP(self, ip: String) -> Option<String>;
    // property (readonly)
    extern "js" fn validFrom(self) -> String;
    // property (readonly)
    extern "js" fn validFromDate(self) -> JsValue;
    // property (readonly)
    extern "js" fn issuer(self) -> String;
    // property (readonly)
    extern "js" fn ca(self) -> bool;
    // property (readonly)
    extern "js" fn fingerprint256(self) -> String;
}

impl X509CheckOptions {
    #[getter]
    #[setter]
    extern "js" subject: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" wildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" partialWildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" multiLabelWildcards: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" singleLabelSubdomains: Option<Option<bool>>;
}

impl Zlib {
    #[getter]
    extern "js" bytesWritten: f64;
    #[getter]
    #[setter]
    extern "js" shell: Option<JsValue>;

    // merged from 2 overloads
    extern "js" fn flush(self, kind: Option<f64>, callback: Option<fn() -> ()>);
    extern "js" fn close(self, callback: Option<fn() -> ()>);
}

impl ZlibOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" windowBits: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" level: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" memLevel: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" strategy: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" dictionary: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
}

impl ZlibParams {
    extern "js" fn params(self, level: f64, strategy: f64, callback: fn() -> ());
}

impl ZlibReset {
    extern "js" fn reset(self);
}

impl ZstdOptions {
    #[getter]
    #[setter]
    extern "js" flush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" finishFlush: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" chunkSize: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" params: Option<Option<JsValue>>;
    #[getter]
    #[setter]
    extern "js" maxOutputLength: Option<Option<f64>>;
    #[getter]
    #[setter]
    extern "js" info: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" dictionary: Option<Option<JsValue>>;
}

impl _GlobOptions<T> {
    #[getter]
    #[setter]
    extern "js" cwd: Option<JsValue>;
    #[getter]
    #[setter]
    extern "js" withFileTypes: Option<Option<bool>>;
    #[getter]
    #[setter]
    extern "js" exclude: Option<JsValue>;
}

impl ucs2 {
    extern "js" fn encode(self, codePoints: JsArray<f64>) -> String;
    extern "js" fn decode(self, string: String) -> JsArray<f64>;
}
